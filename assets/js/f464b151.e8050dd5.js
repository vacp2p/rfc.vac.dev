"use strict";(self.webpackChunklogos_docs_template=self.webpackChunklogos_docs_template||[]).push([[6778],{27588:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>p,default:()=>d,frontMatter:()=>r,metadata:()=>o,toc:()=>s});var n=a(87462),i=(a(67294),a(3905));const r={title:"LIBP2P-MIX",name:"Libp2p Mix Protocol",status:"raw",category:"Standards Track",editor:"Akshaya Mani &lt;akshaya@status.im&gt;",contributors:null},p=void 0,o={unversionedId:"raw/mix",id:"raw/mix",title:"LIBP2P-MIX",description:"- Status: raw",source:"@site/vac/raw/mix.md",sourceDirName:"raw",slug:"/raw/mix",permalink:"/vac/raw/mix",draft:!1,tags:[],version:"current",frontMatter:{title:"LIBP2P-MIX",name:"Libp2p Mix Protocol",status:"raw",category:"Standards Track",editor:"Akshaya Mani &lt;akshaya@status.im&gt;",contributors:null},sidebar:"defaultSidebar",previous:{title:"GOSSIPSUB-TOR-PUSH",permalink:"/vac/raw/gossipsub-tor-push"},next:{title:"RLN-INTEREP-SPEC",permalink:"/vac/raw/rln-interep-spec"}},l={},s=[{value:"Abstract",id:"abstract",level:2},{value:"Background",id:"background",level:2},{value:"Specification",id:"specification",level:2},{value:"1. Protocol Identifier",id:"1-protocol-identifier",level:3},{value:"2. Custom Mix Protocol",id:"2-custom-mix-protocol",level:3},{value:"2.1 Mix Nodes Roles",id:"21-mix-nodes-roles",level:4},{value:"2.2 Roles Flexibility",id:"22-roles-flexibility",level:4},{value:"2.3 Incentives",id:"23-incentives",level:4},{value:"2.4 Node Discovery",id:"24-node-discovery",level:4},{value:"2.5 Protocol Registration",id:"25-protocol-registration",level:4},{value:"2.6 Transport Layer",id:"26-transport-layer",level:4},{value:"2.7 Connection Establishment",id:"27-connection-establishment",level:4},{value:"3. Cryptographic Primitives and Security Parameter",id:"3-cryptographic-primitives-and-security-parameter",level:3},{value:"4. Sphinx Packet Format",id:"4-sphinx-packet-format",level:3},{value:"4.1 Packet Components and Sizes",id:"41-packet-components-and-sizes",level:4},{value:"4.2 Address Format and Delay Specification",id:"42-address-format-and-delay-specification",level:4},{value:"4.3 Message Format",id:"43-message-format",level:4},{value:"5. Handler Function",id:"5-handler-function",level:3},{value:"5.1 Sender",id:"51-sender",level:4},{value:"5.2 Intermediary Mix Node",id:"52-intermediary-mix-node",level:4},{value:"5.3 Exit Node",id:"53-exit-node",level:4},{value:"Copyright",id:"copyright",level:2},{value:"References",id:"references",level:2},{value:"Normative",id:"normative",level:3},{value:"Informative",id:"informative",level:3},{value:"Appendix A. Example Spam Protection using Proof of Work",id:"appendix-a-example-spam-protection-using-proof-of-work",level:2},{value:"Structure",id:"structure",level:3},{value:"Calculate Proof of Work (PoW)",id:"calculate-proof-of-work-pow",level:3},{value:"Attach the PoW to the libp2p Message",id:"attach-the-pow-to-the-libp2p-message",level:3},{value:"Verify PoW",id:"verify-pow",level:3}],m={toc:s};function d(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Status: raw"),(0,i.kt)("li",{parentName:"ul"},"Category: Standards Track"),(0,i.kt)("li",{parentName:"ul"},"Editor: Akshaya Mani ","<",(0,i.kt)("a",{parentName:"li",href:"mailto:akshaya@status.im"},"akshaya@status.im"),">")),(0,i.kt)("h2",{id:"abstract"},"Abstract"),(0,i.kt)("p",null,"This document specifies the Mix protocol, a custom protocol within the\n",(0,i.kt)("a",{parentName:"p",href:"https://libp2p.io"},"libp2p")," framework designed to enable anonymous communication\nin peer-to-peer networks. The Mix protocol allows libp2p nodes to send messages\nwithout revealing the sender's identity to intermediary nodes or the recipient.\nIt achieves this by using the ",(0,i.kt)("a",{parentName:"p",href:"https://www.researchgate.net/publication/220713667_Sphinx_A_Compact_and_Provably_Secure_Mix_Format"},"Sphinx packet format"),",\nwhich encrypts and routes messages through a series of nodes (mix nodes)\nbefore reaching the recipient."),(0,i.kt)("p",null,"Key features of the protocol include:"),(0,i.kt)("p",null,"i. Path selection for choosing a random route through the network via multiple\nmix nodes.\\\nii. Sphinx packet construction and processing, providing cryptographic\nguarantees of anonymity and security.\\\niii. Pluggable spam protection mechanism to prevent abuse of the mix network.\\\niv. Delayed message forwarding to thwart timing analysis attacks."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Protocol identifier:")," ",(0,i.kt)("inlineCode",{parentName:"p"},'"/mix/1.0.0"')),(0,i.kt)("p",null,"Note: The Mix Protocol is designed to work alongside existing libp2p protocols,\nallowing for seamless integration with current libp2p applications while\nproviding enhanced privacy features. For example, it can encapsulate messages\nfrom protocols like ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/libp2p/specs/blob/master/pubsub/gossipsub/gossipsub-v1.2"},"GossipSub"),"\nto ensure sender anonymity."),(0,i.kt)("h2",{id:"background"},"Background"),(0,i.kt)("p",null,"libp2p protocols do not inherently protect sender identities."),(0,i.kt)("p",null,"The Mix protocol enhances anonymity in libp2p by implementing a mix network,\nwhere messages are anonymized through multiple relay nodes before reaching the\nintended recipient. The Sphinx packet format is a well-researched component which\nthis specification leverages to offer strong anonymity properties by concealing\nsender and recipient information at each relay."),(0,i.kt)("p",null,"Using this approach, even the nodes relaying messages cannot determine the\nsender or final recipient, within a robust adversarial model. This decentralized\nsolution distributes trust among participants, eliminating single points of\nfailure and enhancing overall network resilience. Additionally, pluggable\nspam protection mechanism and delayed forwarding address common attacks on\nanonymity networks, such as spam and timing analysis."),(0,i.kt)("p",null,"The Mix protocol is designed with flexibility in mind, allowing for\npluggable components such as spam protection, peer discovery, and\nincentivization mechanisms. This design choice enables the protocol to evolve\nand adapt to different network requirements and constraints. This also leaves\nroom for future enhancements such as cover traffic generation."),(0,i.kt)("p",null,"By incorporating these features, the Mix protocol aims to provide a robust\nanonymity layer within the libp2p ecosystem, enabling developers to easily\nincorporate privacy features into their applications."),(0,i.kt)("h2",{id:"specification"},"Specification"),(0,i.kt)("h3",{id:"1-protocol-identifier"},"1. Protocol Identifier"),(0,i.kt)("p",null,"The Mix protocol is identified by the string ",(0,i.kt)("inlineCode",{parentName:"p"},'"/mix/1.0.0"'),"."),(0,i.kt)("h3",{id:"2-custom-mix-protocol"},"2. Custom Mix Protocol"),(0,i.kt)("p",null,"The Mix protocol is designed as a standalone protocol,\nidentified by the protocol identifier ",(0,i.kt)("inlineCode",{parentName:"p"},'"/mix/1.0.0"'),".\nThis approach allows the Mix protocol to operate independently,\ndecoupled from specific applications,\nproviding greater flexibility and reusability across various libp2p protocols.\nBy doing so, the Mix protocol can evolve independently,\nfocusing on its core functionality without being tied to the development\nand maintenance cycles of other protocols."),(0,i.kt)("h4",{id:"21-mix-nodes-roles"},"2.1 Mix Nodes Roles"),(0,i.kt)("p",null,"All nodes participating in the Mix protocol are considered as mix nodes. They\nhave the capability to create/process and forward Sphinx packets. Mix nodes can\nplay different roles depending on their position in a particular message path:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Sender Node"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"A mix node that initiates the anonymous message publishing process."),(0,i.kt)("li",{parentName:"ul"},"Responsible for:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Path selection."),(0,i.kt)("li",{parentName:"ul"},"Sphinx packet creation."),(0,i.kt)("li",{parentName:"ul"},"Initiating the message routing through the mix network."))),(0,i.kt)("li",{parentName:"ul"},"Must run both the Mix protocol instance and the instance of the libp2p\nprotocol for the message being published (",(0,i.kt)("em",{parentName:"li"},"e.g.,")," GossipSub, Ping, etc.)."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Intermediary Mix Node"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"A mix node that is neither the sender nor the exit node in a message path."),(0,i.kt)("li",{parentName:"ul"},"Responsible for:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Receiving Sphinx packets."),(0,i.kt)("li",{parentName:"ul"},"Processing (decrypting and re-encrypting) Sphinx packets."),(0,i.kt)("li",{parentName:"ul"},"Forwarding processed packets to the next node in the path."))),(0,i.kt)("li",{parentName:"ul"},"Only needs to run the Mix protocol instance."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Exit Node"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"The final mix node in a message path."),(0,i.kt)("li",{parentName:"ul"},"Responsible for:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Receiving and processing the final Sphinx packet."),(0,i.kt)("li",{parentName:"ul"},"Extracting the original message."),(0,i.kt)("li",{parentName:"ul"},"Disseminating the decrypted message using the appropriate libp2p protocol."))),(0,i.kt)("li",{parentName:"ul"},"Must run both the Mix protocol instance and the instance of the libp2p\nprotocol for the message being published.")))),(0,i.kt)("h4",{id:"22-roles-flexibility"},"2.2 Roles Flexibility"),(0,i.kt)("p",null,"A single mix node can play different roles in different paths:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"It can be a sender node for messages it initiates."),(0,i.kt)("li",{parentName:"ul"},"It can be an intermediary node for messages it is forwarding."),(0,i.kt)("li",{parentName:"ul"},"It can be an exit node for messages it is disseminating.")),(0,i.kt)("h4",{id:"23-incentives"},"2.3 Incentives"),(0,i.kt)("p",null,"To publish an anonymous libp2p message (",(0,i.kt)("em",{parentName:"p"},"e.g.,")," GossipSub, Ping, etc.), nodes\nMUST run a mix node instance. This requirement serves as an incentive for nodes\nto participate in the mix network, as it allows them to benefit from the\nanonymity features while also contributing to the network's overall anonymity\nand robustness."),(0,i.kt)("h4",{id:"24-node-discovery"},"2.4 Node Discovery"),(0,i.kt)("p",null,"All mix nodes participate in the discovery process and maintain a list of\ndiscovered nodes."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Bootstrap Nodes")),(0,i.kt)("p",{parentName:"li"},"i. The network has a set of well-known bootstrap nodes that new mix nodes\ncan connect to when joining the network.\\\nii. The bootstrap nodes help new mix nodes discover other active mix nodes in\nthe network.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Discovery")),(0,i.kt)("p",{parentName:"li"},"i. All mix nodes publish their Ethereum Node Records (ENRs) containing:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "id": "v4",\n  "multiaddr": "/ip4/192.0.2.1/udp/9000/quic",\n  "ed25519": "0x5a6fcd3e9d6a5e4d5f71e7e5b4cfa9b7b73d9f5f7e9a8b9c5d7f9e8d5a6f7c9e",\n  "mix": "/mix/1.0.0",\n  "supported_protocols": ["ping", "gossipsub"]\n}\n')),(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Field Explanations")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"id"),": Indicates the ENR format version (",(0,i.kt)("em",{parentName:"li"},"e.g.,")," ",(0,i.kt)("inlineCode",{parentName:"li"},'"v4"'),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"multiaddr"),": The node's multiaddress, including the transport protocol\n(",(0,i.kt)("em",{parentName:"li"},"e.g.,")," QUIC) and IP address/port."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ed25519"),": The node's Ed25519 public key, used for Sphinx encryption."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"mix"),": Indicates the supported Mix protocol version (",(0,i.kt)("em",{parentName:"li"},"e.g.,")," ",(0,i.kt)("inlineCode",{parentName:"li"},'"/mix/1.0.0"'),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"supported_protocols"),": A list of other libp2p protocols supported by the\nnode (",(0,i.kt)("em",{parentName:"li"},"e.g.,")," Ping, GossipSub, etc.)."),(0,i.kt)("li",{parentName:"ul"},"Additional fields may be included based on the node's requirements.")),(0,i.kt)("p",{parentName:"li"},"ii. The mix nodes use a peer discovery protocol like ",(0,i.kt)("a",{parentName:"p",href:"https://waku.org"},"WAKU"),"/",(0,i.kt)("a",{parentName:"p",href:"https://github.com/ethereum/devp2p/blob/master/discv5/discv5"},"Discv5"),":"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Connect to a set of bootstrap nodes when joining the network."),(0,i.kt)("li",{parentName:"ul"},"Regularly update their list of known peers."),(0,i.kt)("li",{parentName:"ul"},"Obtain a random sample of nodes that is representative of the network."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Path Selection (Message Senders Only)")),(0,i.kt)("p",{parentName:"li"},"To send an anonymous message, a mix node performs the following actions:"),(0,i.kt)("p",{parentName:"li"},"i. Choose a random exit node that supports the required libp2p protocol for\nthe message.\\\nii. Select remaining L-1 unique mix nodes randomly without replacement from\nthe list of discovered nodes.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Forwarding To Next Hop (Intermediary Nodes Only)")),(0,i.kt)("p",{parentName:"li"},"When a mix node receives an incoming Sphinx packet, it performs the following\nactions:"),(0,i.kt)("p",{parentName:"li"},"i. Decrypts the packet to obtain the next hop multiaddress\\\nii. Checks if the next hop is in the list of discovered nodes.\\\niii. If not, performs discovery for that specific node.\\\niv. Forwards the Sphinx packet to the next hop."))),(0,i.kt)("h4",{id:"25-protocol-registration"},"2.5 Protocol Registration"),(0,i.kt)("p",null,"The protocol is registered with the libp2p host using the ",(0,i.kt)("inlineCode",{parentName:"p"},'"/mix/1.0.0"'),"\nidentifier. This identifier is used to establish connections and negotiate the\nprotocol between libp2p peers."),(0,i.kt)("h4",{id:"26-transport-layer"},"2.6 Transport Layer"),(0,i.kt)("p",null,"The Mix protocol uses secure transport protocols to ensure confidentiality and\nintegrity of communications. The recommended transport protocols are\n",(0,i.kt)("a",{parentName:"p",href:"https://datatracker.ietf.org/doc/rfc9000/"},"QUIC")," or TLS (preferably QUIC\ndue to its performance benefits and built-in features\nsuch as low latency and efficient multiplexing)."),(0,i.kt)("h4",{id:"27-connection-establishment"},"2.7 Connection Establishment"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The sender initiates a secure connection (TLS or QUIC) to the first mix node\nusing the libp2p transport."),(0,i.kt)("li",{parentName:"ul"},"The sender uses the ",(0,i.kt)("inlineCode",{parentName:"li"},'"/mix/1.0.0"')," protocol identifier to convey that the\nconnection is for the Mix protocol."),(0,i.kt)("li",{parentName:"ul"},"Once the connection is established, the sender can forward Sphinx packets\nusing the Mix protocol."),(0,i.kt)("li",{parentName:"ul"},"Subsequent mix nodes in the path follow the same process when forwarding\nmessages to other mix nodes.")),(0,i.kt)("h3",{id:"3-cryptographic-primitives-and-security-parameter"},"3. Cryptographic Primitives and Security Parameter"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Security Parameter:")," $\\kappa = 128$ bits provides a balance between\nsecurity and efficiency."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Cryptographic Primitives"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Group G"),": Curve25519 elliptic curve offers 128-bit security with small\n(32-byte) group elements, efficient for both encryption and key exchange."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Hash function H"),": SHA-256."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"KDF:")," SHA-256 (truncated to 128 bits)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"AES-CTR:")," AES-128 in counter mode.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Inputs:")," Key ",(0,i.kt)("inlineCode",{parentName:"li"},"k")," (16 bytes), Initialization Vector ",(0,i.kt)("inlineCode",{parentName:"li"},"iv")," (16 bytes),\nPlaintext ",(0,i.kt)("inlineCode",{parentName:"li"},"p")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Initialization Vector (IV)"),": 16 bytes, chosen randomly for each\nencryption."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Plaintext"),": Data to be encrypted (",(0,i.kt)("em",{parentName:"li"},"e.g.,")," routing information, message\npayload)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Output"),": Ciphertext ",(0,i.kt)("inlineCode",{parentName:"li"},"c")," (same size as plaintext ",(0,i.kt)("inlineCode",{parentName:"li"},"p"),")."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Operation"),": AES-CTR mode uses key and the counter (",(0,i.kt)("inlineCode",{parentName:"li"},"iv"),") to produce a\nkeystream, which is XORed with the plaintext to produce the ciphertext."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"HMAC-SHA-256:")," 256-bit MAC (truncated to 128 bits).",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Inputs:")," Key ",(0,i.kt)("inlineCode",{parentName:"li"},"k")," (16 bytes), Message ",(0,i.kt)("inlineCode",{parentName:"li"},"m")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Message"),": Data to be authenticated (",(0,i.kt)("em",{parentName:"li"},"e.g.,")," $\u03b2$ component)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Output"),": MAC ",(0,i.kt)("inlineCode",{parentName:"li"},"mac")," (truncated to 128 bits)."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Operation"),": HMAC-SHA-256 uses the key and the message to produce a\nhash-based message authentication code.")))))),(0,i.kt)("h3",{id:"4-sphinx-packet-format"},"4. Sphinx Packet Format"),(0,i.kt)("h4",{id:"41-packet-components-and-sizes"},"4.1 Packet Components and Sizes"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Alpha ($\u03b1$)"),": 32 bytes"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Represents a Curve25519 group element (x-coordinate in GF(2^255 - 19))."),(0,i.kt)("li",{parentName:"ul"},"Used by mix nodes to extract shared session key using their private key."))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Beta ($\u03b2$)"),": $((t+1)r + 1)\\kappa$ bytes typically, where $r$ is the maximum\npath length."),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Contains the encrypted routing information."),(0,i.kt)("li",{parentName:"ul"},"We recommend a reasonable maximum path length of $r=5$, considering\nlatency/anonymity trade-offs."),(0,i.kt)("li",{parentName:"ul"},"This gives a reasonable size of $336$ bytes, when $t = 3$ (refer\nSection 5.2.10 for the choice of $t$)."),(0,i.kt)("li",{parentName:"ul"},"We extend $\u03b2$ to accommodate next hop address and delay below."))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Gamma ($\u03b3$)"),": $\\kappa$ bytes (16 bytes)"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Output of HMAC-SHA-256, truncated to 128 bits."),(0,i.kt)("li",{parentName:"ul"},"Ensures the integrity of the header information."))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Delta ($\u03b4$)"),": The encrypted payload, which can be of variable size."),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"According to the ",(0,i.kt)("a",{parentName:"li",href:"https://petsymposium.org/popets/2024/popets-2024-0050.pdf"},"MixMatch"),"\npaper, the Nym network uses Sphinx packets of a fixed\nsize (2413 bytes)."),(0,i.kt)("li",{parentName:"ul"},"Considering this, the maximum $\u03b4$ size can be chosen as 2413 bytes minus\nthe header length (which will be derived below).")))),(0,i.kt)("h4",{id:"42-address-format-and-delay-specification"},"4.2 Address Format and Delay Specification"),(0,i.kt)("p",null,"In the original\n",(0,i.kt)("a",{parentName:"p",href:"https://cypherpunks.ca/~iang/pubs/Sphinx_Oakland09.pdf"},"Sphinx")," paper, the\nauthors use node IDs of size $\\kappa$ ($16$ bytes) to represent the next hop\naddresses. To accommodate larger addresses, we'll use a combined size of\n$t\\kappa$ bytes for the address and delay, where $t$ is small (",(0,i.kt)("em",{parentName:"p"},"e.g.,")," $t = 2$\nor $3$)."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Delay"),": 2 bytes\nAllows delays up to 65,535 milliseconds \u2248 65 seconds."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Address"),": $t\\kappa-2$ bytes\nThis flexible format can accommodate various address types, including:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"libp2p multiaddress (variable length, typically 32-64 bytes)."),(0,i.kt)("li",{parentName:"ul"},"Custom format with:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"IP address (IPv4 or IPv6, 4 or 16 bytes)"),(0,i.kt)("li",{parentName:"ul"},"TCP/UDP port number (2 bytes)"),(0,i.kt)("li",{parentName:"ul"},"QUIC/TLS protocol identifier flag (1 byte)"),(0,i.kt)("li",{parentName:"ul"},"Peer ID (32 bytes for Ed25519 or Secp256k1).")))))),(0,i.kt)("p",null,"The entire Sphinx packet header ($\u03b1$, $\u03b2$, and $\u03b3$) can fit within a fixed size\nof $32 + (r(t+1)+1)\\kappa + 16 = 384$ bytes, leaving ample room for a large $\u03b4$ of\nup to $2413 - 384 = 2029$ bytes."),(0,i.kt)("h4",{id:"43-message-format"},"4.3 Message Format"),(0,i.kt)("p",null,"The Mix protocol uses the Sphinx packet format to encapsulate messages and\nrouting information."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-proto"},"message SphinxPacket {\n  bytes alpha = 1; // 32 bytes\n  bytes beta = 2; // 304 - 384 bytes\n  bytes gamma = 3; // 16 bytes\n  bytes delta = 4; // variable size, max 2029 bytes\n}\n")),(0,i.kt)("h3",{id:"5-handler-function"},"5. Handler Function"),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"https://docs.libp2p.io/concepts/fundamentals/protocols/#handler-functions"},"handler function"),"\nis responsible for processing connections and messages for\nthe Mix protocol. It operates according to the mix node roles (",(0,i.kt)("em",{parentName:"p"},"i.e.,")," sender,\nintermediary mix node, or exit node) defined in\n",(0,i.kt)("a",{parentName:"p",href:"#21-mix-nodes-roles"},"Section 2.1"),". This function is crucial for implementing\nthe core functionality of the mixnet protocol within the libp2p framework."),(0,i.kt)("p",null,"When a node receives a new stream for the ",(0,i.kt)("inlineCode",{parentName:"p"},'"/mix/1.0.0"')," protocol, the handler\nfunction is invoked. It performs different operations based on the node's role\nin the current message path:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Role Determination")),(0,i.kt)("p",{parentName:"li"},"The handler first determines the node's role for the incoming message. This\nis typically done by examining the packet structure and the node's position\nin the network.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Packet Processing")),(0,i.kt)("p",{parentName:"li"},"Depending on the role, the handler processes the Sphinx packet differently:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"For senders, it creates and sends new Sphinx packets."),(0,i.kt)("li",{parentName:"ul"},"For intermediary nodes, it processes and forwards existing packets."),(0,i.kt)("li",{parentName:"ul"},"For exit nodes, it decrypts the final layer and disseminates the original message."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Error Handling")),(0,i.kt)("p",{parentName:"li"},"It manages any errors that occur during packet processing, such as invalid\nMACs or decryption failures.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Logging and Metrics")),(0,i.kt)("p",{parentName:"li"},"The handler is also be responsible for logging important events and\ncollecting metrics for network analysis and debugging."))),(0,i.kt)("p",null,"The specific implementation of the handler function for each role (",(0,i.kt)("em",{parentName:"p"},"i.e.,"),"\nsender, intermediary, and exit node) is detailed in the following subsections."),(0,i.kt)("h4",{id:"51-sender"},"5.1 Sender"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Convert the libp2p Message to Bytes")),(0,i.kt)("p",{parentName:"li"},"Serialize the libp2p message to bytes and store the result in\n",(0,i.kt)("inlineCode",{parentName:"p"},"libp2p_message"),". This can be done using Protocol Buffers or another\nserialization method.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Apply Spam Protection")),(0,i.kt)("p",{parentName:"li"},"Apply the chosen spam protection mechanism to the ",(0,i.kt)("inlineCode",{parentName:"p"},"libp2p_message"),".\nThis could be Proof of Work (PoW), Verifiable Delay Function (VDF),\nRate Limiting Nullifier (RLN), or other suitable approaches."),(0,i.kt)("p",{parentName:"li"},"Refer to ",(0,i.kt)("a",{parentName:"p",href:"#appendix-a-example-spam-protection-using-proof-of-work"},"Appendix A"),"\nfor details on the current implementation using PoW.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Prepare the Message")),(0,i.kt)("p",{parentName:"li"},"Prepare the ",(0,i.kt)("inlineCode",{parentName:"p"},"message")," by combining the ",(0,i.kt)("inlineCode",{parentName:"p"},"libp2p_message")," with any necessary data\nfrom the spam protection mechanism. The exact format of ",(0,i.kt)("inlineCode",{parentName:"p"},"message")," will depend\non the chosen spam protection method."),(0,i.kt)("p",{parentName:"li"},"Note: The spam protection mechanism is designed as a pluggable interface,\nallowing for different methods to be implemented based on network requirements.\nThis flexibility extends to other components such as peer discovery and incentivization,\nwhich are not specified in detail to allow for future optimizations and adaptations.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Perform Path Selection")," (refer ",(0,i.kt)("a",{parentName:"p",href:"#24-node-discovery"},"Section 2.4"),")"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Let the Ed25519 public keys of the mix nodes in the path be\n$y",(0,i.kt)("em",{parentName:"li"},"0,\\ y_1,\\ \\ldots,\\ y"),"{L-1}$."))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Wrap Final Message in Sphinx Packet"),"\nPerform the following steps to wrap ",(0,i.kt)("inlineCode",{parentName:"p"},"message")," in a Sphinx packet:"),(0,i.kt)("p",{parentName:"li"},"a. ",(0,i.kt)("strong",{parentName:"p"},"Compute")," ",(0,i.kt)("strong",{parentName:"p"},"Alphas ($\u03b1_i$"),", ",(0,i.kt)("strong",{parentName:"p"},"$i=0$")," to ",(0,i.kt)("strong",{parentName:"p"},"$L-1$)")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Select a random exponent $x$\xa0from $\\mathbb{Z}_q^*$."),(0,i.kt)("li",{parentName:"ul"},"Compute initial alpha $\u03b1_0$, shared secret $s_0$, and blinding factor $b_0$:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"$\u03b1_0 = g^x$ using Curve25519 scalar multiplication."),(0,i.kt)("li",{parentName:"ul"},"$s_0 = y_0^x$, where $y_0$ is the public key of the first hop."),(0,i.kt)("li",{parentName:"ul"},"$b",(0,i.kt)("em",{parentName:"li"},"0 = H(\u03b1_0\\ |\\ s_0)$, where $H$ is the SHA-256 hash function (refer\n"),(0,i.kt)("a",{parentName:"li",href:"#3-cryptographic-primitives-and-security-parameter"},"Section 3"),"_ for details)."))),(0,i.kt)("li",{parentName:"ul"},"For each node $i$ (from $1$ to $L-1$):",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"$\u03b1",(0,i.kt)("em",{parentName:"li"},"i = \u03b1"),"{i-1}^{b_{i-1}}$ using Curve25519 scalar multiplication."),(0,i.kt)("li",{parentName:"ul"},"$s",(0,i.kt)("em",{parentName:"li"},"i = y"),"{i}^{x\\prod",(0,i.kt)("em",{parentName:"li"},"{\\text{j=0}}^{\\text{i-1}} b"),"{j}}$, where $y_{i}$ is\nthe public key of the i-th hop."),(0,i.kt)("li",{parentName:"ul"},"$b_i = H(\u03b1_i\\ |\\ s_i)$, where $H$ is the SHA-256 hash function.")))),(0,i.kt)("p",{parentName:"li"},"Note that $\\alpha_i$ and $s_i$ are group elements, each 32 bytes long."),(0,i.kt)("p",{parentName:"li"},"b. ",(0,i.kt)("strong",{parentName:"p"},"Compute")," ",(0,i.kt)("strong",{parentName:"p"},"Filler Strings ($\\phi_i$"),", ",(0,i.kt)("strong",{parentName:"p"},"$i=0$")," to ",(0,i.kt)("strong",{parentName:"p"},"$L-1$)")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Initialize $\\phi_0$ as an empty string.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For each $i$ (from $1$ to $L-1$):"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Derive the AES key and IV:"),(0,i.kt)("p",{parentName:"li"},"$",(0,i.kt)("inlineCode",{parentName:"p"},'\\text{\u03c6\\_aes\\_key}_{i-1} = KDF(\\text{"aes\\_key"}\\ |\\ s_{i-1})'),"$"),(0,i.kt)("p",{parentName:"li"},"$",(0,i.kt)("inlineCode",{parentName:"p"},'\\text{\u03c6\\_iv}_{i-1} = H(\\text{"iv"}\\ |\\ s_{i-1})'),"$ (truncated to 128 bits)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Compute the filler string $\\phi_i$ using $\\text{AES-CTR}^\\prime_i$,\nwhich is AES-CTR encryption with the keystream starting from\nindex $((t+1)(r-i)+t+2)\\kappa$ :"),(0,i.kt)("p",{parentName:"li"},"$",(0,i.kt)("inlineCode",{parentName:"p"},"\\phi_i = \\text{AES-CTR}^\\prime_i(\\text{\u03c6\\_aes\\_key}_{i-1},\\ \\text{\u03c6\\_iv}_{i-1},\n\\ \\phi_{i-1}\\ |\\ 0_{(t+1)\\kappa})"),"$,\nwhere $0_{(t+1)\\kappa}$ is the string of $0$ bits of length $(t+1)\\kappa$."))))),(0,i.kt)("p",{parentName:"li"},"Note that the length of $\\phi_i$ is $(t+1)i\\kappa$."),(0,i.kt)("p",{parentName:"li"},"c. ",(0,i.kt)("strong",{parentName:"p"},"Compute")," ",(0,i.kt)("strong",{parentName:"p"},"Betas and Gammas ($\\beta_i$"),", $\\gamma_i$, ",(0,i.kt)("strong",{parentName:"p"},"$i=0$")," to ",(0,i.kt)("strong",{parentName:"p"},"$L-1$)")),(0,i.kt)("p",{parentName:"li"},"For each $i$ (from $L-1$ to $0$):"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Derive the AES key, MAC key, and IV:"),(0,i.kt)("p",{parentName:"li"},"$",(0,i.kt)("inlineCode",{parentName:"p"},'\\text{\u03b2\\_aes\\_key}_{i} = KDF(\\text{"aes\\_key"}\\ |\\ s_{i})'),"$"),(0,i.kt)("p",{parentName:"li"},"$",(0,i.kt)("inlineCode",{parentName:"p"},'\\text{mac\\_key}_{i} = KDF(\\text{"mac\\_key"}\\ |\\ s_{i})'),"$"),(0,i.kt)("p",{parentName:"li"},"$",(0,i.kt)("inlineCode",{parentName:"p"},'\\text{\u03b2\\_iv}_{i} = H(\\text{"iv"}\\ |\\ s_{i})'),"$ (truncated to 128 bits)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Generate random $",(0,i.kt)("inlineCode",{parentName:"p"},"\\text{delay\\_i}"),"$, a 16-bit unsigned integer (0-65535 milliseconds)."),(0,i.kt)("p",{parentName:"li"},"Note that top-level applications can use other probability distributions,\nsuch as an exponential distribution, where shorter delays are more likely\nthan longer delays. This can mimic real-world traffic patterns and provide\nrobust anonymity against traffic analysis. The trade-off lies in balancing\nthe need for flexible delay handling with the risk of exposing\napplication-specific traffic patterns.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If $i = L-1$ (",(0,i.kt)("em",{parentName:"p"},"i.e.,")," exit node):"),(0,i.kt)("p",{parentName:"li"},"$",(0,i.kt)("inlineCode",{parentName:"p"},"\\beta_i = \\text{AES-CTR}(\\text{\u03b2\\_aes\\_key}_{i},\\ \\text{\u03b2\\_iv}_{i},\\ 0_{((t+1)\n(r-L)+t+2)\\kappa})\\ |\\ \\phi_{L-1}"),"$")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Otherwise (",(0,i.kt)("em",{parentName:"p"},"i.e.,")," intermediary node):"),(0,i.kt)("p",{parentName:"li"},"$",(0,i.kt)("inlineCode",{parentName:"p"},"\\beta_i = \\text{AES-CTR}(\\text{\u03b2\\_aes\\_key}_{i},\\ \\text{\u03b2\\_iv}_{i},\\ \\text\n{addr}_{i+1} \\ |\\ \\text{delay}_{i+1}\\ | \\ \\gamma_{i+1}\\ |\\ {\\beta_{i+1}}_\n{[0\\ldots(r(t+1)-t)\\kappa\u22121]})"),"$"),(0,i.kt)("p",{parentName:"li"},"Note that the length of $\\beta_i$ is $(r(t+1)+1)\\kappa$, $0 \\leq i \\leq L-1$,\nwhere $t$ is the combined length of next hop address and delay.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"$",(0,i.kt)("inlineCode",{parentName:"p"},"\\gamma_i = \\text{HMAC-SHA-256}(\\text{mac\\_key}_i,\\ \u03b2_i)"),"$\\\nNote that the length of $\\gamma_i$ is $\\kappa$."))),(0,i.kt)("p",{parentName:"li"},"d. ",(0,i.kt)("strong",{parentName:"p"},"Compute")," ",(0,i.kt)("strong",{parentName:"p"},"Deltas ("),"$\\delta_i$, ",(0,i.kt)("strong",{parentName:"p"},"$i=0$")," to ",(0,i.kt)("strong",{parentName:"p"},"$L-1$)")),(0,i.kt)("p",{parentName:"li"},"For each $i$ (from $L-1$ to $0$):"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Derive the AES key and IV:"),(0,i.kt)("p",{parentName:"li"},"$",(0,i.kt)("inlineCode",{parentName:"p"},'\\text{\u03b4\\_aes\\_key}_{i} = KDF(\\text{"\u03b4\\_aes\\_key"}\\ |\\ s_{i})'),"$"),(0,i.kt)("p",{parentName:"li"},"$",(0,i.kt)("inlineCode",{parentName:"p"},'\\text{\u03b4\\_iv}_{i} = H(\\text{"\u03b4\\_iv"}\\ |\\ s_{i})'),"$ (truncated to 128 bits)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If $i = L-1$ (",(0,i.kt)("em",{parentName:"p"},"i.e.,")," exit node):"),(0,i.kt)("p",{parentName:"li"},"$",(0,i.kt)("inlineCode",{parentName:"p"},"\\delta_i = \\text{AES-CTR}(\\text{\u03b4\\_aes\\_key}_{i},\\ \\text{\u03b4\\_iv}_{i},\n\\ 0_{\\kappa}\\ |\\ m)"),"$, where $m$ is the ",(0,i.kt)("inlineCode",{parentName:"p"},"message"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Otherwise (",(0,i.kt)("em",{parentName:"p"},"i.e.,")," intermediary node):"),(0,i.kt)("p",{parentName:"li"},"$",(0,i.kt)("inlineCode",{parentName:"p"},"\\delta_i = \\text{AES-CTR}(\\text{\u03b4\\_aes\\_key}_{i},\\ \\text{\u03b4\\_iv}_{i},\\ \\delta_{i+1})"),"$"),(0,i.kt)("p",{parentName:"li"},"Note that the length of $\\delta$ is $|m| + \\kappa$."),(0,i.kt)("p",{parentName:"li"},"Given that the derived size of $\\delta$ is $2029$ bytes, this allows\n",(0,i.kt)("inlineCode",{parentName:"p"},"message")," to be of length $2029-16 = 2013$ bytes. This means smaller\nmessages may need to be padded up to $2013$ bytes (e.g., using PKCS#7\npadding)."))),(0,i.kt)("p",{parentName:"li"},"e. ",(0,i.kt)("strong",{parentName:"p"},"Construct Final Sphinx Packet")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Initialize header"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-pseudocode"},"alpha = alpha_0 // 32 bytes\nbeta = beta_0 // $(r(t+1)+1)\\kappa$ bytes\ngamma = gamma_0 // 16 bytes\n")),(0,i.kt)("p",{parentName:"li"},"As discussed earlier, for a maximum path length of $r = 5$, and combined\nlength of address and delay $t = 3\\kappa = 48$ bytes, the header size is\njust $384$ bytes.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Initialize payload"),(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"delta = delta_0 // variable size, max 2029 bytes")),(0,i.kt)("p",{parentName:"li"},"For a fixed Sphinx packet size of $2413$ bytes and given the header length\nof $384$ bytes, ",(0,i.kt)("inlineCode",{parentName:"p"},"delta")," size is $2029$ bytes.")))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Serialize the Sphinx Packet"),"\xa0using Protocol Buffers.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Send the Serialized Packet"),"\xa0to the first mix node using the\n",(0,i.kt)("inlineCode",{parentName:"p"},'"/mix/1.0.0"')," protocol."))),(0,i.kt)("h4",{id:"52-intermediary-mix-node"},"5.2 Intermediary Mix Node"),(0,i.kt)("p",null,"Let $",(0,i.kt)("inlineCode",{parentName:"p"},"x_i \\in \\mathbb{Z}_q^*"),"$ be the intermediary node\u2019s private key\ncorresponding to the public key $y_i \\in G^*$. It performs the following steps\nto relay a message:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Receive and Deserialize"),"\xa0the Sphinx packet using Protocol Buffers.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Compute Shared Secret $s = \\alpha^{x_{i}}$"),".")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Check If Previously Seen")),(0,i.kt)("p",{parentName:"li"},"a. Compute tag $H(s)$, where $H$ is the SHA-256 hash function."),(0,i.kt)("p",{parentName:"li"},"b. If tag is in the previously seen list of tags, discard the message."),(0,i.kt)("p",{parentName:"li"},"c. This list can be reset whenever the node rotates its private key")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Compute MAC")),(0,i.kt)("p",{parentName:"li"},"a. Derive MAC key"),(0,i.kt)("p",{parentName:"li"},"$",(0,i.kt)("inlineCode",{parentName:"p"},'\\text{mac\\_key} = KDF(\\text{"mac\\_key"}\\ |\\ s)'),"$"),(0,i.kt)("p",{parentName:"li"},"b. Check if $",(0,i.kt)("inlineCode",{parentName:"p"},"\\gamma = \\text{HMAC-SHA-256}(\\text{mac\\_key},\\ \u03b2)"),"$ . If not,\ndiscard the message."),(0,i.kt)("p",{parentName:"li"},"c. Otherwise, store tag $H(s)$ in the list of seen message tags.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Decrypt One Layer")),(0,i.kt)("p",{parentName:"li"},"a. Derive the AES key, MAC key, and IV:"),(0,i.kt)("p",{parentName:"li"},"$",(0,i.kt)("inlineCode",{parentName:"p"},'\\text{\u03b2\\_aes\\_key} = KDF(\\text{"aes\\_key"}\\ |\\ s)'),"$"),(0,i.kt)("p",{parentName:"li"},"$",(0,i.kt)("inlineCode",{parentName:"p"},'\\text{\u03b2\\_iv} = H(\\text{"iv"}\\ |\\ s)'),"$ (truncated to 128 bits)"),(0,i.kt)("p",{parentName:"li"},"b. Compute\n$",(0,i.kt)("inlineCode",{parentName:"p"},"B = \\text{AES-CTR}(\\text{\u03b2\\_aes\\_key},\\ \\text{\u03b2\\_iv},\\ \\beta\\ |\\ 0_{(t+1)k})"),"$."),(0,i.kt)("p",{parentName:"li"},"c. Uniquely parse prefix of $B$"),(0,i.kt)("p",{parentName:"li"},"If $B$ has a prefix of ",(0,i.kt)("strong",{parentName:"p"},"$0_{((t+1)(r-L)+t+2)\\kappa}$,")," the current node is the\nexit node (refer exit node operations below)."),(0,i.kt)("p",{parentName:"li"},"Otherwise, it is an intermediary node and it performs the followings steps\nto relay the message."),(0,i.kt)("p",{parentName:"li"},"d. ",(0,i.kt)("strong",{parentName:"p"},"Extract Routing Information")),(0,i.kt)("p",{parentName:"li"},"$",(0,i.kt)("inlineCode",{parentName:"p"},"\\text{next\\_hop} = B_{[0\\ldots(t\\kappa-17)]}"),"$ (first $t\\kappa-2$ bytes)."),(0,i.kt)("p",{parentName:"li"},"e. ",(0,i.kt)("strong",{parentName:"p"},"Extract Delay")),(0,i.kt)("p",{parentName:"li"},"$",(0,i.kt)("inlineCode",{parentName:"p"},"\\text{delay} = B_{[(t\\kappa-16)\\ldots(t\\kappa-1)]}"),"$ (following $2$ bytes)."),(0,i.kt)("p",{parentName:"li"},"f. ",(0,i.kt)("strong",{parentName:"p"},"Extract Gamma")),(0,i.kt)("p",{parentName:"li"},"$",(0,i.kt)("inlineCode",{parentName:"p"},"{\\gamma}' = B_{[t\\kappa\\ldots(t\\kappa+\\kappa-1)]}"),"$ (following $\\kappa$ bytes)."),(0,i.kt)("p",{parentName:"li"},"g. ",(0,i.kt)("strong",{parentName:"p"},"Extract Beta")),(0,i.kt)("p",{parentName:"li"},"$",(0,i.kt)("inlineCode",{parentName:"p"},"\\beta' = B_{[(t\\kappa+\\kappa)\\ldots(r(t+1)+t+2)\\kappa-1]}"),"$ (following\n$((t+1)r + 1)\\kappa$ bytes)."),(0,i.kt)("p",{parentName:"li"},"h. ",(0,i.kt)("strong",{parentName:"p"},"Compute Alpha")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Compute blinding factor $b = H(\u03b1\\ |\\ s)$, where $H$ is the SHA-256 hash\nfunction."),(0,i.kt)("li",{parentName:"ul"},"Compute $\u03b1^\u2032 = \u03b1^b$.")),(0,i.kt)("p",{parentName:"li"},"i. ",(0,i.kt)("strong",{parentName:"p"},"Compute Delta")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Derive the AES key and IV:\n$",(0,i.kt)("inlineCode",{parentName:"li"},'\\text{\u03b4\\_aes\\_key} = KDF(\\text{"\u03b4\\_aes\\_key"}\\ |\\ s)'),"$\n$",(0,i.kt)("inlineCode",{parentName:"li"},'\\text{\u03b4\\_iv} = H(\\text{"\u03b4\\_iv"}\\ |\\ s)$')," (truncated to 128 bits)"),(0,i.kt)("li",{parentName:"ul"},"Compute $",(0,i.kt)("inlineCode",{parentName:"li"},"\\delta' = \\text{AES-CTR}(\\text{\u03b4\\_aes\\_key},\\ \\text{\u03b4\\_iv},\\ \\delta)"),"$"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Construct Final Sphinx Packet")),(0,i.kt)("p",{parentName:"li"},"a. Initialize header"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-pseudocode"}," alpha = alpha' // 32 bytes\n beta = beta' // $((t+1)r + 1)\\kappa$ bytes\n gamma = gamma' // 16 bytes\n")),(0,i.kt)("p",{parentName:"li"},"b. Initialize payload"),(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"delta = delta' // variable size, max 2029 bytes"))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Serialize the Sphinx Packet"),"\xa0using Protocol Buffers.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Introduce A Delay")," of $",(0,i.kt)("inlineCode",{parentName:"p"},"\\text{delay}"),"$ milliseconds.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Send the Serialized Packet")," to $",(0,i.kt)("inlineCode",{parentName:"p"},"\\text{next\\_hop}"),"$ using the\n",(0,i.kt)("inlineCode",{parentName:"p"},'"/mix/1.0.0"')," protocol."))),(0,i.kt)("h4",{id:"53-exit-node"},"5.3 Exit Node"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Perform ",(0,i.kt)("em",{parentName:"strong"},"Steps i. to v. b.")," Above"),", similar to an intermediary node. If\n$B$ has a prefix of $0",(0,i.kt)("em",{parentName:"p"},"{((t+1)(r-L)+t+2)\\kappa}$ (in _step 5. c.")," above), the\ncurrent node is the exit node. It performs the following steps to\ndisseminate the message via the respective libp2p protocol.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Compute Delta")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Derive the AES key and IV:"),(0,i.kt)("p",{parentName:"li"},"$",(0,i.kt)("inlineCode",{parentName:"p"},'\\text{\u03b4\\_aes\\_key} = KDF(\\text{"\u03b4\\_aes\\_key"}\\ |\\ s)'),"$"),(0,i.kt)("p",{parentName:"li"},"$",(0,i.kt)("inlineCode",{parentName:"p"},'\\text{\u03b4\\_iv} = H(\\text{"\u03b4\\_iv"}\\ |\\ s)'),"$ (truncated to 128 bits)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Compute $",(0,i.kt)("inlineCode",{parentName:"p"},"\\delta' = \\text{AES-CTR}(\\text{\u03b4\\_aes\\_key},\\ \\text{\u03b4\\_iv},\\ \\delta)"),"$.")))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Extract Message")),(0,i.kt)("p",{parentName:"li"},"$m = \\delta'_{","[\\kappa\\ldots]","}$ (remove first $\\kappa$ bytes).")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Remove Any Padding")," from $m$ to obtain the ",(0,i.kt)("inlineCode",{parentName:"p"},"message")," including any\nnecessary spam protection data.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Verify Spam Protection")),(0,i.kt)("p",{parentName:"li"},"Verify the spam protection mechanism applied to the ",(0,i.kt)("inlineCode",{parentName:"p"},"message"),".\nIf the verification fails, discard the ",(0,i.kt)("inlineCode",{parentName:"p"},"message"),".\nRefer to ",(0,i.kt)("a",{parentName:"p",href:"#appendix-a-example-spam-protection-using-proof-of-work"},"Appendix A"),"\nfor details on the current implementation using PoW.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Deserialize the extracted message"),"\xa0using the respective libp2p protocol's\ndefinition.")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Disseminate the message"),"\xa0via the respective libp2p protocol (",(0,i.kt)("em",{parentName:"p"},"e.g.,"),"\nGossipSub)."))),(0,i.kt)("h2",{id:"copyright"},"Copyright"),(0,i.kt)("p",null,"Copyright and related rights waived via ",(0,i.kt)("a",{parentName:"p",href:"https://creativecommons.org/publicdomain/zero/1.0/"},"CC0"),"."),(0,i.kt)("h2",{id:"references"},"References"),(0,i.kt)("h3",{id:"normative"},"Normative"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://docs.libp2p.io/concepts/fundamentals/protocols/#handler-functions"},"Handler function"),"\n",(0,i.kt)("a",{parentName:"p",href:"https://libp2p.io"},"libp2p"),"\\\n",(0,i.kt)("a",{parentName:"p",href:"https://cypherpunks.ca/~iang/pubs/Sphinx_Oakland09.pdf"},"Sphinx")),(0,i.kt)("h3",{id:"informative"},"Informative"),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://bitcoin.org/bitcoin.pdf"},"PoW"),"\\\n",(0,i.kt)("a",{parentName:"p",href:"https://petsymposium.org/popets/2024/popets-2024-0050.pdf"},"Sphinx packet size")),(0,i.kt)("h2",{id:"appendix-a-example-spam-protection-using-proof-of-work"},"Appendix A. Example Spam Protection using Proof of Work"),(0,i.kt)("p",null,"The current implementation uses a Proof of Work mechanism for spam protection.\nThis section details the specific steps for attaching and verifying the PoW."),(0,i.kt)("h3",{id:"structure"},"Structure"),(0,i.kt)("p",null,"The sender appends the PoW to the serialized libp2p message, ",(0,i.kt)("inlineCode",{parentName:"p"},"libp2p_message"),",\nin a structured format, making it easy to parse and verify by the exit node.\nThe sender includes the PoW as follows:"),(0,i.kt)("p",null,"\xa0",(0,i.kt)("inlineCode",{parentName:"p"},"message = <libp2p_message_bytes | timestamp | nonce>")),(0,i.kt)("p",null,"where:"),(0,i.kt)("p",null," ",(0,i.kt)("inlineCode",{parentName:"p"},"<libp2p_message_bytes>"),": Serialized libp2p message (variable length)."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"<timestamp>"),": The current Unix timestamp in seconds (4 bytes)."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"<nonce>"),": The nonce that satisfies the PoW difficulty criterion (4 bytes)."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Nonce Size:")," The nonce size should be large enough to ensure a sufficiently large\nsearch space. It should be chosen so that the range of possible nonce values\nallows for the difficulty target to be met. However, larger nonce sizes can increase\nthe time and computational effort required to find a valid nonce. We use\na 4-byte nonce to ensure sufficiently large search space with reasonable\ncomputational effort."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Difficulty Level:")," The difficulty level is usually expressed as the number of\nleading zeros required in the hash output. It is chosen such that the\ncomputational effort required is significant but not prohibitive.\nWe recommend a reasonable difficulty level that requires around\n16-18 leading zeros in the SHA-256 hash. This would roughly take\n0.65 to 2.62 seconds to compute in a low-grade CPU,\ncapable of computing 100,000 hashes per second."),(0,i.kt)("h3",{id:"calculate-proof-of-work-pow"},"Calculate Proof of Work (PoW)"),(0,i.kt)("p",null,"The sender performs the following steps to compute the PoW challenge and response:"),(0,i.kt)("p",null,"i. ",(0,i.kt)("strong",{parentName:"p"},"Create Challenge")),(0,i.kt)("p",null,"Retrieves the current Unix timestamp, ",(0,i.kt)("inlineCode",{parentName:"p"},"timestamp"),", in seconds (4 bytes)."),(0,i.kt)("p",null,"ii. ",(0,i.kt)("strong",{parentName:"p"},"Find A Valid Nonce")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Initializes the ",(0,i.kt)("inlineCode",{parentName:"p"},"nonce")," to a 4-byte value (initially zero).")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Increments the ",(0,i.kt)("inlineCode",{parentName:"p"},"nonce")," until the SHA-256 hash of\n",(0,i.kt)("inlineCode",{parentName:"p"},"<libp2p_message_bytes | timestamp | nonce>")," has at least\n18 leading zeros.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The final value of the ",(0,i.kt)("inlineCode",{parentName:"p"},"nonce")," is considered valid."))),(0,i.kt)("h3",{id:"attach-the-pow-to-the-libp2p-message"},"Attach the PoW to the libp2p Message"),(0,i.kt)("p",null,"  Append the 4-byte\xa0",(0,i.kt)("inlineCode",{parentName:"p"},"timestamp"),"\xa0and the valid\xa0",(0,i.kt)("inlineCode",{parentName:"p"},"nonce"),"\xa0to\nthe\xa0",(0,i.kt)("inlineCode",{parentName:"p"},"libp2p_message_bytes"),"\xa0to form the\xa0",(0,i.kt)("inlineCode",{parentName:"p"},"message"),"."),(0,i.kt)("p",null,"  ",(0,i.kt)("inlineCode",{parentName:"p"},"message = <libp2p_message_bytes | timestamp | nonce>")),(0,i.kt)("h3",{id:"verify-pow"},"Verify PoW"),(0,i.kt)("p",null,"i. ",(0,i.kt)("strong",{parentName:"p"},"Extract Timestamp and Nonce")),(0,i.kt)("p",null,"  Split ",(0,i.kt)("inlineCode",{parentName:"p"},"message")," into 4-byte ",(0,i.kt)("inlineCode",{parentName:"p"},"nonce")," (last 4 bytes), 4-byte ",(0,i.kt)("inlineCode",{parentName:"p"},"timestamp"),"\n(the 4 bytes before the nonce), and the serialized libp2p message\nto be published, ",(0,i.kt)("inlineCode",{parentName:"p"},"libp2p_message_bytes")," (the remaining bytes)."),(0,i.kt)("p",null,"ii. ",(0,i.kt)("strong",{parentName:"p"},"Verify Timestamp")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Check the\xa0",(0,i.kt)("inlineCode",{parentName:"li"},"timestamp"),"\xa0is within the last 5 minutes."),(0,i.kt)("li",{parentName:"ul"},"If the timestamp is outside the acceptable window, the exit node\ndiscards the message.")),(0,i.kt)("p",null,"iii. ",(0,i.kt)("strong",{parentName:"p"},"Verifiy Response")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Compute the SHA-256 hash of the ",(0,i.kt)("inlineCode",{parentName:"li"},"message")," and check if the hash\nmeets the difficulty requirement, ",(0,i.kt)("em",{parentName:"li"},"i.e."),", has at least 18 leading zeros."),(0,i.kt)("li",{parentName:"ul"},"If the hash is not valid, the exit node discards the message. Otherwise,\nit follows the steps to publish the message.")))}d.isMDXComponent=!0},3905:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>c});var n=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function p(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),s=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):p(p({},t),e)),a},m=function(e){var t=s(e.components);return n.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},k=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),k=s(a),c=i,h=k["".concat(l,".").concat(c)]||k[c]||d[c]||r;return a?n.createElement(h,p(p({ref:t},m),{},{components:a})):n.createElement(h,p({ref:t},m))}));function c(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,p=new Array(r);p[0]=k;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:i,p[1]=o;for(var s=2;s<r;s++)p[s]=a[s];return n.createElement.apply(null,p)}return n.createElement.apply(null,a)}k.displayName="MDXCreateElement"}}]);