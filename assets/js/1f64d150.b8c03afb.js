"use strict";(self.webpackChunklogos_docs_template=self.webpackChunklogos_docs_template||[]).push([[5531],{88661:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>r,default:()=>h,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var i=n(87462),a=(n(67294),n(3905));const o={title:"38/CONSENSUS-CLARO",name:"Claro Consensus Protocol",status:"raw",category:"Standards Track",editor:"Corey Petty &lt;corey@status.im&gt;",created:"01-JUL-2022",revised:"Fri 13:11Z&gt;",uri:null,contributors:["\xc1lvaro Castro-Castilla","Mark Evenson"]},r=void 0,l={unversionedId:"38/claro",id:"38/claro",title:"38/CONSENSUS-CLARO",description:"- Status: raw",source:"@site/nomos/38/claro.md",sourceDirName:"38",slug:"/38/claro",permalink:"/nomos/38/claro",draft:!1,tags:[],version:"current",frontMatter:{title:"38/CONSENSUS-CLARO",name:"Claro Consensus Protocol",status:"raw",category:"Standards Track",editor:"Corey Petty &lt;corey@status.im&gt;",created:"01-JUL-2022",revised:"Fri 13:11Z&gt;",uri:null,contributors:["\xc1lvaro Castro-Castilla","Mark Evenson"]},sidebar:"defaultSidebar",previous:{title:"Nomos RFCs",permalink:"/nomos/"}},s={},p=[{value:"Abstract",id:"abstract",level:2},{value:"Motivation",id:"motivation",level:2},{value:"Background",id:"background",level:2},{value:"Claro Algorithm Specification",id:"claro-algorithm-specification",level:2},{value:"Algorithmic concept",id:"algorithmic-concept",level:3},{value:"Initial opinion",id:"initial-opinion",level:3},{value:"Setup Parameters",id:"setup-parameters",level:3},{value:"Phase One: Query",id:"phase-one-query",level:3},{value:"Phase Two: Computation",id:"phase-two-computation",level:3},{value:"Phase Three: Computation",id:"phase-three-computation",level:3},{value:"Decision",id:"decision",level:3},{value:"Termination",id:"termination",level:3},{value:"Quiescence",id:"quiescence",level:4},{value:"Clock",id:"clock",level:4},{value:"Further points",id:"further-points",level:2},{value:"Node receives information during round",id:"node-receives-information-during-round",level:3},{value:"Problems with Weighting Node Value of Opinions",id:"problems-with-weighting-node-value-of-opinions",level:4},{value:"Implementation status",id:"implementation-status",level:2},{value:"Wire Protocol",id:"wire-protocol",level:2},{value:"Syntax",id:"syntax",level:2},{value:"Security Considerations",id:"security-considerations",level:2},{value:"Privacy",id:"privacy",level:3},{value:"Security with respect to various Adversarial Models",id:"security-with-respect-to-various-adversarial-models",level:3},{value:"Local Strategies",id:"local-strategies",level:3},{value:"Random Adversaries",id:"random-adversaries",level:4},{value:"Infantile Adversary",id:"infantile-adversary",level:4},{value:"Omniscient Adversaries",id:"omniscient-adversaries",level:3},{value:"Passive Gossip Adversary",id:"passive-gossip-adversary",level:4},{value:"Active Gossip Adversary",id:"active-gossip-adversary",level:4},{value:"Future Directions",id:"future-directions",level:3},{value:"Informative References",id:"informative-references",level:2},{value:"Normative References",id:"normative-references",level:2},{value:"Copyright",id:"copyright",level:2}],d={toc:p};function h(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Status: raw"),(0,a.kt)("li",{parentName:"ul"},"Category: Standards Track"),(0,a.kt)("li",{parentName:"ul"},"Editor: Corey Petty ","<",(0,a.kt)("a",{parentName:"li",href:"mailto:corey@status.im"},"corey@status.im"),">"),(0,a.kt)("li",{parentName:"ul"},"Contributors:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"\xc1lvaro Castro-Castilla"),(0,a.kt)("li",{parentName:"ul"},"Mark Evenson")))),(0,a.kt)("h2",{id:"abstract"},"Abstract"),(0,a.kt)("p",null,"This document specifies Claro: a Byzantine, fault-tolerant, binary decision\nagreement algorithm that utilizes bounded memory for its execution.\nClaro is a novel variant of the Snow family providing a probabilistic\nleaderless BFT consensus algorithm that achieves metastablity via\nnetwork sub-sampling.  We present an application context of the use of\nClaro in an efficient, leaderless, probabilistic permission-less\nconsensus mechanism.  We outline a simple taxonomy of Byzantine\nadversaries, leaving explicit explorations of to subsequent\npublication."),(0,a.kt)("p",null,"NOTE: We have renamed this variant to ",(0,a.kt)("inlineCode",{parentName:"p"},"Claro")," from ",(0,a.kt)("inlineCode",{parentName:"p"},"Glacier")," in order to disambiguate from a previously released research endeavor by ",(0,a.kt)("a",{parentName:"p",href:"https://arxiv.org/pdf/2210.03423.pdf"},"Amores-Sesar, Cachin, and Tedeschi"),". Their naming was coincidentally named the same as our work but is sufficiently differentiated from how ours works. "),(0,a.kt)("h2",{id:"motivation"},"Motivation"),(0,a.kt)("p",null,"This work is a part of a larger research endeavor to explore highly scalable Byzantine Fault Tolerant (BFT) consensus protocols. Consensus lies at the heart of many decentralized protocols, and thus its characteristics and properties are inherited by applications built on top. Thus, we seek to improve upon the current state of the art in two main directions: base-layer scalability and censorship resistance. "),(0,a.kt)("p",null,"Avalanche has shown to exibit the former in a production environment in a way that is differentiated from Nakamoto consensus and other Proof of Stake (PoS) protocols based in practical Byzantine Fault Tolerant (pBFT) methodologies. We aim to understand its limitations and improve upon them."),(0,a.kt)("h2",{id:"background"},"Background"),(0,a.kt)("p",null,"Our starting point is Avalanche\u2019s Binary Byzantine Agreement algorithm, called Snowball. As long as modifications allow a DAG to be constructed later on, this simplifies the design significantly. The DAG stays the same in principle: it supports confidence, but the core algorithm can be modeled without."),(0,a.kt)("p",null,"The concept of the Snowball algorithm is relatively simple. Following is a simplified description (lacking some details, but giving an overview). For further details, please refer to the ",(0,a.kt)("a",{parentName:"p",href:"https://assets.website-files.com/5d80307810123f5ffbb34d6e/6009805681b416f34dcae012_Avalanche%20Consensus%20Whitepaper.pdf"},"Avalanche paper"),"."),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"The objective is to vote yes/no on a decision (this decision could be a single bit, or, in our DAG use case, whether a vertex should be included or not)."),(0,a.kt)("li",{parentName:"ol"},"Every node has an eventually-consistent complete view of the network. It will select at random k nodes, and will ask their opinion on the decision (yes/no)."),(0,a.kt)("li",{parentName:"ol"},"After this sampling is finished, if there is a vote that has more than an ",(0,a.kt)("inlineCode",{parentName:"li"},"alpha")," threshold, it accumulates one count for this opinion, as well as changes its opinion to this one. But, if a different opinion is received, the counter is reset to 1. If no threshold ",(0,a.kt)("inlineCode",{parentName:"li"},"alpha")," is reached, the counter is reset to 0 instead."),(0,a.kt)("li",{parentName:"ol"},"After several iterations of this algorithm, we will reach a threshold ",(0,a.kt)("inlineCode",{parentName:"li"},"beta"),", and decide on that as final.")),(0,a.kt)("p",null,"Next, we will proceed to describe our new algorithm, based on Snowball. "),(0,a.kt)("p",null,"We have identified a shortcoming of the Snowball algorithm that was a perfect starting point for devising improvements. The scenario is as follows:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"There is a powerful adversary in the network, that controls a large percentage of the node population: 10% to ~50%."),(0,a.kt)("li",{parentName:"ul"},"This adversary follows a strategy that allows them to rapidly change the decision bit (possibly even in a coordinated way) so as to maximally confuse the honest nodes."),(0,a.kt)("li",{parentName:"ul"},"Under normal conditions, honest nodes will accumulate supermajorities soon enough, and reach the ",(0,a.kt)("inlineCode",{parentName:"li"},"beta")," threshold. However, when an honest node performs a query and does not reach the threshold ",(0,a.kt)("inlineCode",{parentName:"li"},"alpha")," of responses, the counter will be set to 0."),(0,a.kt)("li",{parentName:"ul"},"The highest threat to Snowball is an adversary that keeps it from reaching the ",(0,a.kt)("inlineCode",{parentName:"li"},"beta")," threshold, managing to continuously reset the counter, and steering Snowball away from making a decision.")),(0,a.kt)("p",null,"This document only outlines the specification to Claro. Subsequent analysis work on Claro (both on its performance and how it differentiates with Snowball) will be published shortly and this document will be updated. "),(0,a.kt)("h2",{id:"claro-algorithm-specification"},"Claro Algorithm Specification"),(0,a.kt)("p",null,"The Claro consensus algorithm computes a boolean decision on a\nproposition via a set of distributed computational nodes.  Claro is\na leaderless, probabilistic, binary consensus algorithm with fast\nfinality that provides good reliability for network and Byzantine\nfault tolerance."),(0,a.kt)("h3",{id:"algorithmic-concept"},"Algorithmic concept"),(0,a.kt)("p",null,"Claro is an evolution of the Snowball Byzantine Binary Agreement (BBA) algorithm, in which we tackle specifically the perceived weakness described above. The main focus is going to be the counter and the triggering of the reset. Following, we elaborate the different modifications and features that have been added to the reference algorithm:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Instead of allowing the latest evidence to change the opinion completely, we take into account all accumulated evidence, to reduce the impact of high variability when there is already a large amount of evidence collected."),(0,a.kt)("li",{parentName:"ol"},"Eliminate the counter and threshold scheme, and introduce instead two regimes of operation:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"One focused on grabbing opinions and reacting as soon as possible. This part is somewhat closer conceptually to the reference algorithm."),(0,a.kt)("li",{parentName:"ul"},"Another one focused on interpreting the accumulated data instead of reacting to the latest information gathered."))),(0,a.kt)("li",{parentName:"ol"},"Finally, combine those two phases via a transition function. This avoids the creation of a step function, or a sudden change in behavior that could complicate analysis and understanding of the dynamics. Instead, we can have a single algorithm that transfers weight from one operation to the other as more evidence is gathered."),(0,a.kt)("li",{parentName:"ol"},"Additionally, we introduce a function for weighted sampling. This will allow the combination of different forms of weighting:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Staking"),(0,a.kt)("li",{parentName:"ul"},"Heuristic reputation"),(0,a.kt)("li",{parentName:"ul"},"Manual reputation.")))),(0,a.kt)("p",null,"It\u2019s worth delving a bit into the way the data is interpreted in order to reach a decision. Our approach is based conceptually on the paper ",(0,a.kt)("a",{parentName:"p",href:"https://cis.temple.edu/~pwang/Publication/confidence.pdf"},"Confidence as Higher-Order Uncertainty"),", which describes a frequentist approach to decision certainty. The first-order certainty, measured by frequency, is caused by known positive evidence, and the higher-order certainty is caused by potential positive evidence. Because confidence is a relative measurement defined on evidence, it naturally follows comparing the amount of evidence the system knows with the amount that it will know in the near future (defining \u201cnear\u201d as a constant). "),(0,a.kt)("p",null,"Intuitively, we are looking for a function of evidence, ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"w")),", call it ",(0,a.kt)("strong",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"strong"},"c"))," for confidence, that satisfies the following conditions:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Confidence ",(0,a.kt)("inlineCode",{parentName:"li"},"c")," is a continuous and monotonically increasing function of ",(0,a.kt)("inlineCode",{parentName:"li"},"w"),". (More evidence, higher confidence.)"),(0,a.kt)("li",{parentName:"ol"},"When ",(0,a.kt)("inlineCode",{parentName:"li"},"w = 0"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"c = 0"),". (Without any evidence, confidence is minimum.)"),(0,a.kt)("li",{parentName:"ol"},"When ",(0,a.kt)("inlineCode",{parentName:"li"},"w")," goes to infinity, ",(0,a.kt)("inlineCode",{parentName:"li"},"c")," converges to 1. (With infinite evidence, confidence is maximum.)")),(0,a.kt)("p",null,"The paper describes also a set of operations for the evidence/confidence pairs, so that different sources of knowledge could be combined. However, we leave here the suggestion of a possible research line in the future combining an algebra of evidence/confidence pairs with swarm-propagation algorithm like the one described in ",(0,a.kt)("a",{parentName:"p",href:"http://replicated.cc/files/schmebulock.pdf"},"this paper"),"."),(0,a.kt)("h3",{id:"initial-opinion"},"Initial opinion"),(0,a.kt)("p",null,"A proposal is formulated to which consensus of truth or falsity is\ndesired.  Each node that participates starts the protocol with an\nopinion on the proposal, represented in the sequel as ",(0,a.kt)("inlineCode",{parentName:"p"},"NO"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"NONE"),",\nand ",(0,a.kt)("inlineCode",{parentName:"p"},"YES"),"."),(0,a.kt)("p",null,"A new proposition is discovered either by local creation or in\nresponse to a query, a node checks its local opinion.  If the node can\ncompute a justification of the proposal, it sets its opinion to one of\n",(0,a.kt)("inlineCode",{parentName:"p"},"YES")," or ",(0,a.kt)("inlineCode",{parentName:"p"},"NO"),".  If it cannot form an opinion, it leaves its opinion as\n",(0,a.kt)("inlineCode",{parentName:"p"},"NONE"),"."),(0,a.kt)("p",null,"For now, we will ignore the proposal dissemination process and assume all nodes participating have an initial opinion to respond to within a given request. Further research will relax this assumption and analyze timing attacks on proposal propagation through the network. "),(0,a.kt)("p",null,"The node then participates in a number of query rounds in which it\nsolicits other node's opinion in query rounds.  Given a set of ",(0,a.kt)("inlineCode",{parentName:"p"},"N"),"\nleaderless computational nodes, a gossip-based protocol is presumed to\nexist which allows members to discover, join, and leave a weakly\ntransitory maximally connected graph.  Joining this graph allows each\nnode to view a possibly incomplete node membership list of all other\nnodes.  This view may change as the protocol advances, as nodes join\nand leave.  Under generalized Internet conditions, the membership of\nthe graph would experience a churn rate varying across different\ntime-scales, as the protocol rounds progress.  As such, a given node\nmay not have a view on the complete members participating in the\nconsensus on a proposal in a given round."),(0,a.kt)("p",null,"The algorithm is divided into 4 phases:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Querying"),(0,a.kt)("li",{parentName:"ol"},"Computing ",(0,a.kt)("inlineCode",{parentName:"li"},"confidence"),", ",(0,a.kt)("inlineCode",{parentName:"li"},"evidence"),", and ",(0,a.kt)("inlineCode",{parentName:"li"},"accumulated evidence")),(0,a.kt)("li",{parentName:"ol"},"Transition function"),(0,a.kt)("li",{parentName:"ol"},"Opinion and Decision")),(0,a.kt)("h3",{id:"setup-parameters"},"Setup Parameters"),(0,a.kt)("p",null,"The node initializes the following integer ratios as constants:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"# The following values are constants chosen with justification from experiments\n# performed with the adversarial models\n\n# \nconfidence_threshold\n  <-- 1   \n         \n# constant look ahead for number of rounds we expect to finalize a\n# decision.  Could be set dependent on number of nodes \n# visible in the current gossip graph.\nlook_ahead \n  <-- 19\n\n# the confidence weighting parameter (aka alpha_1)\ncertainty \n  <-- 4 / 5  \ndoubt ;; the lack of confidence weighting parameter (aka alpha_2)\n  <-- 2 / 5 \n\nk_multiplier     ;; neighbor threshold multiplier\n  <-- 2\n\n;;; maximal threshold multiplier, i.e. we will never exceed \n;;; questioning k_initial * k_multiplier ^ max_k_multiplier_power peers\nmax_k_multiplier_power \n  <-- 4\n    \n;;; Initial number of nodes queried in a round\nk_initial \n  <-- 7\n\n;;; maximum query rounds before termination\nmax_rounds ;; placeholder for simulation work, no justification yet\n   <-- 100 \n")),(0,a.kt)("p",null,"The following variables are needed to keep the state of Claro:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},";; current number of nodes to attempt to query in a round\nk \n  <-- k_original\n  \n;; total number of votes examined over all rounds\ntotal_votes \n   <-- 0 \n;; total number of YES (i.e. positive) votes for the truth of the proposal\ntotal_positive \n   <-- 0\n;; the current query round, an integer starting from zero\nround\n  <-- 0\n")),(0,a.kt)("h3",{id:"phase-one-query"},"Phase One: Query"),(0,a.kt)("p",null,"A node selects ",(0,a.kt)("inlineCode",{parentName:"p"},"k")," nodes randomly from the complete pool of peers in the\nnetwork. This query is can optionally be weighted, so the probability\nof selecting nodes is proportional to their "),(0,a.kt)("p",null,"Node Weighting\n$$\nP(i) = \\frac{w",(0,a.kt)("em",{parentName:"p"},"i}{\\sum"),"{j=0}^{j=N} w_j}\n$$"),(0,a.kt)("p",null,"where ",(0,a.kt)("inlineCode",{parentName:"p"},"w")," is evidence. The list of nodes is maintained by a separate protocol (the network\nlayer), and eventual consistency of this knowledge in the network\nsuffices. Even if there are slight divergences in the network view\nfrom different nodes, the algorithm is resilient to those."),(0,a.kt)("p",null,"A query is sent to each neighbor with the node's current ",(0,a.kt)("inlineCode",{parentName:"p"},"opinion")," of\nthe proposal."),(0,a.kt)("p",null,"Each node replies with their current opinion on the proposal."),(0,a.kt)("p",null,"See ",(0,a.kt)("a",{parentName:"p",href:"#wire-protocol"},"the wire protocol Interoperability section"),' for\ndetails on the semantics and syntax of the "on the wire"\nrepresentation of this query.'),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Adaptive querying"),". An additional optimization in the query\nconsists of adaptively growing the ",(0,a.kt)("em",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"em"},"k"))," constant in the event of\n",(0,a.kt)("strong",{parentName:"p"},"high confusion"),". We define high confusion as the situation in\nwhich neither opinion is strongly held in a query (",(0,a.kt)("em",{parentName:"p"},"i.e.")," a\nthreshold is not reached for either yes or no). For this, we will\nuse the ",(0,a.kt)("em",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"em"},"alpha"))," threshold defined below. This adaptive growth of\nthe query size is done as follows:"),(0,a.kt)("p",null,"Every time the threshold is not reached, we multiply ",(0,a.kt)("em",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"em"},"k"))," by a\nconstant. In our experiments, we found that a constant of 2 works\nwell, but what really matters is that it stays within that order of\nmagnitude."),(0,a.kt)("p",null,"The growth is capped at 4 times the initial ",(0,a.kt)("em",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"em"},"k"))," value. Again, this\nis an experimental value, and could potentially be increased. This\ndepends mainly on complex factors such as the size of the query\nmessages, which could saturate the node bandwidth if the number of\nnodes queried is too high."),(0,a.kt)("p",null,"When the query finishes, the node now initializes the following two\nvalues:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"new_votes \n  &lt;-- |total vote replies received in this round to the current query|\npositive_votes \n  &lt;-- |YES votes received from the query| \n")),(0,a.kt)("h3",{id:"phase-two-computation"},"Phase Two: Computation"),(0,a.kt)("p",null,"When the query returns, three ratios are used later on to compute the\ntransition function and the opinion forming. Confidence encapsulates\nthe notion of how much we know (as a node) in relation to how much we\nwill know in the near future (this being encoded in the look-ahead\nparameter ",(0,a.kt)("em",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"em"},"l")),".) Evidence accumulated keeps the ratio of total positive\nvotes vs the total votes received (positive and negative), whereas the\nevidence per round stores the ratio of the current round only."),(0,a.kt)("p",null,"Parameters\n$$\n\\begin{array}{lc}\n\\text{Look-ahead parameter}      & l = 20 \\newline\n\\text{First evidence parameter}  & \\alpha_1 = 0.8 \\newline\n\\text{Second evidence parameter} & \\alpha_2 = 0.5 \\newline\n\\end{array}\n$$"),(0,a.kt)("p",null,"Computation\n$$\n\\begin{array}{lc}\n\\text{Confidence}                & c",(0,a.kt)("em",{parentName:"p"},"{accum} \\impliedby \\frac{total\\ votes}{total\\ votes + l} \\newline\n\\text{Total accumulated evidence}& e"),"{accum} \\impliedby \\frac{total\\ positive\\ votes}{total\\ votes} \\newline\n\\text{Evidence per round}        & e_{round} \\impliedby \\frac{round\\ positive\\ votes}{round\\ votes} \\newline\n\\end{array}\n$$"),(0,a.kt)("p",null,"The node runs the ",(0,a.kt)("inlineCode",{parentName:"p"},"new_votes")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"positive_votes")," parameters received\nin the query round through the following algorithm:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"total_votes \n  +== new_votes\ntotal_positive \n  +== positive_votes\nconfidence \n  &lt;-- total_votes / (total_votes + look_ahead) \ntotal_evidence \n  &lt;-- total_positive / total_votes\nnew_evidence \n  &lt;-- positive_votes / new_votes\nevidence \n  &lt;-- new_evidence * ( 1 - confidence ) + total_evidence * confidence \nalpha \n  &lt;-- doubt * ( 1 - confidence ) + certainty * confidence \n")),(0,a.kt)("h3",{id:"phase-three-computation"},"Phase Three: Computation"),(0,a.kt)("p",null,"In order to eliminate the need for a step function (a conditional in\nthe code), we introduce a transition function from one regime to the\nother. Our interest in removing the step function is twofold:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"Simplify the algorithm. With this change the number of branches is\nreduced, and everything is expressed as a set of equations.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"The transition function makes the regime switch smooth,\nmaking it harder to potentially exploit the sudden regime change in\nsome unforeseen manner. Such a swift change in operation mode could\npotentially result in a more complex behavior than initially\nunderstood, opening the door to elaborated attacks. The transition\nfunction proposed is linear with respect to the confidence."))),(0,a.kt)("p",null,"Transition Function\n$$\n\\begin{array}{cl}\nevidence & \\impliedby e",(0,a.kt)("em",{parentName:"p"},"{round} (1 - c"),"{accum}) + e",(0,a.kt)("em",{parentName:"p"},"{accum} c"),"{accum} \\newline\n\\alpha &  \\impliedby \\alpha",(0,a.kt)("em",{parentName:"p"},"1 (1 - c"),"{accum}) + \\alpha",(0,a.kt)("em",{parentName:"p"},"2 c"),"{accum} \\newline\n\\end{array}\n$$"),(0,a.kt)("p",null,"Since the confidence is modeled as a ratio that depends on the\nconstant ",(0,a.kt)("em",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"em"},"l")),", we can visualize the transition function at\ndifferent values of ",(0,a.kt)("em",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"em"},"l")),". Recall that this constant encapsulates\nthe idea of \u201cnear future\u201d in the frequentist certainty model: the\nhigher it is, the more distant in time we consider the next\nvaluable input of evidence to happen."),(0,a.kt)("p",null,"We have observed via experiment that for a transition function to be\nuseful, we need establish two requirements:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"The change has to be balanced and smooth, giving an\nopportunity to the first regime to operate and not jump directly\nto the second regime.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"The convergence to 1.0 (fully operating in the second regime)\nshould happen within a reasonable time-frame. We\u2019ve set this\ntime-frame experimentally at 1000 votes, which is in the order of\n~100 queries given a ",(0,a.kt)("em",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"em"},"k"))," of 9."))),(0,a.kt)("p",null,"[","[ Note: Avalanche uses k = 20, as an experimental result from their\ndeployment. Due to the fundamental similarities between the\nalgorithms, it\u2019s a good start for us. ]","]"),(0,a.kt)("p",null,"The node updates its local opinion on the consensus proposal by\nexamining the relationship between the evidence accumulated for a\nproposal with the confidence encoded in the ",(0,a.kt)("inlineCode",{parentName:"p"},"alpha")," parameter:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"IF\n  evidence &gt; alpha\nTHEN \n  opinion &lt;-- YES\nELSE IF       \n  evidence &lt; 1 - alpha\nTHEN \n  opinion &lt;-- NO\n   \n")),(0,a.kt)("p",null,"If the opinion of the node is ",(0,a.kt)("inlineCode",{parentName:"p"},"NONE")," after evaluating the relation\nbetween ",(0,a.kt)("inlineCode",{parentName:"p"},"evidence")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"alpha"),", adjust the number of uniform randomly\nqueried nodes by multiplying the neighbors ",(0,a.kt)("inlineCode",{parentName:"p"},"k")," by the ",(0,a.kt)("inlineCode",{parentName:"p"},"k_multiplier"),"\nup to the limit of ",(0,a.kt)("inlineCode",{parentName:"p"},"k_max_multiplier_power")," query size increases."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},";; possibly increase number nodes to uniformly randomly query in next round\nWHEN\n     opinion is NONE\n  AND \n     k &lt; k_original * k_multiplier ^ max_k_multiplier_power\nTHEN \n   k &lt;-- k * k_multiplier\n")),(0,a.kt)("h3",{id:"decision"},"Decision"),(0,a.kt)("p",null,"The next step is a simple one: change our opinion if the threshold\n",(0,a.kt)("em",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"em"},"alpha"))," is reached. This needs to be done separately for the ",(0,a.kt)("inlineCode",{parentName:"p"},"YES/NO"),"\ndecision, checking both boundaries. The last step is then to ",(0,a.kt)("em",{parentName:"p"},(0,a.kt)("inlineCode",{parentName:"em"},"decide")),"\non the current opinion. For that, a confidence threshold is\nemployed. This threshold is derived from the network size, and is\ndirectly related to the number of total votes received."),(0,a.kt)("p",null,"Decision\n$$\n\\begin{array}{cl}\nevidence ",">"," \\alpha & \\implies \\text{opinion YES} \\newline\nevidence ","<"," 1 - \\alpha & \\implies \\text{opinion NO} \\newline\nif\\ \\text{confidence} ",">"," c_{target} & THEN \\ \\text{finalize decision} \\newline\n\\end{array}\n$$"),(0,a.kt)("p",null,"After the ",(0,a.kt)("inlineCode",{parentName:"p"},"OPINION")," phase is executed, the current value of ",(0,a.kt)("inlineCode",{parentName:"p"},"confidence"),"\nis considered: if ",(0,a.kt)("inlineCode",{parentName:"p"},"confidence")," exceeds a threshold derived from the\nnetwork size and directly related to the total votes received, an\nhonest node marks the decision as final, and always returns this\nopinion is response to further queries from other nodes on the\nnetwork."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"IF \n  confidence &gt; confidence_threshold\nOR \n  round &gt; max_rounds\nTHEN\n  finalized &lt;-- T\n  QUERY LOOP TERMINATES\nELSE \n  round +== 1\n  QUERY LOOP CONTINUES\n")),(0,a.kt)("p",null,"Thus, after the decision phase, either a decision has been finalized\nand the local node becomes quiescent never initiating a new query, or\nit initiates a ",(0,a.kt)("a",{parentName:"p",href:"#query"},"new query"),"."),(0,a.kt)("h3",{id:"termination"},"Termination"),(0,a.kt)("p",null,"A local round of Claro terminates in one of the following\nexecution model considerations:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"No queries are received for any newly initiated round for temporal\nperiods observed via a locally computed passage of time.  See ",(0,a.kt)("a",{parentName:"p",href:"#clock"},"the\nfollowing point on local time"),".")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"The ",(0,a.kt)("inlineCode",{parentName:"p"},"confidence")," on the proposal exceeds our threshold for\nfinalization.")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},"The number of ",(0,a.kt)("inlineCode",{parentName:"p"},"rounds")," executed would be greater than\n",(0,a.kt)("inlineCode",{parentName:"p"},"max_rounds"),". "))),(0,a.kt)("h4",{id:"quiescence"},"Quiescence"),(0,a.kt)("p",null,"After a local node has finalized an ",(0,a.kt)("inlineCode",{parentName:"p"},"opinion")," into a ",(0,a.kt)("inlineCode",{parentName:"p"},"decision"),", it enters a quiescent\nstate whereby it never solicits new votes on the proposal.  The local\nnode MUST reply with the currently finalized ",(0,a.kt)("inlineCode",{parentName:"p"},"decision"),"."),(0,a.kt)("h4",{id:"clock"},"Clock"),(0,a.kt)("p",null,"The algorithm only requires that nodes have computed the drift of\nobservation of the passage of local time, not that that they have\ncoordinated an absolute time with their peers.  For an implementation\nof a phase locked-loop feedback to measure local clock drift see\n",(0,a.kt)("a",{parentName:"p",href:"https://www.rfc-editor.org/rfc/rfc5905.html"},"NTP"),"."),(0,a.kt)("h2",{id:"further-points"},"Further points"),(0,a.kt)("h3",{id:"node-receives-information-during-round"},"Node receives information during round"),(0,a.kt)("p",null,"In the query step, the node is envisioned as packing information into\nthe query to cut down on the communication overhead a query to each of\nthis ",(0,a.kt)("inlineCode",{parentName:"p"},"k")," nodes containing the node's own current opinion on the\nproposal (",(0,a.kt)("inlineCode",{parentName:"p"},"YES"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"NO"),", or ",(0,a.kt)("inlineCode",{parentName:"p"},"NONE"),").  The algorithm does not currently\nspecify how a given node utilizes this incoming information.  A\npossible use may be to count unsolicited votes towards a currently\nactive round, and discard the information if the node is in a\nquiescent state."),(0,a.kt)("h4",{id:"problems-with-weighting-node-value-of-opinions"},"Problems with Weighting Node Value of Opinions"),(0,a.kt)("p",null,"If the view of other nodes is incomplete, then the sum of the optional\nweighting will not be a probability distribution normalized to 1."),(0,a.kt)("p",null,"The current algorithm doesn't describe how the initial opinions are formed."),(0,a.kt)("h2",{id:"implementation-status"},"Implementation status"),(0,a.kt)("p",null,"The following implementations have been created for various testing and simulation purposes:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/logos-co/consensus-research"},"Rust")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#"},"Python")," - FILL THIS IN WITH NEWLY CREATED REPO"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"#"},"Common Lisp")," - FILL THIS IN WITH NEWLY CREATED REPO")),(0,a.kt)("h2",{id:"wire-protocol"},"Wire Protocol"),(0,a.kt)("p",null,"For interoperability we present a wire protocol semantics by requiring\nthe validity of the following statements expressed in Notation3 (aka\n",(0,a.kt)("inlineCode",{parentName:"p"},"n3"),") about any query performed by a query node:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-n3"},'@prefix rdf:         <http://www.w3.org/1999/02/22-rdf-syntax-ns#> .\n@prefix rdfs:        <http://www.w3.org/2000/01/rdf-schema#> .\n@prefix xsd:         <http://www.w3.org/2001/XMLSchema#> .\n\n@prefix Claro      <https://rdf.logos.co/protocol/Claro#> .\n\nClaro:query\n  :holds (\n    :_0 [ rdfs:label "round";\n          a xsd:postitiveInteger; ],\n          rdfs:comment """\nThe current round of this query \n\nA value of zero corresponds to the initial round.\n""" ;\n\n    :_1 [ rdfs:label "uri";\n          rdfs:comment """\nA unique URI for the proposal.\n\nIt MAY be possible to examine the proposal by resolving this resource, \nand its associated URIs.\n""" ;\n          a xsd:anyURI ],\n          \n    :_2 [ rdfs:label "opinion";\n          rdfs:comment """\nThe opinion on the proposal\n\nOne of the strings "YES" "NO" or "NONE".\n""" ;\n          # TODO constrain as an enumeration on three values efficiently\n          a xsd:string ] \n    ) .\n')),(0,a.kt)("p",null,"Nodes are advised to use Waku messages to include their own\nmetadata in serializations as needed."),(0,a.kt)("h2",{id:"syntax"},"Syntax"),(0,a.kt)("p",null,"The semantic description presented above can be reliably round-tripped\nthrough a suitable serialization mechanism.  JSON-LD provides a\ncanonical mapping to UTF-8 JSON."),(0,a.kt)("p",null,"At their core, the query messages are a simple enumeration of the\nthree possible values of the opinion:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"{ NO, NONE, YES }\n")),(0,a.kt)("p",null,"When represented via integers, such as choosing "),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"}," { -1, 0, +1 }\n")),(0,a.kt)("p",null,"the parity summations across network invariants often become easier to\nmanipulate."),(0,a.kt)("h2",{id:"security-considerations"},"Security Considerations"),(0,a.kt)("h3",{id:"privacy"},"Privacy"),(0,a.kt)("p",null,"In practice, each honest node gossips its current opinion which\nreduces the number of messages that need to be gossiped for a given\nproposal.  The resulting impact on the privacy of the node's opinion\nis not currently analyzed."),(0,a.kt)("h3",{id:"security-with-respect-to-various-adversarial-models"},"Security with respect to various Adversarial Models"),(0,a.kt)("p",null,"Adversarial models have been tested for which the values for current\nparameters of Claro have been tuned.  Exposition of the\njustification of this tuning need to be completed."),(0,a.kt)("h3",{id:"local-strategies"},"Local Strategies"),(0,a.kt)("h4",{id:"random-adversaries"},"Random Adversaries"),(0,a.kt)("p",null,'A random adversary optionally chooses to respond to all queries with a\nrandom decision.  Note that this adversary may be in some sense\nByzantine but not malicious.  The random adversary also models some\nsoftware defects involved in not "understanding" how to derive a truth\nvalue for a given proposition.'),(0,a.kt)("h4",{id:"infantile-adversary"},"Infantile Adversary"),(0,a.kt)("p",null,"Like a petulant child, an infantile adversary responds with the\nopposite vote of the honest majority on an opinion."),(0,a.kt)("h3",{id:"omniscient-adversaries"},"Omniscient Adversaries"),(0,a.kt)("p",null,'Omniscient adversaries have somehow gained an "unfair" participation in\nconsensus by being able to control ',(0,a.kt)("inlineCode",{parentName:"p"},"f")," of ",(0,a.kt)("inlineCode",{parentName:"p"},"N"),' nodes with a out-of-band\n"supra-liminal" coordination mechanism.  Such adversaries use this\ncoordinated behavior to delay or sway honest majority consensus.'),(0,a.kt)("h4",{id:"passive-gossip-adversary"},"Passive Gossip Adversary"),(0,a.kt)("p",null,"The passive network omniscient adversary is fully aware at all times\nof the network state. Such an adversary can always chose to vote in\nthe most efficient way to block the distributed consensus from\nfinalizing."),(0,a.kt)("h4",{id:"active-gossip-adversary"},"Active Gossip Adversary"),(0,a.kt)("p",null,"An omniscient gossip adversary somehow not only controls ",(0,a.kt)("inlineCode",{parentName:"p"},"f")," of ",(0,a.kt)("inlineCode",{parentName:"p"},"N"),"\nnodes, but has also has corrupted communications between nodes such\nthat she may inspect, delay, and drop arbitrary messages.  Such an\nadversary uses capability to corrupt consensus away from honest\ndecisions to ones favorable to itself.  This adversary will, of\ncourse, choose to participate in an honest manner until defecting is\nmost advantageous."),(0,a.kt)("h3",{id:"future-directions"},"Future Directions"),(0,a.kt)("p",null,"Although we have proposed a normative description of the\nimplementation of the underlying binary consensus algorithm (Claro),\nwe believe we have prepared for analysis its adversarial performance\nin a manner that is amenable to replacement by another member of the\n",(0,a.kt)("a",{parentName:"p",href:"#snow*"},"snow*")," family."),(0,a.kt)("p",null,"We have presumed the existence of a general family of algorithms that\ncan be counted on to vote on nodes in the DAG in a fair manner.\nAvalanche provides an example of the construction of votes on UTXO\ntransactions.  One can express all state machine, i.e. account-based\nmodels as checkpoints anchored in UTXO trust, so we believe that this\npresupposition has some justification.  We can envision a need for\ntooling abstraction that allow one to just program the DAG itself, as\nthey should be of stable interest no matter if Claro isn't. "),(0,a.kt)("h2",{id:"informative-references"},"Informative References"),(0,a.kt)("ol",{start:0},(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("a",{parentName:"p",href:"%3Chttps://logos.co/%3E"},"Logos"))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("a",{parentName:"p",href:"%3Chttps://dahliamalkhi.github.io/posts/2022/06/dag-bft/%3E"},"On BFT Consensus Evolution: From Monolithic to\nDAG"))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("a",{parentName:"p",href:"%3Chttps://ipfs.io/ipfs/QmUy4jh5mGNZvLkjies1RWM4YuvJh5o2FYopNPVYwrRVGV%3E"},"snow-ipfs"))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("a",{parentName:"p",href:"%3Chttps://www.avalabs.org/whitepapers%3E"},"snow*")," The Snow family of\nalgorithms")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("a",{parentName:"p",href:"%3Chttps://cloud.google.com/composer/docs/how-to/using/writing-dags%3E"},"Move"),"\nMove: a Language for Writing DAG Abstractions ")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("a",{parentName:"p",href:"%3Chttp://www.w3.org/1999/02/22-rdf-syntax-ns#%3E"},"rdf"))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("a",{parentName:"p",href:"%3Chttp://www.w3.org/2000/01/rdf-schema#%3E"},"rdfs"))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("a",{parentName:"p",href:"%3Chttp://www.w3.org/2001/XMLSchema#%3E"},"xsd")," ")),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("a",{parentName:"p",href:"%3Chttps://www.w3.org/TeamSubmission/n3/%3E"},"n3-w3c-notes"))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("a",{parentName:"p",href:"%3Chttps://www.ntp.org/downloads.html%3E"},"ntp")))),(0,a.kt)("h2",{id:"normative-references"},"Normative References"),(0,a.kt)("ol",{start:0},(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("a",{parentName:"p",href:"%3Chttps://rdf.logos.co/protocol/Claro/1/0/0/raw%3E"},"Claro"))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("a",{parentName:"p",href:"%3Chttps://www.w3.org/DesignIssues/Notation3.html%3E"},"n3"))),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("a",{parentName:"p",href:"%3Chttps://json-ld.org/%3E"},"json-ld")))),(0,a.kt)("h2",{id:"copyright"},"Copyright"),(0,a.kt)("p",null,"Copyright and related rights waived via\n",(0,a.kt)("a",{parentName:"p",href:"https://creativecommons.org/publicdomain/zero/1.0/"},"CC0"),"."))}h.isMDXComponent=!0},3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>m});var i=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=i.createContext({}),p=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=p(e.components);return i.createElement(s.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},c=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=p(n),m=a,u=c["".concat(s,".").concat(m)]||c[m]||h[m]||o;return n?i.createElement(u,r(r({ref:t},d),{},{components:n})):i.createElement(u,r({ref:t},d))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=c;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,r[1]=l;for(var p=2;p<o;p++)r[p]=n[p];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}c.displayName="MDXCreateElement"}}]);