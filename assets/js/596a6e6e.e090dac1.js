"use strict";(self.webpackChunklogos_docs_template=self.webpackChunklogos_docs_template||[]).push([[5059],{32617:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var a=n(87462),i=(n(67294),n(3905));const r={title:"ETH-SECPM",name:"Secure channel setup using Ethereum accounts",status:"raw",category:"Standards Track",editor:"Ramses Fernandez &lt;ramses@status.im&gt;",contributors:null},o=void 0,s={unversionedId:"raw/eth-secpm",id:"raw/eth-secpm",title:"ETH-SECPM",description:"- Status: raw",source:"@site/vac/raw/eth-secpm.md",sourceDirName:"raw",slug:"/raw/eth-secpm",permalink:"/vac/raw/eth-secpm",draft:!1,tags:[],version:"current",frontMatter:{title:"ETH-SECPM",name:"Secure channel setup using Ethereum accounts",status:"raw",category:"Standards Track",editor:"Ramses Fernandez &lt;ramses@status.im&gt;",contributors:null},sidebar:"defaultSidebar",previous:{title:"ETH-DEMLS",permalink:"/vac/raw/eth-demls"},next:{title:"ETH-SECURE-CHANNEL",permalink:"/vac/raw/eth-secure-channel"}},l={},p=[{value:"Motivation",id:"motivation",level:2},{value:"Private 1-to-1 communications protocol",id:"private-1-to-1-communications-protocol",level:2},{value:"Theory",id:"theory",level:3},{value:"Syntax",id:"syntax",level:3},{value:"Cryptographic suite",id:"cryptographic-suite",level:4},{value:"X3DH initialization",id:"x3dh-initialization",level:4},{value:"Use of X3DH",id:"use-of-x3dh",level:4},{value:"Initialization of the double datchet",id:"initialization-of-the-double-datchet",level:4},{value:"Encryption",id:"encryption",level:4},{value:"Decryption",id:"decryption",level:4},{value:"Information retrieval",id:"information-retrieval",level:2},{value:"Static data",id:"static-data",level:3},{value:"Ephemeral data",id:"ephemeral-data",level:3},{value:"Private group messaging protocol",id:"private-group-messaging-protocol",level:2},{value:"Theoretical content",id:"theoretical-content",level:3},{value:"Structure",id:"structure",level:3},{value:"Hash-based identifiers",id:"hash-based-identifiers",level:3},{value:"Credentials",id:"credentials",level:3},{value:"Message framing",id:"message-framing",level:3},{value:"Nodes contents",id:"nodes-contents",level:3},{value:"Leaf node validation",id:"leaf-node-validation",level:3},{value:"Ratchet tree evolution",id:"ratchet-tree-evolution",level:3},{value:"Views of the tree synchronization",id:"views-of-the-tree-synchronization",level:3},{value:"Leaf synchronization",id:"leaf-synchronization",level:3},{value:"Tree and parent hashing",id:"tree-and-parent-hashing",level:3},{value:"Key schedule",id:"key-schedule",level:3},{value:"Secret trees",id:"secret-trees",level:3},{value:"Encryption keys",id:"encryption-keys",level:4},{value:"Deletion schedule",id:"deletion-schedule",level:4},{value:"Key packages",id:"key-packages",level:3},{value:"Group creation",id:"group-creation",level:3},{value:"Group evolution",id:"group-evolution",level:3},{value:"Commit messages",id:"commit-messages",level:3},{value:"Application messages",id:"application-messages",level:3},{value:"Considerations with respect to decentralization",id:"considerations-with-respect-to-decentralization",level:3},{value:"Ethereum-based authentication protocol",id:"ethereum-based-authentication-protocol",level:2},{value:"Introduction",id:"introduction",level:3},{value:"Pattern",id:"pattern",level:3},{value:"Message format (ABNF)",id:"message-format-abnf",level:4},{value:"Signing and Verifying Messages with Ethereum Accounts",id:"signing-and-verifying-messages-with-ethereum-accounts",level:4},{value:"Resolving Ethereum Name Service (ENS) Data",id:"resolving-ethereum-name-service-ens-data",level:4},{value:"Implementer steps: specifying the request origin",id:"implementer-steps-specifying-the-request-origin",level:4},{value:"Implementer steps: verifying a signed message",id:"implementer-steps-verifying-a-signed-message",level:4},{value:"Implementer steps: creating sessions",id:"implementer-steps-creating-sessions",level:4},{value:"Implementer steps: interpreting and resolving resources",id:"implementer-steps-interpreting-and-resolving-resources",level:4},{value:"Wallet implementer steps: verifying the message format",id:"wallet-implementer-steps-verifying-the-message-format",level:4},{value:"Wallet implementer steps: verifying the request origin",id:"wallet-implementer-steps-verifying-the-request-origin",level:4},{value:"Wallet implementer steps: creating SIWE interfaces",id:"wallet-implementer-steps-creating-siwe-interfaces",level:4},{value:"Wallet implementer steps: supporting internationalization (i18n)",id:"wallet-implementer-steps-supporting-internationalization-i18n",level:4},{value:"Privacy and Security Considerations",id:"privacy-and-security-considerations",level:2},{value:"Considerations related to the use of Ethereum addresses",id:"considerations-related-to-the-use-of-ethereum-addresses",level:2},{value:"With respect to the Authentication Service",id:"with-respect-to-the-authentication-service",level:3},{value:"With respect to the Delivery Service",id:"with-respect-to-the-delivery-service",level:3},{value:"Consideration related to the onchain component of the protocol",id:"consideration-related-to-the-onchain-component-of-the-protocol",level:2},{value:"Assumptions",id:"assumptions",level:3},{value:"Addition of members to a group",id:"addition-of-members-to-a-group",level:3},{value:"Alice knows Bob\u2019s Ethereum address",id:"alice-knows-bobs-ethereum-address",level:4},{value:"Alice does not know Bob\u2019s Ethereum address",id:"alice-does-not-know-bobs-ethereum-address",level:4},{value:"Considerations regarding smart contracts",id:"considerations-regarding-smart-contracts",level:3},{value:"Copyright",id:"copyright",level:2},{value:"References",id:"references",level:2}],c={toc:p};function d(e){let{components:t,...r}=e;return(0,i.kt)("wrapper",(0,a.Z)({},c,r,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Status: raw"),(0,i.kt)("li",{parentName:"ul"},"Category: Standards Track"),(0,i.kt)("li",{parentName:"ul"},"Editor: Ramses Fernandez ","<",(0,i.kt)("a",{parentName:"li",href:"mailto:ramses@status.im"},"ramses@status.im"),">")),(0,i.kt)("h2",{id:"motivation"},"Motivation"),(0,i.kt)("p",null,"The need for secure communications has become paramount.",(0,i.kt)("br",{parentName:"p"}),"\n","Traditional centralized messaging protocols are susceptible to various security threats,\nincluding unauthorized access, data breaches, and single points of failure.\nTherefore a decentralized approach to secure communication becomes increasingly relevant,\noffering a robust solution to address these challenges."),(0,i.kt)("p",null,"This specification outlines a private messaging service using the\nEthereum blockchain as authentication service.\nRooted in the existing ",(0,i.kt)("a",{parentName:"p",href:"../../waku/standards/application/20/toy-eth-pm"},"model"),",\nthis proposal addresses the deficiencies related\nto forward privacy and authentication inherent\nin the current framework.\nThe specification is divided into 3 sections:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Private 1-to-1 communications protocol, based on ",(0,i.kt)("a",{parentName:"li",href:"https://signal.org/docs/specifications/doubleratchet/"},"Signal's double\nratchet"),"."),(0,i.kt)("li",{parentName:"ul"},"Private group messaging protocol, based on the\n",(0,i.kt)("a",{parentName:"li",href:"https://datatracker.ietf.org/doc/rfc9420/"},"MLS protocol"),"."),(0,i.kt)("li",{parentName:"ul"},"Description of an Ethereum-based authentication protocol, based on\n",(0,i.kt)("a",{parentName:"li",href:"https://eips.ethereum.org/EIPS/eip-4361"},"SIWE"),".")),(0,i.kt)("h2",{id:"private-1-to-1-communications-protocol"},"Private 1-to-1 communications protocol"),(0,i.kt)("h3",{id:"theory"},"Theory"),(0,i.kt)("p",null,"The specification is based on the noise protocol framework.\nIt corresponds to the double ratchet scheme combined with\nthe X3DH algorithm, which will be used to initialize the former.\nWe chose to express the protocol in noise to be be able to use\nthe noise streamlined implementation and proving features.\nThe X3DH algorithm provides both authentication and forward\nsecrecy, as stated in the\n",(0,i.kt)("a",{parentName:"p",href:"https://signal.org/docs/specifications/x3dh/"},"X3DH specification"),"."),(0,i.kt)("p",null,"This protocol will consist of several stages:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Key setting for X3DH: this step will produce\nprekey bundles for Bob which will be fed into X3DH.\nIt will also allow Alice to generate the keys required\nto run the X3DH algorithm correctly."),(0,i.kt)("li",{parentName:"ol"},"Execution of X3DH: This step will output\na common secret key ",(0,i.kt)("inlineCode",{parentName:"li"},"SK")," together with an additional\ndata vector ",(0,i.kt)("inlineCode",{parentName:"li"},"AD"),". Both will be used in the double\nratchet algorithm initialization."),(0,i.kt)("li",{parentName:"ol"},"Execution of the double ratchet algorithm\nfor forward secure, authenticated communications,\nusing the common secret key ",(0,i.kt)("inlineCode",{parentName:"li"},"SK"),", obtained from X3DH, as a root key.")),(0,i.kt)("p",null,"The protocol assumes the following requirements:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Alice knows Bob\u2019s Ethereum address."),(0,i.kt)("li",{parentName:"ul"},"Bob is willing to participate in the protocol,\nand publishes his public key."),(0,i.kt)("li",{parentName:"ul"},"Bob\u2019s ownership of his public key is verifiable,"),(0,i.kt)("li",{parentName:"ul"},"Alice wants to send message M to Bob."),(0,i.kt)("li",{parentName:"ul"},"An eavesdropper cannot read M\u2019s content\neven if she is storing it or relaying it.")),(0,i.kt)("p",null,">"," The inclusion of this first section devoted to secure 1-to-1\ncommunications between users is motivated by the fact certain\ninteractions between existing group members and prospective new\nmembers require secure communication channels."),(0,i.kt)("h3",{id:"syntax"},"Syntax"),(0,i.kt)("h4",{id:"cryptographic-suite"},"Cryptographic suite"),(0,i.kt)("p",null,"The following cryptographic functions MUST be used:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"X488")," as Diffie-Hellman function ",(0,i.kt)("inlineCode",{parentName:"li"},"DH"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"SHA256")," as KDF."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"AES256-GCM")," as AEAD algorithm."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"SHA512")," as hash function."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"XEd448")," for digital signatures.")),(0,i.kt)("h4",{id:"x3dh-initialization"},"X3DH initialization"),(0,i.kt)("p",null,"This scheme MUST work on the curve curve448.\nThe X3DH algorithm corresponds to the IX pattern in Noise."),(0,i.kt)("p",null,"Bob and Alice MUST define personal key pairs\n",(0,i.kt)("inlineCode",{parentName:"p"},"(ik_B, IK_B)")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"(ik_A, IK_A)")," respectively where:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The key ",(0,i.kt)("inlineCode",{parentName:"li"},"ik")," must be kept secret,"),(0,i.kt)("li",{parentName:"ul"},"and the key ",(0,i.kt)("inlineCode",{parentName:"li"},"IK")," is public.")),(0,i.kt)("p",null,"Bob MUST generate new keys using\n",(0,i.kt)("inlineCode",{parentName:"p"},"(ik_B, IK_B) = GENERATE_KEYPAIR(curve = curve448)"),"."),(0,i.kt)("p",null,"Bob MUST also generate a public key pair\n",(0,i.kt)("inlineCode",{parentName:"p"},"(spk_B, SPK_B) = GENERATE_KEYPAIR(curve = curve448)"),"."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"SPK")," is a public key generated and stored at medium-term.\nBoth signed prekey and the certificate MUST\nundergo periodic replacement.\nAfter replacing the key,\nBob keeps the old private key of ",(0,i.kt)("inlineCode",{parentName:"p"},"SPK"),"\nfor some interval, dependant on the implementation.\nThis allows Bob to decrypt delayed messages."),(0,i.kt)("p",null,"Bob MUST sign ",(0,i.kt)("inlineCode",{parentName:"p"},"SPK")," for authentication:\n",(0,i.kt)("inlineCode",{parentName:"p"},"SigSPK = XEd448(ik, Encode(SPK))")),(0,i.kt)("p",null,"A final step requires the definition of\n",(0,i.kt)("inlineCode",{parentName:"p"},"prekey_bundle = (IK, SPK, SigSPK, OPK_i)")),(0,i.kt)("p",null,"One-time keys ",(0,i.kt)("inlineCode",{parentName:"p"},"OPK")," MUST be generated as\n",(0,i.kt)("inlineCode",{parentName:"p"},"(opk_B, OPK_B) = GENERATE_KEYPAIR(curve = curve448)"),"."),(0,i.kt)("p",null,"Before sending an initial message to Bob,\nAlice MUST generate an AD: ",(0,i.kt)("inlineCode",{parentName:"p"},"AD = Encode(IK_A) || Encode(IK_B)"),"."),(0,i.kt)("p",null,"Alice MUST generate ephemeral key pairs\n",(0,i.kt)("inlineCode",{parentName:"p"},"(ek, EK) = GENERATE_KEYPAIR(curve = curve448)"),"."),(0,i.kt)("p",null,"The function ",(0,i.kt)("inlineCode",{parentName:"p"},"Encode()")," transforms a\ncurve448 public key into a byte sequence.\nThis is specified in the ",(0,i.kt)("a",{parentName:"p",href:"http://www.ietf.org/rfc/rfc7748.txt"},"RFC 7748"),"\non elliptic curves for security."),(0,i.kt)("p",null,"One MUST consider ",(0,i.kt)("inlineCode",{parentName:"p"},"q = 2^446 - 13818066809895115352007386748515426880336692474882178609894547503885"),"\nfor digital signatures with ",(0,i.kt)("inlineCode",{parentName:"p"},"(XEd448_sign, XEd448_verify)"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"XEd448_sign((ik, IK), message):\n    Z = randbytes(64)  \n    r = SHA512(2^456 - 2 || ik || message ||\xa0Z )\n    R = (r * convert_mont(5)) % q\n    h = SHA512(R ||\xa0IK || M)\n    s = (r + h * ik) % q\n    return (R || s)\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"XEd448_verify(u, message, (R || s)):\n    if (R.y >= 2^448) or (s >= 2^446): return FALSE\n    h = (SHA512(R || 156326 || message)) % q\n    R_check = s * convert_mont(5) - h * 156326\n    if R == R_check: return TRUE\n    return FALSE \n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"convert_mont(u):\n    u_masked = u % mod 2^448\n    inv = ((1 - u_masked)^(2^448 - 2^224 - 3)) % (2^448 - 2^224 - 1)\n    P.y = ((1 + u_masked) * inv)) % (2^448 - 2^224 - 1)\n    P.s = 0\n    return P\n")),(0,i.kt)("h4",{id:"use-of-x3dh"},"Use of X3DH"),(0,i.kt)("p",null,"This specification combines the double ratchet\nwith X3DH using the following data as initialization for the former:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"SK")," output from X3DH becomes the ",(0,i.kt)("inlineCode",{parentName:"li"},"SK"),"\ninput of the double ratchet. See section 3.3 of\n",(0,i.kt)("a",{parentName:"li",href:"https://signal.org/docs/specifications/doubleratchet/"},"Signal Specification"),"\nfor a detailed description."),(0,i.kt)("li",{parentName:"ul"},"The ",(0,i.kt)("inlineCode",{parentName:"li"},"AD")," output from X3DH becomes the ",(0,i.kt)("inlineCode",{parentName:"li"},"AD"),"\ninput of the double ratchet. See sections 3.4 and 3.5 of\n",(0,i.kt)("a",{parentName:"li",href:"https://signal.org/docs/specifications/doubleratchet/"},"Signal Specification"),"\nfor a detailed description."),(0,i.kt)("li",{parentName:"ul"},"Bob\u2019s signed prekey ",(0,i.kt)("inlineCode",{parentName:"li"},"SigSPKB")," from X3DH is used as Bob\u2019s\ninitial ratchet public key of the double ratchet.")),(0,i.kt)("p",null,"X3DH has three phases:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Bob publishes his identity key and prekeys to a server,\na network, or dedicated smart contract."),(0,i.kt)("li",{parentName:"ol"},"Alice fetches a prekey bundle from the server,\nand uses it to send an initial message to Bob."),(0,i.kt)("li",{parentName:"ol"},"Bob receives and processes Alice's initial message.")),(0,i.kt)("p",null,"Alice MUST perform the following computations:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"dh1 = DH(IK_A, SPK_B, curve = curve448)\ndh2 = DH(EK_A, IK_B, curve = curve448)\ndh3 = DH(EK_A, SPK_B)\nSK = KDF(dh1 || dh2 || dh3)\n")),(0,i.kt)("p",null,"Alice MUST send to Bob a message containing:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"IK_A, EK_A"),"."),(0,i.kt)("li",{parentName:"ul"},"An identifier to Bob's prekeys used."),(0,i.kt)("li",{parentName:"ul"},"A message encrypted with AES256-GCM using ",(0,i.kt)("inlineCode",{parentName:"li"},"AD")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"SK"),".")),(0,i.kt)("p",null,"Upon reception of the initial message, Bob MUST:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Perform the same computations above with the ",(0,i.kt)("inlineCode",{parentName:"li"},"DH()")," function."),(0,i.kt)("li",{parentName:"ol"},"Derive ",(0,i.kt)("inlineCode",{parentName:"li"},"SK")," and construct ",(0,i.kt)("inlineCode",{parentName:"li"},"AD"),"."),(0,i.kt)("li",{parentName:"ol"},"Decrypt the initial message encrypted with ",(0,i.kt)("inlineCode",{parentName:"li"},"AES256-GCM"),"."),(0,i.kt)("li",{parentName:"ol"},"If decryption fails, abort the protocol.")),(0,i.kt)("h4",{id:"initialization-of-the-double-datchet"},"Initialization of the double datchet"),(0,i.kt)("p",null,"In this stage Bob and Alice have generated key pairs\nand agreed a shared secret ",(0,i.kt)("inlineCode",{parentName:"p"},"SK")," using X3DH."),(0,i.kt)("p",null,"Alice calls ",(0,i.kt)("inlineCode",{parentName:"p"},"RatchetInitAlice()")," defined below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"RatchetInitAlice(SK, IK_B):\n    state.DHs = GENERATE_KEYPAIR(curve = curve448)\n    state.DHr = IK_B\n    state.RK, state.CKs = HKDF(SK, DH(state.DHs, state.DHr)) \n    state.CKr = None\n    state.Ns, state.Nr, state.PN = 0\n    state.MKSKIPPED = {}\n")),(0,i.kt)("p",null,"The HKDF function MUST be the proposal by\n",(0,i.kt)("a",{parentName:"p",href:"http://www.ietf.org/rfc/rfc5869.txt"},"Krawczyk and Eronen"),".\nIn this proposal ",(0,i.kt)("inlineCode",{parentName:"p"},"chaining_key")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"input_key_material"),"\nMUST be replaced with ",(0,i.kt)("inlineCode",{parentName:"p"},"SK")," and the output of ",(0,i.kt)("inlineCode",{parentName:"p"},"DH")," respectively."),(0,i.kt)("p",null,"Similarly, Bob calls the function ",(0,i.kt)("inlineCode",{parentName:"p"},"RatchetInitBob()")," defined below:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"RatchetInitBob(SK, (ik_B,IK_B)):\n    state.DHs = (ik_B, IK_B)\n    state.Dhr = None\n    state.RK = SK\n    state.CKs, state.CKr = None\n    state.Ns, state.Nr, state.PN = 0\n    state.MKSKIPPED = {}\n")),(0,i.kt)("h4",{id:"encryption"},"Encryption"),(0,i.kt)("p",null,"This function performs the symmetric key ratchet."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"RatchetEncrypt(state, plaintext, AD):\n   state.CKs, mk = HMAC-SHA256(state.CKs)\n   header = HEADER(state.DHs, state.PN, state.Ns)\n   state.Ns = state.Ns + 1\n   return header, AES256-GCM_Enc(mk, plaintext, AD || header)\n")),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"HEADER")," function creates a new message header\ncontaining the public key from the key pair output of the ",(0,i.kt)("inlineCode",{parentName:"p"},"DH"),"function.\nIt outputs the previous chain length ",(0,i.kt)("inlineCode",{parentName:"p"},"pn"),",\nand the message number ",(0,i.kt)("inlineCode",{parentName:"p"},"n"),".\nThe returned header object contains ratchet public key\n",(0,i.kt)("inlineCode",{parentName:"p"},"dh")," and integers ",(0,i.kt)("inlineCode",{parentName:"p"},"pn")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"n"),"."),(0,i.kt)("h4",{id:"decryption"},"Decryption"),(0,i.kt)("p",null,"The function ",(0,i.kt)("inlineCode",{parentName:"p"},"RatchetDecrypt()")," decrypts incoming messages:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"RatchetDecrypt(state, header, ciphertext, AD):\n    plaintext = TrySkippedMessageKeys(state, header, ciphertext, AD)\n    if plaintext != None:\n        return plaintext\n    if header.dh != state.DHr:\n        SkipMessageKeys(state, header.pn)\n        DHRatchet(state, header)\n    SkipMessageKeys(state, header.n)\n    state.CKr, mk = HMAC-SHA256(state.CKr)\n    state.Nr = state.Nr + 1\n    return AES256-GCM_Dec(mk, ciphertext, AD || header)\n")),(0,i.kt)("p",null,"Auxiliary functions follow:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"DHRatchet(state, header):\n    state.PN = state.Ns\n    state.Ns = state.Nr = 0\n    state.DHr = header.dh\n    state.RK, state.CKr = HKDF(state.RK, DH(state.DHs, state.DHr))\n    state.DHs = GENERATE_KEYPAIR(curve = curve448)\n    state.RK, state.CKs = HKDF(state.RK, DH(state.DHs, state.DHr))\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"SkipMessageKeys(state, until):\n    if state.NR + MAX_SKIP < until:\n        raise Error\n    if state.CKr != none:\n        while state.Nr < until:\n            state.CKr, mk = HMAC-SHA256(state.CKr)\n            state.MKSKIPPED[state.DHr, state.Nr] = mk\n            state.Nr = state.Nr + 1\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"TrySkippedMessageKey(state, header, ciphertext, AD):\n    if (header.dh, header.n) in state.MKSKIPPED:\n        mk = state.MKSKIPPED[header.dh, header.n]\n        delete state.MKSKIPPED[header.dh, header.n]\n        return AES256-GCM_Dec(mk, ciphertext, AD || header)\n    else: return None\n")),(0,i.kt)("h2",{id:"information-retrieval"},"Information retrieval"),(0,i.kt)("h3",{id:"static-data"},"Static data"),(0,i.kt)("p",null,"Some data, such as the key pairs ",(0,i.kt)("inlineCode",{parentName:"p"},"(ik, IK)")," for Alice and Bob,\nMAY NOT be regenerated after a period of time.\nTherefore the prekey bundle MAY be stored in long-term\nstorage solutions, such as a dedicated smart contract\nwhich outputs such a key pair when receiving an Ethereum wallet\naddress."),(0,i.kt)("p",null,"Storing static data is done using a dedicated\nsmart contract ",(0,i.kt)("inlineCode",{parentName:"p"},"PublicKeyStorage")," which associates\nthe Ethereum wallet address of a user with his public key.\nThis mapping is done by ",(0,i.kt)("inlineCode",{parentName:"p"},"PublicKeyStorage"),"\nusing a ",(0,i.kt)("inlineCode",{parentName:"p"},"publicKeys")," function, or a ",(0,i.kt)("inlineCode",{parentName:"p"},"setPublicKey")," function.\nThis mapping is done if the user passed an authorization process.\nA user who wants to retrieve a public key associated\nwith a specific wallet address calls a function ",(0,i.kt)("inlineCode",{parentName:"p"},"getPublicKey"),".\nThe user provides the wallet address as the only\ninput parameter for ",(0,i.kt)("inlineCode",{parentName:"p"},"getPublicKey"),".\nThe function outputs the associated public key\nfrom the smart contract."),(0,i.kt)("h3",{id:"ephemeral-data"},"Ephemeral data"),(0,i.kt)("p",null,"Storing ephemeral data on Ethereum MAY be done using\na combination of on-chain and off-chain solutions.\nThis approach provides an efficient solution to\nthe problem of storing updatable data in Ethereum."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Ethereum stores a reference or a hash\nthat points to the off-chain data."),(0,i.kt)("li",{parentName:"ol"},"Off-chain solutions can include systems like IPFS,\ntraditional cloud storage solutions, or\ndecentralized storage networks such as a\n",(0,i.kt)("a",{parentName:"li",href:"https://www.ethswarm.org"},"Swarm"),".")),(0,i.kt)("p",null,"In any case, the user stores the associated\nIPFS hash, URL or reference in Ethereum."),(0,i.kt)("p",null,"The fact of a user not updating the ephemeral information\ncan be understood as Bob not willing to participate in any\ncommunication."),(0,i.kt)("p",null,"This applies to ",(0,i.kt)("inlineCode",{parentName:"p"},"KeyPackage"),",\nwhich in the MLS specification are meant\no be stored in a directory provided by the delivery service.\nIf such an element does not exist,\n",(0,i.kt)("inlineCode",{parentName:"p"},"KeyPackage")," MUST be stored according\nto one of the two options outlined above."),(0,i.kt)("h2",{id:"private-group-messaging-protocol"},"Private group messaging protocol"),(0,i.kt)("h3",{id:"theoretical-content"},"Theoretical content"),(0,i.kt)("p",null,"The ",(0,i.kt)("a",{parentName:"p",href:"https://datatracker.ietf.org/doc/rfc9420/"},"Messaging Layer Security"),"(MLS)\nprotocol aims at providing a group of users with\nend-to-end encryption in an authenticated and asynchronous way.\nThe main security characteristics of the protocol are:\nMessage confidentiality and authentication, sender authentication,\nmembership agreement, post-remove\nand post-update security, and forward secrecy and\npost-compromise security.\nThe MLS protocol achieves: low-complexity, group integrity,\nsynchronization and extensibility."),(0,i.kt)("p",null,"The extension to group chat described in forthcoming sections is built upon the\n",(0,i.kt)("a",{parentName:"p",href:"https://datatracker.ietf.org/doc/rfc9420/"},"MLS")," protocol."),(0,i.kt)("h3",{id:"structure"},"Structure"),(0,i.kt)("p",null,"Each MLS session uses a single cipher suite that specifies the\nprimitives to be used in group key computations. The cipher suite MUST\nuse:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"X488")," as Diffie-Hellman function."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"SHA256")," as KDF."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"AES256-GCM")," as AEAD algorithm."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"SHA512")," as hash function."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"XEd448")," for digital signatures.")),(0,i.kt)("p",null,"Formats for public keys, signatures and public-key encryption MUST\nfollow Section 5.1 of\n",(0,i.kt)("a",{parentName:"p",href:"https://datatracker.ietf.org/doc/rfc9420/"},"RFC9420"),"."),(0,i.kt)("h3",{id:"hash-based-identifiers"},"Hash-based identifiers"),(0,i.kt)("p",null,"Some MLS messages refer to other MLS objects by hash.\nThese identifiers MUST be computed according to Section 5.2 of\n",(0,i.kt)("a",{parentName:"p",href:"https://datatracker.ietf.org/doc/rfc9420/"},"RFC9420"),"."),(0,i.kt)("h3",{id:"credentials"},"Credentials"),(0,i.kt)("p",null,"Each member of a group presents a credential that provides one or more\nidentities for the\nmember and associates them with the member's signing key.\nThe identities and signing key are verified by the Authentication\nService in use for a\ngroup."),(0,i.kt)("p",null,"Credentials MUST follow the specifications of section 5.3 of\n",(0,i.kt)("a",{parentName:"p",href:"https://datatracker.ietf.org/doc/rfc9420/"},"RFC9420"),"."),(0,i.kt)("p",null,"Below follows the flow diagram for the generation of credentials.\nUsers MUST generate key pairs by themselves.\n",(0,i.kt)("img",{alt:"figure1",src:n(83684).Z,width:"460",height:"228"})),(0,i.kt)("h3",{id:"message-framing"},"Message framing"),(0,i.kt)("p",null,"Handshake and application messages use a common framing structure\nproviding encryption to\nensure confidentiality within the group, and signing to authenticate\nthe sender."),(0,i.kt)("p",null,"The structure is:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"PublicMessage"),": represents a message that is only signed, and not\nencrypted.\nThe definition and the encoding/decoding of a ",(0,i.kt)("inlineCode",{parentName:"li"},"PublicMessage")," MUST\nfollow the specification\nin section 6.2 of ",(0,i.kt)("a",{parentName:"li",href:"https://datatracker.ietf.org/doc/rfc9420/"},"RFC9420"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"PrivateMessage"),": represents a signed and encrypted message, with\nprotections for both the content of the message and related metadata.")),(0,i.kt)("p",null,"The definition, and the encoding/decoding of a ",(0,i.kt)("inlineCode",{parentName:"p"},"PrivateMessage")," MUST\nfollow the  specification in section 6.3 of\n",(0,i.kt)("a",{parentName:"p",href:"https://datatracker.ietf.org/doc/rfc9420/"},"RFC9420"),"."),(0,i.kt)("p",null,"Applications MUST use ",(0,i.kt)("inlineCode",{parentName:"p"},"PrivateMessage")," to encrypt application messages."),(0,i.kt)("p",null,"Applications SHOULD use ",(0,i.kt)("inlineCode",{parentName:"p"},"PrivateMessage")," to encode handshake messages."),(0,i.kt)("p",null,'Each encrypted MLS message carries a "generation" number which is a\nper-sender incrementing counter.\nIf a group member observes a gap in the generation sequence for a\nsender, then they know that they have missed a message from that\nsender.'),(0,i.kt)("h3",{id:"nodes-contents"},"Nodes contents"),(0,i.kt)("p",null,"The nodes of a ratchet tree contain several types of data:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Leaf nodes describe individual members."),(0,i.kt)("li",{parentName:"ul"},"Parent nodes describe subgroups.")),(0,i.kt)("p",null,"Contents of each kind of node, and its structure MUST follow the\nindications described in\nsections 7.1 and 7.2 of\n",(0,i.kt)("a",{parentName:"p",href:"https://datatracker.ietf.org/docrfc9420/"},"RFC9420"),"."),(0,i.kt)("h3",{id:"leaf-node-validation"},"Leaf node validation"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"KeyPackage")," objects describe the client's capabilities and provides\nkeys that can be used  to add the client to a group."),(0,i.kt)("p",null,"The validity of a leaf node needs to be verified at the following\nstages:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"When a leaf node is downloaded in a ",(0,i.kt)("inlineCode",{parentName:"li"},"KeyPackage"),", before it is used\nto add the client to the group."),(0,i.kt)("li",{parentName:"ul"},"When a leaf node is received by a group member in an Add, Update, or\nCommit message."),(0,i.kt)("li",{parentName:"ul"},"When a client validates a ratchet tree.")),(0,i.kt)("p",null,"A client MUST verify the validity of a leaf node following the\ninstructions of section 7.3 in\n",(0,i.kt)("a",{parentName:"p",href:"https://datatracker.ietf.org/doc/rfc9420/"},"RFC9420"),"."),(0,i.kt)("h3",{id:"ratchet-tree-evolution"},"Ratchet tree evolution"),(0,i.kt)("p",null,"Whenever a member initiates an epoch change, they MAY need to refresh\nthe key pairs of their leaf and of the nodes on their direct path. This\nis done to keep forward secrecy and post-compromise security.\nThe member initiating the epoch change MUST follow this procedure\nprocedure.\nA member updates the nodes along its direct path as follows:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Blank all the nodes on the direct path from the leaf to the root."),(0,i.kt)("li",{parentName:"ul"},"Generate a fresh HPKE key pair for the leaf."),(0,i.kt)("li",{parentName:"ul"},"Generate a sequence of path secrets, one for each node on the leaf's\nfiltered direct path.")),(0,i.kt)("p",null,"It MUST follow the procedure described in section 7.4 of [RFC9420\n(",(0,i.kt)("a",{parentName:"p",href:"https://datatracker.ietf.org/doc/rfc9420/"},"https://datatracker.ietf.org/doc/rfc9420/"),")."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Compute the sequence of HPKE key pairs ",(0,i.kt)("inlineCode",{parentName:"li"},"(node_priv,node_pub)"),", one\nfor each node on the leaf's direct path.")),(0,i.kt)("p",null,"It MUST follow the procedure described in section 7.4 of [RFC9420\n(",(0,i.kt)("a",{parentName:"p",href:"https://datatracker.ietf.org/doc/rfc9420/"},"https://datatracker.ietf.org/doc/rfc9420/"),")."),(0,i.kt)("h3",{id:"views-of-the-tree-synchronization"},"Views of the tree synchronization"),(0,i.kt)("p",null,"After generating fresh key material and applying it to update their\nlocal tree state, the generator broadcasts this update to other members\nof the group.\nThis operation MUST be done according to section 7.5 of [RFC9420\n(",(0,i.kt)("a",{parentName:"p",href:"https://datatracker.ietf.org/doc/rfc9420/"},"https://datatracker.ietf.org/doc/rfc9420/"),")."),(0,i.kt)("h3",{id:"leaf-synchronization"},"Leaf synchronization"),(0,i.kt)("p",null,"Changes to group memberships MUST be represented by adding and removing\nleaves of the tree.\nThis corresponds to increasing or decreasing the depth of the tree,\nresulting in the number of leaves being doubled or halved.\nThese operations MUST be done as described in section 7.7 of [RFC9420\n(",(0,i.kt)("a",{parentName:"p",href:"https://datatracker.ietf.org/doc/rfc9420/"},"https://datatracker.ietf.org/doc/rfc9420/"),")."),(0,i.kt)("h3",{id:"tree-and-parent-hashing"},"Tree and parent hashing"),(0,i.kt)("p",null,"Group members can agree on the cryptographic state of the group by\ngenerating a hash value that represents the contents of the group\nratchet tree and the member\u2019s credentials.\nThe hash of the tree is the hash of its root node, defined recursively\nfrom the leaves.\nTree hashes summarize the state of a tree at point in time.\nThe hash of a leaf is the hash of the ",(0,i.kt)("inlineCode",{parentName:"p"},"LeafNodeHashInput")," object.\nAt the same time, the hash of a parent node including the root, is the\nhash of a ",(0,i.kt)("inlineCode",{parentName:"p"},"ParentNodeHashInput")," object.\nParent hashes capture information about how keys in the tree were\npopulated."),(0,i.kt)("p",null,"Tree and parent hashing MUST follow the directions in Sections 7.8 and\n7.9 of ",(0,i.kt)("a",{parentName:"p",href:"https://datatracker.ietf.org/doc/rfc9420/"},"RFC9420"),"."),(0,i.kt)("h3",{id:"key-schedule"},"Key schedule"),(0,i.kt)("p",null,"Group keys are derived using the ",(0,i.kt)("inlineCode",{parentName:"p"},"Extract")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"Expand")," functions from\nthe KDF for the group's cipher suite, as well as the functions defined\nbelow:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},'ExpandWithLabel(Secret, Label, Context, Length) = KDF.Expand(Secret,\nKDFLabel, Length)\nDeriveSecret(Secret, Label) = ExpandWithLabel(Secret, Label, "",\nKDF.Nh)\n\n')),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"KDFLabel")," MUST be specified as:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"struct {\n    uint16 length;\n    opaque label<V>;\n    opaque context<V>;\n} KDFLabel;\n\n")),(0,i.kt)("p",null,"The fields of ",(0,i.kt)("inlineCode",{parentName:"p"},"KDFLabel")," MUST be:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},'length = Length;\nlabel = "MLS 1.0 " + Label;\ncontext = Context;\n\n')),(0,i.kt)("p",null,"Each member of the group MUST maintaint a ",(0,i.kt)("inlineCode",{parentName:"p"},"GroupContext")," object\nsummarizing the state of the group."),(0,i.kt)("p",null,"The sturcture of such object MUST be:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"struct {\nProtocolVersion version = mls10;\nCipherSuite cipher_suite;\nopaque group_id<V>;\nuint64 epoch;\nopaque tree_hash<V>;\nopaque confirmed_trasncript_hash<V>;\nExtension extension<V>;\n} GroupContext;\n\n")),(0,i.kt)("p",null,"The use of key scheduling MUST follow the indications in sections 8.1 -\n8.7 in ",(0,i.kt)("a",{parentName:"p",href:"https://datatracker.ietf.org/doc/rfc9420/"},"RFC9420"),"."),(0,i.kt)("h3",{id:"secret-trees"},"Secret trees"),(0,i.kt)("p",null,"For the generation of encryption keys and nonces, the key schedule\nbegins with the ",(0,i.kt)("inlineCode",{parentName:"p"},"encryption_secret")," at the root and derives a tree of\nsecrets with the same structure as the group's ratchet tree.\nEach leaf in the secret tree is associated with the same group member\nas the corresponding leaf in the ratchet tree."),(0,i.kt)("p",null,"If ",(0,i.kt)("inlineCode",{parentName:"p"},"N")," is a parent node in the secret tree, the secrets of the children\nof ",(0,i.kt)("inlineCode",{parentName:"p"},"N")," MUST be defined following section 9 of\n",(0,i.kt)("a",{parentName:"p",href:"https://datatracker.ietf.org/doc/rfc9420/"},"RFC9420"),"."),(0,i.kt)("h4",{id:"encryption-keys"},"Encryption keys"),(0,i.kt)("p",null,"MLS encrypts three different types of information:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Metadata (sender information)."),(0,i.kt)("li",{parentName:"ul"},"Handshake messages (Proposal and Commit)."),(0,i.kt)("li",{parentName:"ul"},"Application messages.")),(0,i.kt)("p",null,"For handshake and application messages, a sequence of keys is derived\nvia a sender ratchet.\nEach sender has their own sender ratchet, and each step along the\nratchet is called a generation. These procedures MUST follow section\n9.1 of ",(0,i.kt)("a",{parentName:"p",href:"https://datatracker.ietf.org/doc/rfc9420/"},"RFC9420"),"."),(0,i.kt)("h4",{id:"deletion-schedule"},"Deletion schedule"),(0,i.kt)("p",null,"All security-sensitive values MUST be deleted as soon as they are\nconsumed."),(0,i.kt)("p",null,"A sensitive value S is consumed if:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"S was used to encrypt or (successfully) decrypt a message."),(0,i.kt)("li",{parentName:"ul"},"A key, nonce, or secret derived from S has been consumed.")),(0,i.kt)("p",null,"The deletion procedure MUST follow the instruction described in section\n9.2 of ",(0,i.kt)("a",{parentName:"p",href:"https://datatracker.ietf.org/doc/rfc9420/"},"RFC9420"),"."),(0,i.kt)("h3",{id:"key-packages"},"Key packages"),(0,i.kt)("p",null,"KeyPackage objects are used to ease the addition of clients to a group\nasynchronously.\nA KeyPackage object specifies:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Protocol version and cipher suite supported by the client."),(0,i.kt)("li",{parentName:"ul"},"Public keys that can be used to encrypt Welcome messages.\nWelcome messages provide new members with the information\nto initialize their\nstate for the epoch in which they were added or in which they want to\nadd themselves to the group"),(0,i.kt)("li",{parentName:"ul"},"The content of the leaf node that should be added to the tree to\nrepresent this client.")),(0,i.kt)("p",null,"KeyPackages are intended to be used only once and SHOULD NOT be reused."),(0,i.kt)("p",null,"Clients MAY generate and publish multiple KeyPackages to support\nmultiple cipher suites."),(0,i.kt)("p",null,"The structure of the object MUST be:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},'struct {\nProtocolVersion version;\nCipherSuite cipher_suite;\nHPKEPublicKey init_key;\nLeafNode leaf_node;\nExtension extensions<V>;\n/* SignWithLabel(., "KeyPackageTBS", KeyPackageTBS) */\nopaque signature<V>;\n}\n\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"struct {\nProtocolVersion version;\nCipheSuite cipher_suite;\nHPKEPublicKey init_key;\nLeafNode leaf_node;\nExtension extensions<V>;\n}\n\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"KeyPackage")," object MUST be verified when:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A ",(0,i.kt)("inlineCode",{parentName:"li"},"KeyPackage")," is downloaded by a group member, before it is used to\nadd the client to the group."),(0,i.kt)("li",{parentName:"ul"},"When a ",(0,i.kt)("inlineCode",{parentName:"li"},"KeyPackage")," is received by a group member in an ",(0,i.kt)("inlineCode",{parentName:"li"},"Add"),"\nmessage.")),(0,i.kt)("p",null,"Verification MUST be done as follows:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Verify that the cipher suite and protocol version of the ",(0,i.kt)("inlineCode",{parentName:"li"},"KeyPackage"),"\nmatch those in the ",(0,i.kt)("inlineCode",{parentName:"li"},"GroupContext"),"."),(0,i.kt)("li",{parentName:"ul"},"Verify that the ",(0,i.kt)("inlineCode",{parentName:"li"},"leaf_node")," of the ",(0,i.kt)("inlineCode",{parentName:"li"},"KeyPackage")," is valid for a\n",(0,i.kt)("inlineCode",{parentName:"li"},"KeyPackage"),"."),(0,i.kt)("li",{parentName:"ul"},"Verify that the signature on the ",(0,i.kt)("inlineCode",{parentName:"li"},"KeyPackage")," is valid."),(0,i.kt)("li",{parentName:"ul"},"Verify that the value of ",(0,i.kt)("inlineCode",{parentName:"li"},"leaf_node.encryption_key")," is different from\nthe value of the ",(0,i.kt)("inlineCode",{parentName:"li"},"init_key field"),".")),(0,i.kt)("p",null,"HPKE public keys are opaque values in a format defined by Section 4 of\n",(0,i.kt)("a",{parentName:"p",href:"https://datatracker.ietf.org/doc/rfc9180/"},"RFC9180"),"."),(0,i.kt)("p",null,"Signature public keys are represented as opaque values in a format\ndefined by the cipher suite's signature scheme."),(0,i.kt)("h3",{id:"group-creation"},"Group creation"),(0,i.kt)("p",null,"A group is always created with a single member.\nOther members are then added to the group using the usual Add/Commit\nmechanism.\nThe creator of a group MUST set:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"the group ID."),(0,i.kt)("li",{parentName:"ul"},"cipher suite."),(0,i.kt)("li",{parentName:"ul"},"initial extensions for the group.")),(0,i.kt)("p",null,"If the creator intends to add other members at the time of creation,\nthen it SHOULD fetch ",(0,i.kt)("inlineCode",{parentName:"p"},"KeyPackages")," for those members, and select a\ncipher suite and extensions according to their capabilities."),(0,i.kt)("p",null,"The creator MUST use the capabilities information in these\n",(0,i.kt)("inlineCode",{parentName:"p"},"KeyPackages")," to verify that the chosen version and cipher suite is the\nbest option supported by all members."),(0,i.kt)("p",null,"Group IDs SHOULD be constructed so they are unique with high\nprobability."),(0,i.kt)("p",null,"To initialize a group, the creator of the group MUST initialize a one\nmember group with the following initial values:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Ratchet tree: A tree with a single node, a leaf node containing an\nHPKE public key and credential for the creator."),(0,i.kt)("li",{parentName:"ul"},"Group ID: A value set by the creator."),(0,i.kt)("li",{parentName:"ul"},"Epoch: ",(0,i.kt)("inlineCode",{parentName:"li"},"0"),"."),(0,i.kt)("li",{parentName:"ul"},"Tree hash: The root hash of the above ratchet tree."),(0,i.kt)("li",{parentName:"ul"},"Confirmed transcript hash: The zero-length octet string."),(0,i.kt)("li",{parentName:"ul"},"Epoch secret: A fresh random value of size ",(0,i.kt)("inlineCode",{parentName:"li"},"KDF.Nh"),"."),(0,i.kt)("li",{parentName:"ul"},"Extensions: Any values of the creator's choosing.")),(0,i.kt)("p",null,"The creator MUST also calculate the interim transcript hash:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Derive the ",(0,i.kt)("inlineCode",{parentName:"li"},"confirmation_key")," for the epoch according to Section 8 of\n",(0,i.kt)("a",{parentName:"li",href:"https://datatracker.ietf.org/doc/rfc9420/"},"RFC9420"),"."),(0,i.kt)("li",{parentName:"ul"},"Compute a ",(0,i.kt)("inlineCode",{parentName:"li"},"confirmation_tag")," over the empty\n",(0,i.kt)("inlineCode",{parentName:"li"},"confirmed_transcript_hash")," using the ",(0,i.kt)("inlineCode",{parentName:"li"},"confirmation_key")," as described\nin Section 8.1 of ",(0,i.kt)("a",{parentName:"li",href:"https://datatracker.ietf.org/doc/rfc9420/"},"RFC9420"),"."),(0,i.kt)("li",{parentName:"ul"},"Compute the updated ",(0,i.kt)("inlineCode",{parentName:"li"},"interim_transcript_hash")," from the\n",(0,i.kt)("inlineCode",{parentName:"li"},"confirmed_transcript_hash")," and the ",(0,i.kt)("inlineCode",{parentName:"li"},"confirmation_tag")," as described in\nSection 8.2 ",(0,i.kt)("a",{parentName:"li",href:"https://datatracker.ietf.org/doc/rfc9420/"},"RFC9420"),".")),(0,i.kt)("p",null,"All members of a group MUST support the cipher suite and protocol\nversion in use. Additional requirements MAY be imposed by including a\n",(0,i.kt)("inlineCode",{parentName:"p"},"required_capabilities")," extension in the ",(0,i.kt)("inlineCode",{parentName:"p"},"GroupContext"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"struct {\nExtensionType extension_types<V>;\nProposalType proposal_types<V>;\nCredentialType credential_types<V>;\n}\n\n")),(0,i.kt)("p",null,"The flow diagram shows the procedure to fetch key material from other\nusers:\n",(0,i.kt)("img",{alt:"figure2",src:n(38669).Z,width:"510",height:"425"})),(0,i.kt)("p",null,"Below follows the flow diagram for the creation of a group:\n",(0,i.kt)("img",{alt:"figure3",src:n(25475).Z,width:"622",height:"720"})),(0,i.kt)("h3",{id:"group-evolution"},"Group evolution"),(0,i.kt)("p",null,"Group membership can change, and existing members can change their keys\nin order to achieve post-compromise security.\nIn MLS, each such change is accomplished by a two-step process:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A proposal to make the change is broadcast to the group in a Proposal\nmessage."),(0,i.kt)("li",{parentName:"ul"},"A member of the group or a new member broadcasts a Commit message\nthat causes one or more proposed changes to enter into effect.")),(0,i.kt)("p",null,"The group evolves from one cryptographic state to another each time a\nCommit message is sent and processed.\nThese states are called epochs and are uniquely identified among states\nof the group by eight-octet epoch values."),(0,i.kt)("p",null,"Proposals are included in a ",(0,i.kt)("inlineCode",{parentName:"p"},"FramedContent")," by way of a ",(0,i.kt)("inlineCode",{parentName:"p"},"Proposal"),"\nstructure that indicates their type:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},"struct {\nProposalType proposal_type;\nselect (Proposal.proposal_type) {\ncase add:                      Add:\ncase update:                   Update;\ncase remove:                   Remove;\ncase psk:                      PreSharedKey;\ncase reinit:                   ReInit;\ncase external_init:            ExternalInit;\ncase group_context_extensions: GroupContextExtensions;\n}\n\n")),(0,i.kt)("p",null,"On receiving a ",(0,i.kt)("inlineCode",{parentName:"p"},"FramedContent")," containing a ",(0,i.kt)("inlineCode",{parentName:"p"},"Proposal"),", a client MUST\nverify the signature inside ",(0,i.kt)("inlineCode",{parentName:"p"},"FramedContentAuthData")," and that the epoch\nfield of the enclosing FramedContent is equal to the epoch field of the\ncurrent GroupContext object.\nIf the verification is successful, then the Proposal SHOULD be cached\nin such a way that it can be retrieved by hash in a later Commit\nmessage."),(0,i.kt)("p",null,"Proposals are organized as follows:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Add"),": requests that a client with a specified KeyPackage be added to\nthe group."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Update"),": similar to Add, it replaces the sender's LeafNode in the\ntree instead of adding a new leaf to the tree."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"Remove"),": requests that the member with the leaf index removed be\nremoved from the group."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ReInit"),": requests to reinitialize the group with different\nparameters."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ExternalInit"),": used by new members that want to join a group by\nusing an external commit."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"GroupContentExtensions"),": it is used to update the list of extensions\nin the GroupContext for the group.")),(0,i.kt)("p",null,"Proposals structure and semantics MUST follow sections 12.1.1 - 12.1.7\nof ",(0,i.kt)("a",{parentName:"p",href:"https://datatracker.ietf.org/doc/rfc9420/"},"RFC9420"),"."),(0,i.kt)("p",null,"Any list of commited proposals MUST be validated either by a the group\nmember who created the commit, or any group member processing such\ncommit.\nThe validation MUST be done according to one of the procedures\ndescribed in Section 12.2 of\n",(0,i.kt)("a",{parentName:"p",href:"https://datatracker.ietf.orgdoc/rfc9420/"},"RFC9420"),"."),(0,i.kt)("p",null,"When creating or processing a Commit, a client applies a list of\nproposals to the ratchet tree and ",(0,i.kt)("inlineCode",{parentName:"p"},"GroupContext"),".\nThe client MUST apply the proposals in the list in the order described\nin Section 12.3 of ",(0,i.kt)("a",{parentName:"p",href:"https://datatracker.ietf.org/docrfc9420/"},"RFC9420"),"."),(0,i.kt)("p",null,"Below follows the flow diagram for the addition of a member to a group:\n",(0,i.kt)("img",{alt:"figure4",src:n(16138).Z,width:"586",height:"769"})),(0,i.kt)("p",null,"The diagram below shows the procedure to remove a group member:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"figure5",src:n(75133).Z,width:"622",height:"425"})),(0,i.kt)("p",null,"The flow diagram below shows an update procedure:"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"figure6",src:n(2501).Z,width:"463",height:"622"})),(0,i.kt)("h3",{id:"commit-messages"},"Commit messages"),(0,i.kt)("p",null,"Commit messages initiate new group epochs.\nIt informs group members to update their representation of the state of\nthe group by applying the proposals and advancing the key schedule."),(0,i.kt)("p",null,"Each proposal covered by the Commit is included by a ",(0,i.kt)("inlineCode",{parentName:"p"},"ProposalOrRef"),"\nvalue.\n",(0,i.kt)("inlineCode",{parentName:"p"},"ProposalOrRef")," identify the proposal to be applied by value or by\nreference.\nCommits that refer to new Proposals from the committer can be included\nby value.\nCommits for previously sent proposals from anyone can be sent by\nreference.\nProposals sent by reference are specified by including the hash of the\n",(0,i.kt)("inlineCode",{parentName:"p"},"AuthenticatedContent"),"."),(0,i.kt)("p",null,"Group members that have observed one or more valid proposals within an\nepoch MUST send a Commit message before sending application data.\nA sender and a receiver of a Commit MUST verify that the committed list\nof proposals is valid.\nThe sender of a Commit SHOULD include all valid proposals received\nduring the current epoch."),(0,i.kt)("p",null,"Functioning of commits MUST follow the instructions of Section 12.4 of\n",(0,i.kt)("a",{parentName:"p",href:"https://datatracker.ietf.org/doc/rfc9420/"},"RFC9420"),"."),(0,i.kt)("h3",{id:"application-messages"},"Application messages"),(0,i.kt)("p",null,"Handshake messages provide an authenticated group key exchange to\nclients.\nTo protect application messages sent among the members of a group, the\n",(0,i.kt)("inlineCode",{parentName:"p"},"encryption_secret")," provided by the key schedule is used to derive a\nsequence of nonces and keys for message encryption."),(0,i.kt)("p",null,"Each client MUST maintain their local copy of the key schedule for each\nepoch during which they are a group member.\nThey derive new keys, nonces, and secrets as needed. This data MUST be\ndeleted as soon as they have been used."),(0,i.kt)("p",null,"Group members MUST use the AEAD algorithm associated with the\nnegotiated MLS ciphersuite to encrypt and decrypt Application messages\naccording to the Message Framing section.\nThe group identifier and epoch allow a device to know which group\nsecrets should be used and from which Epoch secret to start computing\nother secrets and keys.\nApplication messages SHOULD be padded to provide resistance against\ntraffic analysis techniques.\nThis avoids additional information to be provided to an attacker in\norder to guess the length of the encrypted message.\nPadding SHOULD be used on messages with zero-valued bytes before AEAD\nencryption."),(0,i.kt)("p",null,"Functioning of application messages MUST follow the instructions of\nSection 15 of ",(0,i.kt)("a",{parentName:"p",href:"https://datatracker.ietf.org/doc/rfc9420/"},"RFC9420"),"."),(0,i.kt)("h3",{id:"considerations-with-respect-to-decentralization"},"Considerations with respect to decentralization"),(0,i.kt)("p",null,"The MLS protocol assumes the existence on a (central, untrusted)\n",(0,i.kt)("em",{parentName:"p"},"delivery service"),", whose responsabilites include:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Acting as a directory service providing the initial\nkeying material for clients to use."),(0,i.kt)("li",{parentName:"ul"},"Routing MLS messages among clients.")),(0,i.kt)("p",null,"The central delivery service can be avoided in protocols using the\npublish/gossip approach, such as\n",(0,i.kt)("a",{parentName:"p",href:"https://github.com/libp2p/specs/tree/master/pubsub/gossipsub"},"gossipsub"),"."),(0,i.kt)("p",null,"Concerning keys, each node can generate and disseminate their\nencryption key among the other nodes, so they can create a local\nversion of the tree that allows for the generation of the group key."),(0,i.kt)("p",null,"Another important component is the ",(0,i.kt)("em",{parentName:"p"},"authentication service"),", which is\nreplaced with SIWE in this specification."),(0,i.kt)("h2",{id:"ethereum-based-authentication-protocol"},"Ethereum-based authentication protocol"),(0,i.kt)("h3",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,"Sign-in with Ethereum describes how Ethereum accounts authenticate with\noff-chain services by signing a standard message format\nparameterized by scope, session details, and security mechanisms.\nSign-in with Ethereum (SIWE), which is described in the [EIP 4361\n(",(0,i.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-4361"},"https://eips.ethereum.org/EIPS/eip-4361"),"), MUST be the authentication\nmethod required."),(0,i.kt)("h3",{id:"pattern"},"Pattern"),(0,i.kt)("h4",{id:"message-format-abnf"},"Message format (ABNF)"),(0,i.kt)("p",null,"A SIWE Message MUST conform with the following Augmented Backus\u2013Naur\nForm (",(0,i.kt)("a",{parentName:"p",href:"https://datatracker.ietf.org/doc/html/rfc5234"},"RFC 5234"),")\nexpression."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-text"},'sign-in-with-ethereum =\n    [ scheme "://" ] domain %s" wants you to sign in with your \n    Ethereum account:" LF address LF\n    LF\n    [ statement LF ]\n    LF\n    %s"URI: " uri LF\n    %s"Version: " version LF\n    %s"Chain ID: " chain-id LF\n    %s"Nonce: " nonce LF\n    %s"Issued At: " issued-at\n    [ LF %s"Expiration Time: " expiration-time ]\n    [ LF %s"Not Before: " not-before ]\n    [ LF %s"Request ID: " request-id ]\n    [ LF %s"Resources:"\n    resources ]\n\nscheme = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )\n    ; See RFC 3986 for the fully contextualized\n    ; definition of "scheme".\n\ndomain = authority\n    ; From RFC 3986:\n    ;     authority     = [ userinfo "@" ] host [ ":" port ]\n    ; See RFC 3986 for the fully contextualized\n    ; definition of "authority".\n\naddress = "0x" 40*40HEXDIG\n    ; Must also conform to captilization\n    ; checksum encoding specified in EIP-55\n    ; where applicable (EOAs).\n\nstatement = *( reserved / unreserved / " " )\n    ; See RFC 3986 for the definition\n    ; of "reserved" and "unreserved".\n    ; The purpose is to exclude LF (line break).\n\nuri = URI\n    ; See RFC 3986 for the definition of "URI".\n\nversion = "1"\n\nchain-id = 1*DIGIT\n    ; See EIP-155 for valid CHAIN_IDs.\n\nnonce = 8*( ALPHA / DIGIT )\n    ; See RFC 5234 for the definition\n    ; of "ALPHA" and "DIGIT".\n\nissued-at = date-time\nexpiration-time = date-time\nnot-before = date-time\n    ; See RFC 3339 (ISO 8601) for the\n    ; definition of "date-time".\n\nrequest-id = *pchar\n    ; See RFC 3986 for the definition of "pchar".\n\nresources = *( LF resource )\n\nresource = "- " URI\n\n')),(0,i.kt)("p",null,"This specification defines the following SIWE Message fields that can\nbe parsed from a SIWE Message by following the rules in ABNF Message\nFormat:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"scheme")," OPTIONAL. The URI scheme of the origin of the request.\nIts value MUST be a\n",(0,i.kt)("a",{parentName:"p",href:"https://datatracker.ietf.org/doc/htmlrfc3986"},"RFC 3986"),"\nURI scheme.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"domain")," REQUIRED.\nThe domain that is requesting the signing.\nIts value MUST be a ",(0,i.kt)("a",{parentName:"p",href:"https://datatracker.ietf.org/doc/html/rfc3986"},"RFC 3986"),"\nauthority. The authority includes an OPTIONAL port.\nIf the port is not specified, the default\nport for the provided scheme is assumed."))),(0,i.kt)("p",null,"If scheme is not specified, HTTPS is assumed by default."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"address")," REQUIRED. The Ethereum address performing the signing.\nIts value SHOULD be conformant to mixed-case checksum address encoding\nspecified in ERC-55 where applicable.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"statement")," OPTIONAL. A human-readable ASCII assertion that the user\nwill sign which MUST NOT include '\\n' (the byte 0x0a).")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"uri")," REQUIRED. An\n",(0,i.kt)("a",{parentName:"p",href:"https://datatracker.ietf.org/doc/htmlrfc3986"},"RFC 3986"),"\nURI referring to the resource that is the subject of the\nsigning.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"version")," REQUIRED. The current version of the SIWE Message, which\nMUST be 1 for this specification.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"chain-id")," REQUIRED. The EIP-155 Chain ID to which the session is\nbound, and the network where Contract Accounts MUST be resolved.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"nonce")," REQUIRED. A random string (minimum 8 alphanumeric characters)\nchosen by the relying party and used to prevent replay attacks.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"issued-at")," REQUIRED. The time when the message was generated,\ntypically the current time."))),(0,i.kt)("p",null,"Its value MUST be an ISO 8601 datetime string."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"expiration-time")," OPTIONAL. The time when the signed authentication\nmessage is no longer valid.")),(0,i.kt)("p",null,"Its value MUST be an ISO 8601 datetime string."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"not-before")," OPTIONAL. The time when the signed authentication\nmessage will become valid.")),(0,i.kt)("p",null,"Its value MUST be an ISO 8601 datetime string."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"request-id")," OPTIONAL. An system-specific identifier that MAY be used\nto uniquely refer to the sign-in request.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"resources")," OPTIONAL. A list of information or references to\ninformation the user wishes to have resolved as part of authentication\nby the relying party."))),(0,i.kt)("p",null,'Every resource MUST be a RFC 3986 URI separated by "\\n- " where \\n is\nthe byte 0x0a.'),(0,i.kt)("h4",{id:"signing-and-verifying-messages-with-ethereum-accounts"},"Signing and Verifying Messages with Ethereum Accounts"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For Externally Owned Accounts, the verification method specified in\n",(0,i.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-191"},"ERC-191"),"\nMUST be used.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"For Contract Accounts,"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The verification method specified in\n",(0,i.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-1271"},"ERC-1271"),"\nSHOULD be used.\nOtherwise, the implementer MUST clearly define the\nverification method\nto attain security and interoperability for both\nwallets and relying parties.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"When performing ",(0,i.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-1271"},"ERC-1271"),"\nsignature verification, the contract performing the verification MUST\nbe resolved from the specified ",(0,i.kt)("inlineCode",{parentName:"p"},"chain-id"),".")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Implementers SHOULD take into consideration that [ERC-1271\n(",(0,i.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-1271"},"https://eips.ethereum.org/EIPS/eip-1271"),") implementations are not\nrequired to be pure functions.\nThey can return different results for the same inputs depending on\nblockchain state.\nThis can affect the security model and session validation rules."))))),(0,i.kt)("h4",{id:"resolving-ethereum-name-service-ens-data"},"Resolving Ethereum Name Service (ENS) Data"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The relying party or wallet MAY additionally perform resolution of\nENS data, as this can improve the user experience by displaying human\nfriendly information that is related to the ",(0,i.kt)("inlineCode",{parentName:"p"},"address"),".\nResolvable ENS data include:"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"The primary ENS name."),(0,i.kt)("li",{parentName:"ul"},"The ENS avatar."),(0,i.kt)("li",{parentName:"ul"},"Any other resolvable resources specified in the ENS documentation."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"If resolution of ENS data is performed, implementers SHOULD take\nprecautions to preserve user privacy and consent.\nTheir ",(0,i.kt)("inlineCode",{parentName:"p"},"address")," could be forwarded to third party services as part of\nthe resolution process."))),(0,i.kt)("h4",{id:"implementer-steps-specifying-the-request-origin"},"Implementer steps: specifying the request origin"),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"domain")," and, if present, the ",(0,i.kt)("inlineCode",{parentName:"p"},"scheme"),", in the SIWE Message MUST\ncorrespond to the origin from where the signing request was made."),(0,i.kt)("h4",{id:"implementer-steps-verifying-a-signed-message"},"Implementer steps: verifying a signed message"),(0,i.kt)("p",null,"The SIWE Message MUST be checked for conformance to the ABNF Message\nFormat and its signature MUST be checked as defined in Signing and\nVerifying Messages with Ethereum Accounts."),(0,i.kt)("h4",{id:"implementer-steps-creating-sessions"},"Implementer steps: creating sessions"),(0,i.kt)("p",null,"Sessions MUST be bound to the address and not to further resolved\nresources that can change."),(0,i.kt)("h4",{id:"implementer-steps-interpreting-and-resolving-resources"},"Implementer steps: interpreting and resolving resources"),(0,i.kt)("p",null,"Implementers SHOULD ensure that that URIs in the listed resources are\nhuman-friendly when expressed in plaintext form."),(0,i.kt)("h4",{id:"wallet-implementer-steps-verifying-the-message-format"},"Wallet implementer steps: verifying the message format"),(0,i.kt)("p",null,"The full SIWE message MUST be checked for conformance to the ABNF\ndefined in ABNF Message Format."),(0,i.kt)("p",null,"Wallet implementers SHOULD warn users if the substring ",(0,i.kt)("inlineCode",{parentName:"p"},'"wants you to\nsign in with your Ethereum account"')," appears anywhere in an [ERC-191\n(",(0,i.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-191"},"https://eips.ethereum.org/EIPS/eip-191"),") message signing request unless\nthe message fully conforms to the format defined ABNF Message Format."),(0,i.kt)("h4",{id:"wallet-implementer-steps-verifying-the-request-origin"},"Wallet implementer steps: verifying the request origin"),(0,i.kt)("p",null,"Wallet implementers MUST prevent phishing attacks by verifying the\norigin of the request against the ",(0,i.kt)("inlineCode",{parentName:"p"},"scheme")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"domain")," fields in the\nSIWE Message."),(0,i.kt)("p",null,"The origin SHOULD be read from a trusted data source such as the\nbrowser window or over WalletConnect\n",(0,i.kt)("a",{parentName:"p",href:"https://eips.ethereum.org/EIPS/eip-1328"},"ERC-1328")," sessions for\ncomparison against the\nsigning message contents."),(0,i.kt)("p",null,"Wallet implementers MAY warn instead of rejecting the verification if\nthe origin is pointing to localhost."),(0,i.kt)("p",null,"The following is a RECOMMENDED algorithm for Wallets to conform with\nthe requirements on request origin verification defined by this\nspecification."),(0,i.kt)("p",null,"The algorithm takes the following input variables:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"fields from the SIWE message."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"origin")," of the signing request: the origin of the page which\nrequested the signin via the provider."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"allowedSchemes"),": a list of schemes allowed by the Wallet."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"defaultScheme"),": a scheme to assume when none was provided. Wallet\nimplementers in the browser SHOULD use https."),(0,i.kt)("li",{parentName:"ul"},"developer mode indication: a setting deciding if certain risks should\nbe a warning instead of rejection. Can be manually configured or\nderived from ",(0,i.kt)("inlineCode",{parentName:"li"},"origin")," being localhost.")),(0,i.kt)("p",null,"The algorithm is described as follows:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"If ",(0,i.kt)("inlineCode",{parentName:"li"},"scheme")," was not provided, then assign ",(0,i.kt)("inlineCode",{parentName:"li"},"defaultScheme")," as scheme."),(0,i.kt)("li",{parentName:"ul"},"If ",(0,i.kt)("inlineCode",{parentName:"li"},"scheme")," is not contained in ",(0,i.kt)("inlineCode",{parentName:"li"},"allowedSchemes"),", then the ",(0,i.kt)("inlineCode",{parentName:"li"},"scheme"),"\nis not expected and the Wallet MUST reject the request.\nWallet implementers in the browser SHOULD limit the list of\nallowedSchemes to just 'https' unless a developer mode is activated."),(0,i.kt)("li",{parentName:"ul"},"If ",(0,i.kt)("inlineCode",{parentName:"li"},"scheme")," does not match the scheme of origin, the Wallet SHOULD\nreject the request.\nWallet implementers MAY show a warning instead of rejecting the request\nif a developer mode is activated.\nIn that case the Wallet continues processing the request."),(0,i.kt)("li",{parentName:"ul"},"If the ",(0,i.kt)("inlineCode",{parentName:"li"},"host")," part of the ",(0,i.kt)("inlineCode",{parentName:"li"},"domain")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"origin")," do not match, the\nWallet MUST reject the request unless the Wallet is in developer mode.\nIn developer mode the Wallet MAY show a warning instead and continues\nprocesing the request."),(0,i.kt)("li",{parentName:"ul"},"If ",(0,i.kt)("inlineCode",{parentName:"li"},"domain")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"origin")," have mismatching subdomains, the Wallet\nSHOULD reject the request unless the Wallet is in developer mode.\nIn developer mode the Wallet MAY show a warning instead and continues\nprocesing the request."),(0,i.kt)("li",{parentName:"ul"},"Let ",(0,i.kt)("inlineCode",{parentName:"li"},"port")," be the port component of ",(0,i.kt)("inlineCode",{parentName:"li"},"domain"),", and if no port is\ncontained in domain, assign port the default port specified for the\nscheme."),(0,i.kt)("li",{parentName:"ul"},"If ",(0,i.kt)("inlineCode",{parentName:"li"},"port")," is not empty, then the Wallet SHOULD show a warning if the\n",(0,i.kt)("inlineCode",{parentName:"li"},"port")," does not match the port of ",(0,i.kt)("inlineCode",{parentName:"li"},"origin"),"."),(0,i.kt)("li",{parentName:"ul"},"If ",(0,i.kt)("inlineCode",{parentName:"li"},"port")," is empty, then the Wallet MAY show a warning if ",(0,i.kt)("inlineCode",{parentName:"li"},"origin"),"\ncontains a specific port."),(0,i.kt)("li",{parentName:"ul"},"Return request origin verification completed.")),(0,i.kt)("h4",{id:"wallet-implementer-steps-creating-siwe-interfaces"},"Wallet implementer steps: creating SIWE interfaces"),(0,i.kt)("p",null,"Wallet implementers MUST display to the user the following fields from\nthe SIWE Message request by default and prior to signing, if they are\npresent: ",(0,i.kt)("inlineCode",{parentName:"p"},"scheme"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"domain"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"address"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"statement"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"resources"),".\nOther present fields MUST also be made available to the user prior to\nsigning either by default or through an extended interface."),(0,i.kt)("p",null,"Wallet implementers displaying a plaintext SIWE Message to the user\nSHOULD require the user to scroll to the bottom of the text area prior\nto signing."),(0,i.kt)("p",null,"Wallet implementers MAY construct a custom SIWE user interface by\nparsing the ABNF terms into data elements for use in the interface.\nThe display rules above still apply to custom interfaces."),(0,i.kt)("h4",{id:"wallet-implementer-steps-supporting-internationalization-i18n"},"Wallet implementer steps: supporting internationalization (i18n)"),(0,i.kt)("p",null,"After successfully parsing the message into ABNF terms, translation MAY\nhappen at the UX level per human language."),(0,i.kt)("h2",{id:"privacy-and-security-considerations"},"Privacy and Security Considerations"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},'The double ratchet "recommends" using AES in CBC mode. Since\nencryption must be with an AEAD encryption scheme, we will use AES in\nGCM mode instead (supported by Noise).'),(0,i.kt)("li",{parentName:"ul"},"For the information retrieval, the algorithm MUST include a access\ncontrol mechanisms to restrict who can call the set and get functions."),(0,i.kt)("li",{parentName:"ul"},"One SHOULD include event logs to track changes in public keys."),(0,i.kt)("li",{parentName:"ul"},"The curve vurve448 MUST be chosen due to its higher security level:\n224-bit security instead of the 128-bit security provided by X25519."),(0,i.kt)("li",{parentName:"ul"},"It is important that Bob MUST NOT reuse ",(0,i.kt)("inlineCode",{parentName:"li"},"SPK"),".")),(0,i.kt)("h2",{id:"considerations-related-to-the-use-of-ethereum-addresses"},"Considerations related to the use of Ethereum addresses"),(0,i.kt)("h3",{id:"with-respect-to-the-authentication-service"},"With respect to the Authentication Service"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"If users used their Ethereum addresses as identifiers, they MUST\ngenerate their own credentials.\nThese credentials MUST use the digital signature key pair associated to\nthe Ethereum address."),(0,i.kt)("li",{parentName:"ul"},"Other users can verify credentials."),(0,i.kt)("li",{parentName:"ul"},"With this approach, there is no need to have a dedicated\nAuthentication Service responsible for the issuance and verification of\ncredentials."),(0,i.kt)("li",{parentName:"ul"},"The interaction diagram showing the generation of credentials becomes\nobsolete.")),(0,i.kt)("h3",{id:"with-respect-to-the-delivery-service"},"With respect to the Delivery Service"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Users MUST generate their own KeyPackage."),(0,i.kt)("li",{parentName:"ul"},"Other users can verify KeyPackages when required."),(0,i.kt)("li",{parentName:"ul"},"A Delivery Service storage system MUST verify KeyPackages before\nstoring them."),(0,i.kt)("li",{parentName:"ul"},"Interaction diagrams involving the DS do not change.")),(0,i.kt)("h2",{id:"consideration-related-to-the-onchain-component-of-the-protocol"},"Consideration related to the onchain component of the protocol"),(0,i.kt)("h3",{id:"assumptions"},"Assumptions"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Users have set a secure 1-1 communication channel."),(0,i.kt)("li",{parentName:"ul"},"Each group is managed by a separate smart contract.")),(0,i.kt)("h3",{id:"addition-of-members-to-a-group"},"Addition of members to a group"),(0,i.kt)("h4",{id:"alice-knows-bobs-ethereum-address"},"Alice knows Bob\u2019s Ethereum address"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Off-chain - Alice and Bob set a secure communication channel."),(0,i.kt)("li",{parentName:"ol"},"Alice creates the smart contract associated to the group. This smart\ncontract MUST include an ACL."),(0,i.kt)("li",{parentName:"ol"},"Alice adds Bob\u2019s Ethereum address to the ACL."),(0,i.kt)("li",{parentName:"ol"},"Off-chain - Alice sends a request to join the group to Bob. The\nrequest MUST include the contract\u2019s address: ",(0,i.kt)("inlineCode",{parentName:"li"},'RequestMLSPayload {"You\nare joining the group with smart contract: 0xabcd"}')),(0,i.kt)("li",{parentName:"ol"},"Off-chain - Bob responds the request with a digitally signed\nresponse. This response includes Bob\u2019s credentials and key package:\n",(0,i.kt)("inlineCode",{parentName:"li"},"ResponseMLSPayload {sig: signature(ethereum_sk, message_to_sign),\naddress: ethereum_address, credentials, keypackage}")),(0,i.kt)("li",{parentName:"ol"},"Off-chain - Alice verifies the signature, using Bob\u2019s ",(0,i.kt)("inlineCode",{parentName:"li"},"ethereum_pk"),"\nand checks that it corresponds to an address contained in the ACL."),(0,i.kt)("li",{parentName:"ol"},"Off-chain - Alice sends a welcome message to Bob."),(0,i.kt)("li",{parentName:"ol"},"Off-chain - Alice SHOULD broadcasts a message announcing the\naddition of Bob to other users of the group.\n",(0,i.kt)("img",{alt:"figure7",src:n(76884).Z,width:"649",height:"928"}))),(0,i.kt)("h4",{id:"alice-does-not-know-bobs-ethereum-address"},"Alice does not know Bob\u2019s Ethereum address"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Off-chain - Alice and Bob set a secure communication channel."),(0,i.kt)("li",{parentName:"ol"},"Alice creates the smart contract associated to the group.\nThis smart contract MUST include an ACL."),(0,i.kt)("li",{parentName:"ol"},"Off-chain - Alice sends a request to join the group to Bob. The\nrequest MUST include the contract\u2019s address:\n",(0,i.kt)("inlineCode",{parentName:"li"},'RequestMLSPayload{"You are joining the group\nwith smart contract: 0xabcd"}')),(0,i.kt)("li",{parentName:"ol"},"Off-chain - Bob responds the request with a digitally signed\nresponse. This response includes Bob\u2019s credentials, his Ethereum\naddress and key package: ",(0,i.kt)("inlineCode",{parentName:"li"},"ResponseMLSPayload {sig:\nsignature(ethereum_sk, message_to_sign), address: ethereum_address,\ncredentials, keypackage}")),(0,i.kt)("li",{parentName:"ol"},"Off-chain - Alice verifies the signature using Bob\u2019s ",(0,i.kt)("inlineCode",{parentName:"li"},"ethereum_pk"),"."),(0,i.kt)("li",{parentName:"ol"},"Upon reception of Bob\u2019s data, Alice registers data with the smart\ncontract."),(0,i.kt)("li",{parentName:"ol"},"Off-chain - Alice sends a welcome message to Bob."),(0,i.kt)("li",{parentName:"ol"},"Off-chain - Alice SHOULD broadcasts a message announcing the\naddition of Bob to other users of the group.")),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"figure8",src:n(93372).Z,width:"649",height:"928"})),(0,i.kt)("h3",{id:"considerations-regarding-smart-contracts"},"Considerations regarding smart contracts"),(0,i.kt)("p",null,"The role of the smart contract includes:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Register user information and key packages:\nAs described in the previous section."),(0,i.kt)("li",{parentName:"ul"},"Updates of key material.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Users MUST send any update in their key material to the other\nusers of the group via off-chain messages."),(0,i.kt)("li",{parentName:"ul"},"Upon reception of the new key material, the creator of the\ncontract MUST update the state of the smart contract."))),(0,i.kt)("li",{parentName:"ul"},"Deletion of users.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Any user can submit a proposal for the removal of a user via\noff-chain message."),(0,i.kt)("li",{parentName:"ul"},"This proposal MUST be sent to the creator of the contract."),(0,i.kt)("li",{parentName:"ul"},"The creator of the contract MUST update the ACL, and send\nmessages to the group for key update.")))),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"figure9",src:n(20690).Z,width:"654",height:"632"})),(0,i.kt)("p",null,">"," It is important to note that both\nuser removal and updates of any kind\nhave a similar interaction flow."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Queries of existing users.",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Any user can query the smart contract to know the state of the\ngroup, including existing users and removed ones."),(0,i.kt)("li",{parentName:"ul"},"This aspect MUST be used when adding new members to verify that\nthe prospective key package has not been already used.")))),(0,i.kt)("h2",{id:"copyright"},"Copyright"),(0,i.kt)("p",null,"Copyright and related rights waived via ",(0,i.kt)("a",{parentName:"p",href:"https://creativecommons.org/publicdomain/zero/1.0/"},"CC0"),"."),(0,i.kt)("h2",{id:"references"},"References"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://datatracker.ietf.org/doc/html/rfc5234"},"Augmented BNF for Syntax Specifications")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/libp2p/specs/tree/master/pubsub/gossipsub"},"Gossipsub")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://www.ietf.org/rfc/rfc5869.txt"},"HMAC-based Extract-and-Expand Key Derivation Function")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://datatracker.ietf.org/doc/rfc9180/"},"Hybrid Public Key Encryption")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://eprint.iacr.org/2019/1189.pdf"},"Security Analysis and Improvements for the IETF MLS Standard for Group Messaging")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://eips.ethereum.org/EIPS/eip-191"},"Signed Data Standard")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://eips.ethereum.org/EIPS/eip-4361"},"Sign-In with Ethereum")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://eips.ethereum.org/EIPS/eip-1271"},"Standard Signature Validation Method for Contracts")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://signal.org/docs/specifications/doubleratchet/"},"The Double Ratchet Algorithm")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://datatracker.ietf.org/doc/rfc9420/"},"The Messaging Layer Security Protocol")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://signal.org/docs/specifications/x3dh/"},"The X3DH Key Agreement Protocol")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://rfc.vac.dev/spec/20/"},"Toy Ethereum Private Messaging Protocol")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://datatracker.ietf.org/doc/html/rfc3986"},"Uniform Resource Identifier")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://eips.ethereum.org/EIPS/eip-1328"},"WalletConnect URI Format"))))}d.isMDXComponent=!0},3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>u});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},h=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),h=p(n),u=i,m=h["".concat(l,".").concat(u)]||h[u]||d[u]||r;return n?a.createElement(m,o(o({ref:t},c),{},{components:n})):a.createElement(m,o({ref:t},c))}));function u(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var p=2;p<r;p++)o[p]=n[p];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}h.displayName="MDXCreateElement"},16138:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/eth-secpm_add-7a67a0d211cabceae702f2fe6a6bf778.png"},25475:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/eth-secpm_creation-e9f4d0d596ddd6c261508db853dd9b52.png"},83684:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/eth-secpm_credential-ba3397173859f28e7269577e6258d18d.png"},38669:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/eth-secpm_fetching-565512a6395769350b2c5b1274b3f69c.png"},76884:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/eth-secpm_onchain-register-1-1ad2249cf2cb224d92fade649eb09efb.png"},93372:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/eth-secpm_onchain-register-2-ba304aeb2ae734c0a7016e87c3fc1ad8.png"},20690:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/eth-secpm_onchain-update-091a5510c2f7948003bfc0bf49298f0a.png"},75133:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/eth-secpm_remove-05ff9ff9fe9a3c5b675343752e708dd4.png"},2501:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/images/eth-secpm_update-5a67b9c8b3debf48af8380a9e4172540.png"}}]);