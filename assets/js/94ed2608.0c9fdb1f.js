"use strict";(self.webpackChunklogos_docs_template=self.webpackChunklogos_docs_template||[]).push([[8409],{64782:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>m,frontMatter:()=>r,metadata:()=>o,toc:()=>p});var i=n(87462),a=(n(67294),n(3905));const r={title:"32/RLN-V1",name:"Rate Limit Nullifier",status:"draft",editor:"Aaryamann Challani &lt;p1ge0nh8er@proton.me&gt;",contributors:["Barry Whitehat &lt;barrywhitehat@protonmail.com&gt;","Sanaz Taheri &lt;sanaz@status.im&gt;","Oskar Thor\xe9n &lt;oskarth@titanproxy.com&gt;","Onur Kilic &lt;onurkilic1004@gmail.com&gt;","Blagoj Dimovski &lt;blagoj.dimovski@yandex.com&gt;","Rasul Ibragimov &lt;curryrasul@gmail.com&gt;"]},l=void 0,o={unversionedId:"32/rln-v1",id:"32/rln-v1",title:"32/RLN-V1",description:"- Status: draft",source:"@site/vac/32/rln-v1.md",sourceDirName:"32",slug:"/32/rln-v1",permalink:"/vac/32/rln-v1",draft:!1,tags:[],version:"current",frontMatter:{title:"32/RLN-V1",name:"Rate Limit Nullifier",status:"draft",editor:"Aaryamann Challani &lt;p1ge0nh8er@proton.me&gt;",contributors:["Barry Whitehat &lt;barrywhitehat@protonmail.com&gt;","Sanaz Taheri &lt;sanaz@status.im&gt;","Oskar Thor\xe9n &lt;oskarth@titanproxy.com&gt;","Onur Kilic &lt;onurkilic1004@gmail.com&gt;","Blagoj Dimovski &lt;blagoj.dimovski@yandex.com&gt;","Rasul Ibragimov &lt;curryrasul@gmail.com&gt;"]},sidebar:"defaultSidebar",previous:{title:"25/LIBP2P-DNS-DISCOVERY",permalink:"/vac/25/libp2p-dns-discovery"},next:{title:"XX/(WAKU2|LOGOS|CODEX|*)-TEMPLATE",permalink:"/vac/template"}},s={},p=[{value:"Abstract",id:"abstract",level:2},{value:"Motivation",id:"motivation",level:2},{value:"Wire Format Specification",id:"wire-format-specification",level:2},{value:"Flow",id:"flow",level:3},{value:"Registration",id:"registration",level:3},{value:"Implementation notes",id:"implementation-notes",level:4},{value:"User identity",id:"user-identity",level:5},{value:"Signaling",id:"signaling",level:3},{value:"Implementation Notes",id:"implementation-notes-1",level:4},{value:"Signal hash",id:"signal-hash",level:5},{value:"External nullifier",id:"external-nullifier",level:5},{value:"Obtaining Merkle proof",id:"obtaining-merkle-proof",level:5},{value:"Generating proof",id:"generating-proof",level:5},{value:"Calculating output",id:"calculating-output",level:5},{value:"Sending the output message",id:"sending-the-output-message",level:5},{value:"Verification and slashing",id:"verification-and-slashing",level:3},{value:"Notes from Implementation",id:"notes-from-implementation",level:4},{value:"Verification",id:"verification",level:5},{value:"Slashing",id:"slashing",level:5},{value:"Technical overview",id:"technical-overview",level:3},{value:"Terminology",id:"terminology",level:4},{value:"RLN Zero-Knowledge Circuit specific terms",id:"rln-zero-knowledge-circuit-specific-terms",level:4},{value:"Zero-Knowledge Circuits specification",id:"zero-knowledge-circuits-specification",level:4},{value:"System parameters",id:"system-parameters",level:5},{value:"Circuit parameters",id:"circuit-parameters",level:5},{value:"Public Inputs",id:"public-inputs",level:6},{value:"Private Inputs",id:"private-inputs",level:6},{value:"Outputs",id:"outputs",level:6},{value:"Hash function",id:"hash-function",level:5},{value:"Membership implementation",id:"membership-implementation",level:5},{value:"Slashing and Shamir&#39;s Secret Sharing",id:"slashing-and-shamirs-secret-sharing",level:4},{value:"Identity credentials generation",id:"identity-credentials-generation",level:4},{value:"<code>identity_secret</code>",id:"identity_secret",level:5},{value:"<code>identity_secret_hash</code>",id:"identity_secret_hash",level:5},{value:"<code>identity_commitment</code>",id:"identity_commitment",level:5},{value:"Appendix A: Security Considerations",id:"appendix-a-security-considerations",level:3},{value:"SSS Security Assumptions",id:"sss-security-assumptions",level:4},{value:"Appendix B: Identity Scheme Choice",id:"appendix-b-identity-scheme-choice",level:3},{value:"Appendix C: Auxiliary Tooling",id:"appendix-c-auxiliary-tooling",level:3},{value:"Appendix D: Example Usage",id:"appendix-d-example-usage",level:3},{value:"Creating a RLN Object",id:"creating-a-rln-object",level:4},{value:"Generating Identity Credentials",id:"generating-identity-credentials",level:4},{value:"Adding ID Commitment to the RLN Merkle Tree",id:"adding-id-commitment-to-the-rln-merkle-tree",level:4},{value:"Setting Epoch and Signal",id:"setting-epoch-and-signal",level:4},{value:"Generating Proof",id:"generating-proof-1",level:4},{value:"Verifiying Proof",id:"verifiying-proof",level:4},{value:"Copyright",id:"copyright",level:2},{value:"References",id:"references",level:2},{value:"Informative",id:"informative",level:3}],d={toc:p};function m(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Status: draft"),(0,a.kt)("li",{parentName:"ul"},"Editor: Aaryamann Challani ","<",(0,a.kt)("a",{parentName:"li",href:"mailto:p1ge0nh8er@proton.me"},"p1ge0nh8er@proton.me"),">"),(0,a.kt)("li",{parentName:"ul"},"Contributors:",(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},"Barry Whitehat ","<",(0,a.kt)("a",{parentName:"li",href:"mailto:barrywhitehat@protonmail.com"},"barrywhitehat@protonmail.com"),">"),(0,a.kt)("li",{parentName:"ul"},"Sanaz Taheri ","<",(0,a.kt)("a",{parentName:"li",href:"mailto:sanaz@status.im"},"sanaz@status.im"),">"),(0,a.kt)("li",{parentName:"ul"},"Oskar Thor\xe9n ","<",(0,a.kt)("a",{parentName:"li",href:"mailto:oskarth@titanproxy.com"},"oskarth@titanproxy.com"),">"),(0,a.kt)("li",{parentName:"ul"},"Onur Kilic ","<",(0,a.kt)("a",{parentName:"li",href:"mailto:onurkilic1004@gmail.com"},"onurkilic1004@gmail.com"),">"),(0,a.kt)("li",{parentName:"ul"},"Blagoj Dimovski ","<",(0,a.kt)("a",{parentName:"li",href:"mailto:blagoj.dimovski@yandex.com"},"blagoj.dimovski@yandex.com"),">"),(0,a.kt)("li",{parentName:"ul"},"Rasul Ibragimov ","<",(0,a.kt)("a",{parentName:"li",href:"mailto:curryrasul@gmail.com"},"curryrasul@gmail.com"),">")))),(0,a.kt)("h2",{id:"abstract"},"Abstract"),(0,a.kt)("p",null,"The following specification covers the RLN construct\nas well as some auxiliary libraries useful for interacting with it.\nRate limiting nullifier (RLN) is a construct based on zero-knowledge proofs that\nprovides an anonymous rate-limited signaling/messaging framework\nsuitable for decentralized (and centralized) environments.\nAnonymity refers to the unlinkability of messages to their owner."),(0,a.kt)("h2",{id:"motivation"},"Motivation"),(0,a.kt)("p",null,"RLN guarantees a messaging rate is enforced cryptographically\nwhile preserving the anonymity of the message owners.\nA wide range of applications can benefit from RLN and\nprovide desirable security features.\nFor example,\nan e-voting system can integrate RLN to contain the voting rate while\nprotecting the voters-vote unlinkability.\nAnother use case is to protect an anonymous messaging system against DDoS and\nspam attacks by constraining messaging rate of users.\nThis latter use case is explained in ",(0,a.kt)("a",{parentName:"p",href:"../../waku/standards/core/17/rln-relay"},"17/WAKU2-RLN-RELAY RFC"),"."),(0,a.kt)("h2",{id:"wire-format-specification"},"Wire Format Specification"),(0,a.kt)("p",null,"The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d,\n\u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and\n\u201cOPTIONAL\u201d in this document are to be interpreted as described in ",(0,a.kt)("a",{parentName:"p",href:"https://www.ietf.org/rfc/rfc2119.txt"},"2119"),"."),(0,a.kt)("h3",{id:"flow"},"Flow"),(0,a.kt)("p",null,"The users participate in the protocol by\nfirst registering to an application-defined group referred by the ",(0,a.kt)("em",{parentName:"p"},"membership group"),".\nRegistration to the group is mandatory for signaling in the application.\nAfter registration, group members can generate a zero-knowledge proof of membership\nfor their signals and can participate in the application.\nUsually, the membership requires a financial or\nsocial stake which is beneficial for the prevention\nof inclusion of Sybils within the ",(0,a.kt)("em",{parentName:"p"},"membership group"),".\nGroup members are allowed to send one signal per external nullifier\n(an identifier that groups signals and can be thought of as a voting booth).\nIf a user generates more signals than allowed,\nthe user risks being slashed - by revealing his membership secret credentials.\nIf the financial stake is put in place, the user also risks his stake being taken."),(0,a.kt)("p",null,"Generally the flow can be described by the following steps:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"Registration"),(0,a.kt)("li",{parentName:"ol"},"Signaling"),(0,a.kt)("li",{parentName:"ol"},"Verification and slashing")),(0,a.kt)("h3",{id:"registration"},"Registration"),(0,a.kt)("p",null,"Depending on the application requirements,\nthe registration can be implemented in different ways, for example:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"centralized registrations, by using a central server"),(0,a.kt)("li",{parentName:"ul"},"decentralized registrations, by using a smart contract")),(0,a.kt)("p",null,"The users' identity commitments\n(explained in section ",(0,a.kt)("a",{parentName:"p",href:"#user-identity"},"User Identity"),") are stored in a Merkle tree,\nand the users can obtain a Merkle proof proving that they are part of the group."),(0,a.kt)("p",null,"Also depending on the application requirements,\nusually a financial or social stake is introduced.\nAn example for financial stake is:"),(0,a.kt)("p",null,"For each registration a certain amount of ETH is required.\nAn example for social stake is using ",(0,a.kt)("a",{parentName:"p",href:"https://interep.link/"},"Interep")," as a registry,\nusers need to prove that they have a highly reputable social media account."),(0,a.kt)("h4",{id:"implementation-notes"},"Implementation notes"),(0,a.kt)("h5",{id:"user-identity"},"User identity"),(0,a.kt)("p",null,"The user's identity is composed of:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"{\n    identity_secret: [identity_nullifier, identity_trapdoor],\n    identity_secret_hash: poseidonHash(identity_secret),\n    identity_commitment: poseidonHash([identity_secret_hash])\n}\n\n")),(0,a.kt)("p",null,"For registration, the user MUST submit their ",(0,a.kt)("inlineCode",{parentName:"p"},"identity_commitment"),"\n(along with any additional registration requirements) to the registry.\nUpon registration, they SHOULD receive ",(0,a.kt)("inlineCode",{parentName:"p"},"leaf_index")," value\nwhich represents their position in the Merkle tree.\nReceiving a ",(0,a.kt)("inlineCode",{parentName:"p"},"leaf_index")," is not a hard requirement and is application specific.\nThe other way around is\nthe users calculating the ",(0,a.kt)("inlineCode",{parentName:"p"},"leaf_index")," themselves upon successful registration."),(0,a.kt)("h3",{id:"signaling"},"Signaling"),(0,a.kt)("p",null,"After registration,\nthe users can participate in the application by\nsending signals to the other participants in a decentralised manner or\nto a centralised server.\nAlong with their signal,\nthey MUST generate a zero-knowledge proof by\nusing the circuit with the specification described above."),(0,a.kt)("p",null,"For generating a proof,\nthe users need to obtain the required parameters or compute them themselves,\ndepending on the application implementation and\nclient libraries supported by the application.\nFor example,\nthe users MAY store the membership Merkle tree on their end and\ngenerate a Merkle proof whenever they want to generate a signal."),(0,a.kt)("h4",{id:"implementation-notes-1"},"Implementation Notes"),(0,a.kt)("h5",{id:"signal-hash"},"Signal hash"),(0,a.kt)("p",null,"The signal hash can be generated by hashing the raw signal (or content)\nusing the ",(0,a.kt)("inlineCode",{parentName:"p"},"keccak256")," hash function."),(0,a.kt)("h5",{id:"external-nullifier"},"External nullifier"),(0,a.kt)("p",null,"The external nullifier MUST be computed as the Poseidon hash of the current epoch\n(e.g. a value equal to or\nderived from the current UNIX timestamp divided by the epoch length)\nand the RLN identifier."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"\nexternal_nullifier = poseidonHash([epoch, rln_identifier]);\n\n")),(0,a.kt)("h5",{id:"obtaining-merkle-proof"},"Obtaining Merkle proof"),(0,a.kt)("p",null,"The Merkle proof SHOULD be obtained locally or from a trusted third party.\nBy using the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/appliedzkp/incrementalquintree/blob/master/ts/IncrementalQuinTree.ts"},"incremental Merkle tree algorithm"),",\nthe Merkle can be obtained by providing the ",(0,a.kt)("inlineCode",{parentName:"p"},"leaf_index")," of the ",(0,a.kt)("inlineCode",{parentName:"p"},"identity_commitment"),".\nThe proof (",(0,a.kt)("inlineCode",{parentName:"p"},"Merkle_proof"),") is composed of the following fields:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"\n{\n    root: bigint,\n    indices: number[],\n    path_elements: bigint[][]\n}\n\n")),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"root")," - The root of membership group Merkle tree\nat the time of publishing the message"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"indices")," - The index fields of the leafs in the Merkle tree -\nused by the Merkle tree algorithm for verification"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"path_elements")," - Auxiliary data structure used for storing the path\nto the leaf - used by the Merkle proof algorithm for verificaton")),(0,a.kt)("h5",{id:"generating-proof"},"Generating proof"),(0,a.kt)("p",null,"For proof generation,\nthe user MUST submit the following fields to the circuit:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"\n{\n    identity_secret: identity_secret_hash,\n    path_elements: Merkle_proof.path_elements,\n    identity_path_index: Merkle_proof.indices,\n    x: signal_hash,\n    external_nullifier: external_nullifier\n}\n\n")),(0,a.kt)("h5",{id:"calculating-output"},"Calculating output"),(0,a.kt)("p",null,"The proof output is calculated locally,\nin order for the required fields for proof verification\nto be sent along with the proof.\nThe proof output is composed of the ",(0,a.kt)("inlineCode",{parentName:"p"},"y")," share of the secret equation and the ",(0,a.kt)("inlineCode",{parentName:"p"},"internal_nullifier"),".\nThe ",(0,a.kt)("inlineCode",{parentName:"p"},"internal_nullifier")," represents a unique fingerprint of a user\nfor a given ",(0,a.kt)("inlineCode",{parentName:"p"},"epoch")," and app.\nThe following fields are needed for proof output calculation:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"{\n    identity_secret_hash: bigint, \n    external_nullifier: bigint,\n    x: bigint\n}\n\n")),(0,a.kt)("p",null,"The output ",(0,a.kt)("inlineCode",{parentName:"p"},"[y, internal_nullifier]")," is calculated in the following way:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"\na_0 = identity_secret_hash;\na_1 = poseidonHash([a0, external_nullifier]);\n\ny = a_0 + x * a_1;\n\ninternal_nullifier = poseidonHash([a_1]);\n\n")),(0,a.kt)("p",null,"It relies on the properties of the ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing"},"Shamir's Secret sharing scheme"),"."),(0,a.kt)("h5",{id:"sending-the-output-message"},"Sending the output message"),(0,a.kt)("p",null,"The user's output message (",(0,a.kt)("inlineCode",{parentName:"p"},"output_message"),"),\ncontaining the signal SHOULD contain the following fields at minimum:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"\n{\n    signal: signal, # non-hashed signal,\n    proof: zk_proof,\n    internal_nullifier: internal_nullifier,\n    x: x, # signal_hash,\n    y: y,\n    rln_identifier: rln_identifier\n}\n\n")),(0,a.kt)("p",null,"Additionally depending on the application,\nthe following fields MAY be required:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"\n{\n    root: Merkle_proof.root,\n    epoch: epoch\n}\n\n")),(0,a.kt)("h3",{id:"verification-and-slashing"},"Verification and slashing"),(0,a.kt)("p",null,"The slashing implementation is dependent on the type of application.\nIf the application is implemented in a centralised manner,\nand everything is stored on a single server,\nthe slashing will be implemented only on the server.\nOtherwise if the application is distributed,\nthe slashing will be implemented on each user's client."),(0,a.kt)("h4",{id:"notes-from-implementation"},"Notes from Implementation"),(0,a.kt)("p",null,"Each user of the protocol\n(server or otherwise) MUST store metadata for each message received by each user,\nfor the given ",(0,a.kt)("inlineCode",{parentName:"p"},"epoch"),".\nThe data can be deleted when the ",(0,a.kt)("inlineCode",{parentName:"p"},"epoch")," passes.\nStoring metadata is REQUIRED,\nso that if a user sends more than one unique signal per ",(0,a.kt)("inlineCode",{parentName:"p"},"epoch"),",\nthey can be slashed and removed from the protocol.\nThe metadata stored contains the ",(0,a.kt)("inlineCode",{parentName:"p"},"x"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"y")," shares and\nthe ",(0,a.kt)("inlineCode",{parentName:"p"},"internal_nullifier")," for the user for each message.\nIf enough such shares are present, the user's secret can be retreived."),(0,a.kt)("p",null,"One way of storing received metadata (",(0,a.kt)("inlineCode",{parentName:"p"},"messaging_metadata"),") is the following format:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"\n{\n    [external_nullifier]: {\n        [internal_nullifier]: {\n            x_shares: [],\n            y_shares: []\n        }\n    }\n}\n\n")),(0,a.kt)("h5",{id:"verification"},"Verification"),(0,a.kt)("p",null,"The output message verification consists of the following steps:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"external_nullifier")," correctness"),(0,a.kt)("li",{parentName:"ul"},"non-duplicate message check"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"zk_proof")," zero-knowledge proof verification"),(0,a.kt)("li",{parentName:"ul"},"spam verification")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"1. ",(0,a.kt)("inlineCode",{parentName:"strong"},"external_nullifier")," correctness"),"\nUpon received ",(0,a.kt)("inlineCode",{parentName:"p"},"output_message"),",\nfirst the ",(0,a.kt)("inlineCode",{parentName:"p"},"epoch")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"rln_identifier")," fields are checked,\nto ensure that the message matches the current ",(0,a.kt)("inlineCode",{parentName:"p"},"external_nullifier"),".\nIf the ",(0,a.kt)("inlineCode",{parentName:"p"},"external_nullifier")," is correct the verification continues, otherwise,\nthe message is discarded."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"2. non-duplicate message check"),"\nThe received message is checked to ensure it is not duplicate.\nThe duplicate message check is performed by verifying that the ",(0,a.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"y"),"\nfields do not exist in the ",(0,a.kt)("inlineCode",{parentName:"p"},"messaging_metadata")," object.\nIf the ",(0,a.kt)("inlineCode",{parentName:"p"},"x")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"y")," fields exist in the ",(0,a.kt)("inlineCode",{parentName:"p"},"x_shares")," and\n",(0,a.kt)("inlineCode",{parentName:"p"},"y_shares")," array for the ",(0,a.kt)("inlineCode",{parentName:"p"},"external_nullifier")," and\nthe ",(0,a.kt)("inlineCode",{parentName:"p"},"internal_nullifier")," the message can be considered as a duplicate.\nDuplicate messages are discarded."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"3. ",(0,a.kt)("inlineCode",{parentName:"strong"},"zk_proof")," verification")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"zk_proof")," SHOULD be verified by providing the ",(0,a.kt)("inlineCode",{parentName:"p"},"zk_proof")," field\nto the circuit verifier along with the ",(0,a.kt)("inlineCode",{parentName:"p"},"public_signal"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"\n[\n    y,\n    Merkle_proof.root,\n    internal_nullifier,\n    x, # signal_hash\n    external_nullifier\n]\n\n")),(0,a.kt)("p",null,"If the proof verification is correct,\nthe verification continues, otherwise the message is discarded."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"4. Double signaling verification"),"\nAfter the proof is verified the ",(0,a.kt)("inlineCode",{parentName:"p"},"x"),", and\n",(0,a.kt)("inlineCode",{parentName:"p"},"y")," fields are added to the ",(0,a.kt)("inlineCode",{parentName:"p"},"x_shares")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"y_shares"),"\narrays of the ",(0,a.kt)("inlineCode",{parentName:"p"},"messaging_metadata")," ",(0,a.kt)("inlineCode",{parentName:"p"},"external_nullifier")," and\n",(0,a.kt)("inlineCode",{parentName:"p"},"internal_nullifier")," object.\nIf the length of the arrays is equal to the signaling threshold (",(0,a.kt)("inlineCode",{parentName:"p"},"limit"),"),\nthe user can be slashed."),(0,a.kt)("h5",{id:"slashing"},"Slashing"),(0,a.kt)("p",null,"After the verification,\nthe user SHOULD be slashed if two different shares are present\nto reconstruct their ",(0,a.kt)("inlineCode",{parentName:"p"},"identity_secret_hash")," from ",(0,a.kt)("inlineCode",{parentName:"p"},"x_shares")," and\n",(0,a.kt)("inlineCode",{parentName:"p"},"y_shares")," fields, for their ",(0,a.kt)("inlineCode",{parentName:"p"},"internal_nullifier"),".\nThe secret can be retreived by the properties of the Shamir's secret sharing scheme.\nIn particular the secret (",(0,a.kt)("inlineCode",{parentName:"p"},"a_0"),") can be retrieved by computing ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Lagrange_polynomial"},"Lagrange polynomials"),"."),(0,a.kt)("p",null,"After the secret is retreived,\nthe user's ",(0,a.kt)("inlineCode",{parentName:"p"},"identity_commitment")," SHOULD be generated from the secret and\nit can be used for removing the user from the membership Merkle tree\n(zeroing out the leaf that contains the user's ",(0,a.kt)("inlineCode",{parentName:"p"},"identity_commitment"),").\nAdditionally, depending on the application the ",(0,a.kt)("inlineCode",{parentName:"p"},"identity_secret_hash"),"\nMAY be used for taking the user's provided stake."),(0,a.kt)("h3",{id:"technical-overview"},"Technical overview"),(0,a.kt)("p",null,"The main RLN construct is implemented using a\n",(0,a.kt)("a",{parentName:"p",href:"https://z.cash/technology/zksnarks/"},"ZK-SNARK")," circuit.\nHowever, it is helpful to describe\nthe other necessary outside components for interaction with the circuit,\nwhich together with the ZK-SNARK circuit enable the above mentioned features."),(0,a.kt)("h4",{id:"terminology"},"Terminology"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Term"),(0,a.kt)("th",{parentName:"tr",align:null},"Description"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("strong",{parentName:"td"},"ZK-SNARK")),(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("a",{parentName:"td",href:"https://z.cash/technology/zksnarks/"},"zksnarks"))),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("strong",{parentName:"td"},"Stake")),(0,a.kt)("td",{parentName:"tr",align:null},"Financial or social stake required for registering in the RLN applications.  Common stake examples are: locking cryptocurrency (financial), linking reputable social identity.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("strong",{parentName:"td"},"Identity secret")),(0,a.kt)("td",{parentName:"tr",align:null},"An array of two unique random components (identity nullifier and identity trapdoor), which must be kept private by the user. Secret hash and identity commitment are derived from this array.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("strong",{parentName:"td"},"Identity nullifier")),(0,a.kt)("td",{parentName:"tr",align:null},"Random 32 byte value used as component for identity secret generation.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("strong",{parentName:"td"},"Identity trapdoor")),(0,a.kt)("td",{parentName:"tr",align:null},"Random 32 byte value used as component for identity secret generation.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("strong",{parentName:"td"},"Identity secret hash")),(0,a.kt)("td",{parentName:"tr",align:null},"The hash of the identity secret, obtained using the Poseidon hash function. It is used for deriving the identity commitment of the user, and as a private input for zero-knowledge proof generation. The secret hash should be kept private by the user.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("strong",{parentName:"td"},"Identity commitment")),(0,a.kt)("td",{parentName:"tr",align:null},"Hash obtained from the ",(0,a.kt)("inlineCode",{parentName:"td"},"Identity secret hash")," by using the poseidon hash function. It is used by the users for registering in the protocol.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("strong",{parentName:"td"},"Signal")),(0,a.kt)("td",{parentName:"tr",align:null},"The message generated by a user. It is an arbitrary bit string that may represent a chat message, a URL request, protobuf message, etc.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("strong",{parentName:"td"},"Signal hash")),(0,a.kt)("td",{parentName:"tr",align:null},"Keccak256 hash of the signal modulo circuit's field characteristic, used as an input in the RLN circuit.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("strong",{parentName:"td"},"RLN Identifier")),(0,a.kt)("td",{parentName:"tr",align:null},"Random finite field value unique per RLN app. It is used for additional cross-application security. The role of the RLN identifier is protection of the user secrets from being compromised when signals are being generated with the same credentials in different apps.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("strong",{parentName:"td"},"RLN membership tree")),(0,a.kt)("td",{parentName:"tr",align:null},"Merkle tree data structure, filled with identity commitments of the users. Serves as a data structure that ensures user registrations.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("strong",{parentName:"td"},"Merkle proof")),(0,a.kt)("td",{parentName:"tr",align:null},"Proof that a user is member of the RLN membership tree.")))),(0,a.kt)("h4",{id:"rln-zero-knowledge-circuit-specific-terms"},"RLN Zero-Knowledge Circuit specific terms"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Term"),(0,a.kt)("th",{parentName:"tr",align:null},"Description"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("strong",{parentName:"td"},"x")),(0,a.kt)("td",{parentName:"tr",align:null},"Keccak hash of the signal, same as signal hash (Defined above).")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("strong",{parentName:"td"},"A0")),(0,a.kt)("td",{parentName:"tr",align:null},"The identity secret hash.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("strong",{parentName:"td"},"A1")),(0,a.kt)("td",{parentName:"tr",align:null},"Poseidon hash of ","[A0, External nullifier]"," (see about External nullifier below).")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("strong",{parentName:"td"},"y")),(0,a.kt)("td",{parentName:"tr",align:null},"The result of the polynomial equation (y = a0 + a1*x). The public output of the circuit.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("strong",{parentName:"td"},"External nullifier")),(0,a.kt)("td",{parentName:"tr",align:null},"Poseidon hash of ","[Epoch, RLN Identifier]",". An identifier that groups signals and can be thought of as a voting booth.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},(0,a.kt)("strong",{parentName:"td"},"Internal nullifier")),(0,a.kt)("td",{parentName:"tr",align:null},"Poseidon hash of ","[A1]",". This field ensures that a user can send only one valid signal per external nullifier without risking being slashed. Public input of the circuit.")))),(0,a.kt)("h4",{id:"zero-knowledge-circuits-specification"},"Zero-Knowledge Circuits specification"),(0,a.kt)("p",null,"Anonymous signaling with a controlled rate limit\nis enabled by proving that the user is part of a group\nwhich has high barriers to entry (form of stake) and\nenabling secret reveal if more than 1 unique signal is produced per external nullifier.\nThe membership part is implemented using\nmembership ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Merkle_tree"},"Merkle trees")," and Merkle proofs,\nwhile the secret reveal part is enabled by using the Shamir's Secret Sharing scheme.\nEssentially the protocol requires the users to generate zero-knowledge proof\nto be able to send signals and\nparticipate in the application.\nThe zero knowledge proof proves that the user is member of a group,\nbut also enforces the user to share part of their secret\nfor each signal in an external nullifier.\nThe external nullifier is usually represented by timestamp or a time interval.\nIt can also be thought of as a voting booth in voting applications."),(0,a.kt)("p",null,"The zero-knowledge Circuit is implemented using a ",(0,a.kt)("a",{parentName:"p",href:"https://eprint.iacr.org/2016/260.pdf"},"Groth-16 ZK-SNARK"),",\nusing the ",(0,a.kt)("a",{parentName:"p",href:"https://docs.circom.io/"},"circomlib")," library."),(0,a.kt)("h5",{id:"system-parameters"},"System parameters"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"DEPTH")," - Merkle tree depth")),(0,a.kt)("h5",{id:"circuit-parameters"},"Circuit parameters"),(0,a.kt)("h6",{id:"public-inputs"},"Public Inputs"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"x")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"external_nullifier"))),(0,a.kt)("h6",{id:"private-inputs"},"Private Inputs"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"identity_secret_hash")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"path_elements")," - rln membership proof component"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"identity_path_index")," - rln membership proof component")),(0,a.kt)("h6",{id:"outputs"},"Outputs"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"y")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"root")," - the rln membership tree root"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"internal_nullifier"))),(0,a.kt)("h5",{id:"hash-function"},"Hash function"),(0,a.kt)("p",null,"Canonical ",(0,a.kt)("a",{parentName:"p",href:"https://eprint.iacr.org/2019/458.pdf"},"Poseidon hash implementation"),"\nis used,\nas implemented in the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/iden3/circomlib/blob/master/circuits/poseidon.circom"},"circomlib library"),",\naccording to the Poseidon paper.\nThis Poseidon hash version (canonical implementation) uses the following parameters:"),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:"center"},"Hash inputs"),(0,a.kt)("th",{parentName:"tr",align:"center"},(0,a.kt)("inlineCode",{parentName:"th"},"t")),(0,a.kt)("th",{parentName:"tr",align:"center"},(0,a.kt)("inlineCode",{parentName:"th"},"RF")),(0,a.kt)("th",{parentName:"tr",align:"center"},(0,a.kt)("inlineCode",{parentName:"th"},"RP")))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:"center"},"1"),(0,a.kt)("td",{parentName:"tr",align:"center"},"2"),(0,a.kt)("td",{parentName:"tr",align:"center"},"8"),(0,a.kt)("td",{parentName:"tr",align:"center"},"56")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:"center"},"2"),(0,a.kt)("td",{parentName:"tr",align:"center"},"3"),(0,a.kt)("td",{parentName:"tr",align:"center"},"8"),(0,a.kt)("td",{parentName:"tr",align:"center"},"57")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:"center"},"3"),(0,a.kt)("td",{parentName:"tr",align:"center"},"4"),(0,a.kt)("td",{parentName:"tr",align:"center"},"8"),(0,a.kt)("td",{parentName:"tr",align:"center"},"56")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:"center"},"4"),(0,a.kt)("td",{parentName:"tr",align:"center"},"5"),(0,a.kt)("td",{parentName:"tr",align:"center"},"8"),(0,a.kt)("td",{parentName:"tr",align:"center"},"60")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:"center"},"5"),(0,a.kt)("td",{parentName:"tr",align:"center"},"6"),(0,a.kt)("td",{parentName:"tr",align:"center"},"8"),(0,a.kt)("td",{parentName:"tr",align:"center"},"60")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:"center"},"6"),(0,a.kt)("td",{parentName:"tr",align:"center"},"7"),(0,a.kt)("td",{parentName:"tr",align:"center"},"8"),(0,a.kt)("td",{parentName:"tr",align:"center"},"63")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:"center"},"7"),(0,a.kt)("td",{parentName:"tr",align:"center"},"8"),(0,a.kt)("td",{parentName:"tr",align:"center"},"8"),(0,a.kt)("td",{parentName:"tr",align:"center"},"64")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:"center"},"8"),(0,a.kt)("td",{parentName:"tr",align:"center"},"9"),(0,a.kt)("td",{parentName:"tr",align:"center"},"8"),(0,a.kt)("td",{parentName:"tr",align:"center"},"63")))),(0,a.kt)("h5",{id:"membership-implementation"},"Membership implementation"),(0,a.kt)("p",null,"For a valid signal, a user's ",(0,a.kt)("inlineCode",{parentName:"p"},"identity_commitment"),"\n(more on identity commitments below) must exist in identity membership tree.\nMembership is proven by providing a membership proof (witness).\nThe fields from the membership proof REQUIRED for the verification are:\n",(0,a.kt)("inlineCode",{parentName:"p"},"path_elements")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"identity_path_index"),"."),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://github.com/appliedzkp/incrementalquintree"},"IncrementalQuinTree"),"\nalgorithm is used for constructing the Membership Merkle tree.\nThe circuits are reused from this repository.\nYou can find out more details about the IncrementalQuinTree algorithm ",(0,a.kt)("a",{parentName:"p",href:"https://ethresear.ch/t/gas-and-circuit-constraint-benchmarks-of-binary-and-quinary-incremental-Merkle-trees-using-the-poseidon-hash-function/7446"},"here"),"."),(0,a.kt)("h4",{id:"slashing-and-shamirs-secret-sharing"},"Slashing and Shamir's Secret Sharing"),(0,a.kt)("p",null,"Slashing is enabled by using polynomials and ",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing"},"Shamir's Secret sharing"),".\nIn order to produce a valid proof,\n",(0,a.kt)("inlineCode",{parentName:"p"},"identity_secret_hash")," as a private input to the circuit.\nThen a secret equation is created in the form of:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"\ny = a_0 + x * a_1;\n\n")),(0,a.kt)("p",null,"where ",(0,a.kt)("inlineCode",{parentName:"p"},"a_0")," is the ",(0,a.kt)("inlineCode",{parentName:"p"},"identity_secret_hash")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"a_1 = hash(a_0, external nullifier)"),".\nAlong with the generated proof,\nthe users MUST provide a ",(0,a.kt)("inlineCode",{parentName:"p"},"(x, y)")," share which satisfies the line equation,\nin order for their proof to be verified.\n",(0,a.kt)("inlineCode",{parentName:"p"},"x")," is the hashed signal, while the ",(0,a.kt)("inlineCode",{parentName:"p"},"y")," is the circuit output.\nWith more than one pair of unique shares, anyone can derive ",(0,a.kt)("inlineCode",{parentName:"p"},"a_0"),", i.e. the ",(0,a.kt)("inlineCode",{parentName:"p"},"identity_secret_hash"),".\nThe hash of a signal will be the evaluation point ",(0,a.kt)("inlineCode",{parentName:"p"},"x"),".\nIn this way,\na member who sends more than one unique signal per ",(0,a.kt)("inlineCode",{parentName:"p"},"external_nullifier"),"\nrisks their identity secret being revealed."),(0,a.kt)("p",null,"Note that shares used in different epochs and\ndifferent RLN apps cannot be used to derive the ",(0,a.kt)("inlineCode",{parentName:"p"},"identity_secret_hash"),"."),(0,a.kt)("p",null,"Thanks to the ",(0,a.kt)("inlineCode",{parentName:"p"},"external_nullifier")," definition,\nalso shares computed from same secret within same epoch but\nin different RLN apps cannot be used to derive the identity secret hash."),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"rln_identifier")," is a random value from a finite field, unique per RLN app,\nand is used for additional cross-application security -\nto protect the user secrets being compromised if they use\nthe same credentials accross different RLN apps.\nIf ",(0,a.kt)("inlineCode",{parentName:"p"},"rln_identifier")," is not present,\nthe user uses the same credentials and\nsends a different message for two different RLN apps using the same ",(0,a.kt)("inlineCode",{parentName:"p"},"external_nullifier"),",\nthen their user signals can be grouped by the ",(0,a.kt)("inlineCode",{parentName:"p"},"internal_nullifier"),"\nwhich could lead the user's secret revealed.\nThis is because two separate signals under the same ",(0,a.kt)("inlineCode",{parentName:"p"},"internal_nullifier"),"\ncan be treated as rate limiting violation.\nWith adding the ",(0,a.kt)("inlineCode",{parentName:"p"},"rln_identifier")," field we obscure the ",(0,a.kt)("inlineCode",{parentName:"p"},"internal_nullifier"),",\nso this kind of attack can be hardened because\nwe don't have the same ",(0,a.kt)("inlineCode",{parentName:"p"},"internal_nullifier")," anymore."),(0,a.kt)("h4",{id:"identity-credentials-generation"},"Identity credentials generation"),(0,a.kt)("p",null,"In order to be able to generate valid proofs,\nthe users MUST be part of the identity membership Merkle tree.\nThey are part of the identity membership Merkle tree if\ntheir ",(0,a.kt)("inlineCode",{parentName:"p"},"identity_commitment")," is placed in a leaf in the tree."),(0,a.kt)("p",null,"The identity credentials of a user are composed of:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"identity_secret")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"identity_secret_hash")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"identity_commitment"))),(0,a.kt)("h5",{id:"identity_secret"},(0,a.kt)("inlineCode",{parentName:"h5"},"identity_secret")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"identity_secret")," is generated in the following way:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"\nidentity_nullifier = random_32_byte_buffer;\nidentity_trapdoor = random_32_byte_buffer;\nidentity_secret = [identity_nullifier, identity_trapdoor];\n\n")),(0,a.kt)("p",null,"The same secret SHOULD NOT be used accross different protocols,\nbecause revealing the secret at one protocol\ncould break privacy for the user in the other protocols."),(0,a.kt)("h5",{id:"identity_secret_hash"},(0,a.kt)("inlineCode",{parentName:"h5"},"identity_secret_hash")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"identity_secret_hash")," is generated by obtaining a Poseidon hash\nof the ",(0,a.kt)("inlineCode",{parentName:"p"},"identity_secret")," array:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"\nidentity_secret_hash = poseidonHash(identity_secret);\n\n")),(0,a.kt)("h5",{id:"identity_commitment"},(0,a.kt)("inlineCode",{parentName:"h5"},"identity_commitment")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"identity_commitment")," is generated by obtaining a Poseidon hash of the ",(0,a.kt)("inlineCode",{parentName:"p"},"identity_secret_hash"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"\nidentity_commitment = poseidonHash([identity_secret_hash]);\n\n")),(0,a.kt)("h3",{id:"appendix-a-security-considerations"},"Appendix A: Security Considerations"),(0,a.kt)("p",null,"RLN is an experimental and still un-audited technology.\nThis means that the circuits have not been yet audited.\nAnother consideration is the security of the underlying primitives.\nzk-SNARKS require a trusted setup for generating a prover and verifier keys.\nThe standard for this is to use trusted\n",(0,a.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Secure_multi-party_computation"},"Multi-Party Computation (MPC)"),"\nceremony, which requires two phases.\nTrusted MPC ceremony has not yet been performed for the RLN circuits."),(0,a.kt)("h4",{id:"sss-security-assumptions"},"SSS Security Assumptions"),(0,a.kt)("p",null,"Shamir-Secret Sharing requires polynomial coefficients\nto be independent of each other.\nHowever, ",(0,a.kt)("inlineCode",{parentName:"p"},"a_1")," depends on ",(0,a.kt)("inlineCode",{parentName:"p"},"a_0")," through the Poseidon hash algorithm.\nDue to the design of Poseidon,\nit is possible to\n",(0,a.kt)("a",{parentName:"p",href:"https://github.com/Rate-Limiting-Nullifier/rln-circuits/pull/7#issuecomment-1416085627"},"attack"),"\nthe protocol.",(0,a.kt)("br",{parentName:"p"}),"\n","It was decided ",(0,a.kt)("em",{parentName:"p"},"not")," to change the circuits design,\nsince at the moment the attack is infeasible.\nTherefore, implementers must be aware that the current version\nprovides approximately 160-bit security and not 254.\nPossible improvements:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/Rate-Limiting-Nullifier/rln-circuits/pull/7#issuecomment-1416085627"},"change the circuit"),"\nto make coefficients independent;"),(0,a.kt)("li",{parentName:"ul"},"switch to other hash function (Keccak, SHA);")),(0,a.kt)("h3",{id:"appendix-b-identity-scheme-choice"},"Appendix B: Identity Scheme Choice"),(0,a.kt)("p",null,"The hashing scheme used is based on the design decisions\nwhich also include the Semaphore circuits.\nOur goal was to ensure compatibility of the secrets for apps that use Semaphore and\nRLN circuits while also not compromising on security because of using the same secrets."),(0,a.kt)("p",null,"For example, let's say there is a voting app that uses Semaphore,\nand also a chat app that uses RLN.\nThe UX would be better if\nthe users would not need to care about complicated identity management\n(secrets and commitments) they use for each app,\nand it would be much better if they could use a single id commitment for this.\nAlso in some cases these kind of dependency is required -\nRLN chat app using Interep as a registry (instead of using financial stake).\nOne potential concern about this interoperability is a slashed user\non the RLN app side having their security compromised\non the semaphore side apps as well.\ni.e. obtaining the user's secret,\nanyone would be able to generate valid semaphore proofs as the slashed user.\nWe don't want that,\nand we should keep user's app specific security threats\nin the domain of that app alone."),(0,a.kt)("p",null,"To achieve the above interoperability UX\nwhile preventing the shared app security model\n(i.e slashing user on an RLN app having impact on Semaphore apps),\nwe had to do the follow in regard the identity secret and identity commitment:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-js"},"\nidentity_secret = [identity_nullifier, identity_trapdoor];\nidentity_secret_hash = poseidonHash(identity_secret);\nidentity_commitment = poseidonHash([identity_secret_hash]);\n\n")),(0,a.kt)("p",null,"Secret components for generating Semaphore proof:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"identity_nullifier")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"identity_trapdoor"))),(0,a.kt)("p",null,"Secret components for generting RLN proof:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"identity_secret_hash"))),(0,a.kt)("p",null,"When a user is slashed on the RLN app side, their ",(0,a.kt)("inlineCode",{parentName:"p"},"identity_secret_hash")," is revealed.\nHowever, a semaphore proof can't be generated because\nwe do not know the user's ",(0,a.kt)("inlineCode",{parentName:"p"},"identity_nullifier")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"identity_trapdoor"),"."),(0,a.kt)("p",null,"With this design we achieve:"),(0,a.kt)("p",null,(0,a.kt)("inlineCode",{parentName:"p"},"identity_commitment")," (Semaphore) == ",(0,a.kt)("inlineCode",{parentName:"p"},"identity_commitment")," (RLN)\nsecret (semaphore) != secret (RLN)."),(0,a.kt)("p",null,"This is the only option we had for the scheme\nin order to satisfy the properties described above."),(0,a.kt)("p",null,"Also, for RLN we do a single secret component input for the circuit.\nThus we need to hash the secret array (two components) to a secret hash,\nand we use that as a secret component input."),(0,a.kt)("h3",{id:"appendix-c-auxiliary-tooling"},"Appendix C: Auxiliary Tooling"),(0,a.kt)("p",null,"There are few additional tools implemented for easier integrations and\nusage of the RLN protocol."),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://github.com/vacp2p/zerokit"},(0,a.kt)("inlineCode",{parentName:"a"},"zerokit"))," is a set of Zero Knowledge modules,\nwritten in Rust and designed to be used in many different environments.\nAmong different modules, it supports ",(0,a.kt)("inlineCode",{parentName:"p"},"Semaphore")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"RLN"),"."),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://github.com/appliedzkp/zk-kit"},(0,a.kt)("inlineCode",{parentName:"a"},"zk-kit")),"\nis a typescript library which exposes APIs for identity credentials generation,\nas well as proof generation.\nIt supports various protocols (",(0,a.kt)("inlineCode",{parentName:"p"},"Semaphore"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"RLN"),")."),(0,a.kt)("p",null,(0,a.kt)("a",{parentName:"p",href:"https://github.com/akinovak/zk-keeper"},(0,a.kt)("inlineCode",{parentName:"a"},"zk-keeper")),"\nis a browser plugin which allows for safe credential storing and\nproof generation.\nYou can think of MetaMask for zero-knowledge proofs.\nIt uses ",(0,a.kt)("inlineCode",{parentName:"p"},"zk-kit")," under the hood."),(0,a.kt)("h3",{id:"appendix-d-example-usage"},"Appendix D: Example Usage"),(0,a.kt)("p",null,"The following examples are code snippets using the ",(0,a.kt)("inlineCode",{parentName:"p"},"zerokit")," RLN module.\nThe examples are written in ",(0,a.kt)("a",{parentName:"p",href:"https://www.rust-lang.org/"},"rust"),"."),(0,a.kt)("h4",{id:"creating-a-rln-object"},"Creating a RLN Object"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'\nuse rln::protocol::*;\nuse rln::public::*;\nuse std::io::Cursor;\n// We set the RLN parameters: \n// - the tree height;\n// - the circuit resource folder (requires a trailing "/").\nlet tree_height = 20;\nlet resources = Cursor::new("../zerokit/rln/resources/tree_height_20/");\n// We create a new RLN instance\nlet mut rln = RLN::new(tree_height, resources);\n\n')),(0,a.kt)("h4",{id:"generating-identity-credentials"},"Generating Identity Credentials"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"\n// We generate an identity tuple\nlet mut buffer = Cursor::new(Vec::<u8>::new());\nrln.extended_key_gen(&mut buffer).unwrap();\n// We deserialize the keygen output to obtain\n// the identiy_secret and id_commitment\nlet (identity_trapdoor, identity_nullifier, identity_secret_hash, id_commitment) = deserialize_identity_tuple(buffer.into_inner());\n\n")),(0,a.kt)("h4",{id:"adding-id-commitment-to-the-rln-merkle-tree"},"Adding ID Commitment to the RLN Merkle Tree"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"\n// We define the tree index where id_commitment will be added\nlet id_index = 10;\n// We serialize id_commitment and pass it to set_leaf\nlet mut buffer = Cursor::new(serialize_field_element(id_commitment));\nrln.set_leaf(id_index, &mut buffer).unwrap();\n\n")),(0,a.kt)("h4",{id:"setting-epoch-and-signal"},"Setting Epoch and Signal"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},'\n// We generate epoch from a date seed and we ensure is\n// mapped to a field element by hashing-to-field its content\nlet epoch = hash_to_field(b"Today at noon, this year");\n// We set our signal \nlet signal = b"RLN is awesome";\n\n')),(0,a.kt)("h4",{id:"generating-proof-1"},"Generating Proof"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"\n// We prepare input to the proof generation routine\nlet proof_input = prepare_prove_input(identity_secret, id_index, epoch, signal);\n// We generate a RLN proof for proof_input\nlet mut in_buffer = Cursor::new(proof_input);\nlet mut out_buffer = Cursor::new(Vec::<u8>::new());\nrln.generate_rln_proof(&mut in_buffer, &mut out_buffer)\n    .unwrap();\n// We get the public outputs returned by the circuit evaluation\nlet proof_data = out_buffer.into_inner();\n\n")),(0,a.kt)("h4",{id:"verifiying-proof"},"Verifiying Proof"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-rust"},"\n// We prepare input to the proof verification routine\nlet verify_data = prepare_verify_input(proof_data, signal);\n// We verify the zero-knowledge proof against the provided proof values\nlet mut in_buffer = Cursor::new(verify_data);\nlet verified = rln.verify(&mut in_buffer).unwrap();\n// We ensure the proof is valid\nassert!(verified);\n\n")),(0,a.kt)("p",null,"For more details please visit the\n",(0,a.kt)("a",{parentName:"p",href:"https://github.com/vacp2p/zerokit"},(0,a.kt)("inlineCode",{parentName:"a"},"zerokit"))," library."),(0,a.kt)("h2",{id:"copyright"},"Copyright"),(0,a.kt)("p",null,"Copyright and related rights waived via ",(0,a.kt)("a",{parentName:"p",href:"https://creativecommons.org/publicdomain/zero/1.0/"},"CC0")),(0,a.kt)("h2",{id:"references"},"References"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"../../waku/standards/core/17/rln-relay"},"17/WAKU2-RLN-RELAY RFC")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://interep.link/"},"Interep")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/appliedzkp/incrementalquintree/blob/master/ts/IncrementalQuinTree.ts"},"incremental Merkle tree algorithm")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Shamir%27s_Secret_Sharing"},"Shamir's Secret sharing scheme")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Lagrange_polynomial"},"Lagrange polynomials")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://z.cash/technology/zksnarks/"},"ZK-SNARK")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Merkle_tree"},"Merkle trees")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://eprint.iacr.org/2016/260.pdf"},"Groth-16 ZK-SNARK")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://docs.circom.io/"},"circomlib")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://eprint.iacr.org/2019/458.pdf"},"Poseidon hash implementation")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/iden3/circomlib/blob/master/circuits/poseidon.circom"},"circomlib library")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/appliedzkp/incrementalquintree"},"IncrementalQuinTree")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://ethresear.ch/t/gas-and-circuit-constraint-benchmarks-of-binary-and-quinary-incremental-Merkle-trees-using-the-poseidon-hash-function/7446"},"IncrementalQuinTree algorithm")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://en.wikipedia.org/wiki/Secure_multi-party_computation"},"Multi-Party Computation (MPC)")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/Rate-Limiting-Nullifier/rln-circuits/pull/7#issuecomment-1416085627"},"Poseidon hash attack")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/vacp2p/zerokit"},"zerokit")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/appliedzkp/zk-kit"},"zk-kit")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://github.com/akinovak/zk-keeper"},"zk-keeper")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://www.rust-lang.org/"},"rust"))),(0,a.kt)("h3",{id:"informative"},"Informative"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"[1][privacy-scaling-explorations]","(",(0,a.kt)("a",{parentName:"li",href:"https://medium.com/privacy-scaling-explorations/rate-limiting-nullifier-a-spam-protection-mechanism-for-anonymous-environments-bbe4006a57d"},"https://medium.com/privacy-scaling-explorations/rate-limiting-nullifier-a-spam-protection-mechanism-for-anonymous-environments-bbe4006a57d"),")"),(0,a.kt)("li",{parentName:"ul"},"[2][security-considerations-of-zk-snark-parameter-multi-party-computation]","(",(0,a.kt)("a",{parentName:"li",href:"https://research.nccgroup.com/2020/06/24/)security-considerations-of-zk-snark-parameter-multi-party-computation/"},"https://research.nccgroup.com/2020/06/24/)security-considerations-of-zk-snark-parameter-multi-party-computation/")),(0,a.kt)("li",{parentName:"ul"},"[3][rln-circuits]","(",(0,a.kt)("a",{parentName:"li",href:"https://github.com/Rate-Limiting-Nullifier/rln-circuits/"},"https://github.com/Rate-Limiting-Nullifier/rln-circuits/"),")"),(0,a.kt)("li",{parentName:"ul"},"[4][rln docs]","(",(0,a.kt)("a",{parentName:"li",href:"https://rate-limiting-nullifier.github.io/rln-docs/"},"https://rate-limiting-nullifier.github.io/rln-docs/"),")")))}m.isMDXComponent=!0},3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>u});var i=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=i.createContext({}),p=function(e){var t=i.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=p(e.components);return i.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},h=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,s=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),h=p(n),u=a,c=h["".concat(s,".").concat(u)]||h[u]||m[u]||r;return n?i.createElement(c,l(l({ref:t},d),{},{components:n})):i.createElement(c,l({ref:t},d))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,l=new Array(r);l[0]=h;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:a,l[1]=o;for(var p=2;p<r;p++)l[p]=n[p];return i.createElement.apply(null,l)}return i.createElement.apply(null,n)}h.displayName="MDXCreateElement"}}]);