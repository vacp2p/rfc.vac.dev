"use strict";(self.webpackChunklogos_docs_template=self.webpackChunklogos_docs_template||[]).push([[952],{26514:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>m,contentTitle:()=>s,default:()=>p,frontMatter:()=>i,metadata:()=>o,toc:()=>d});var a=n(87462),r=(n(67294),n(3905));const i={title:"VAC-DECENTRALIZED-MESSAGING-ETHEREUM",name:"Decentralized Key and Session Setup for Secure Messaging over Ethereum",status:"raw",category:"informational",editor:"Ramses Fernandez-Valencia &lt;ramses@status.im&gt;",contributors:null},s=void 0,o={unversionedId:"raw/decentralized-messaging-ethereum",id:"raw/decentralized-messaging-ethereum",title:"VAC-DECENTRALIZED-MESSAGING-ETHEREUM",description:"- Status: raw",source:"@site/vac/raw/decentralized-messaging-ethereum.md",sourceDirName:"raw",slug:"/raw/decentralized-messaging-ethereum",permalink:"/vac/raw/decentralized-messaging-ethereum",draft:!1,tags:[],version:"current",frontMatter:{title:"VAC-DECENTRALIZED-MESSAGING-ETHEREUM",name:"Decentralized Key and Session Setup for Secure Messaging over Ethereum",status:"raw",category:"informational",editor:"Ramses Fernandez-Valencia &lt;ramses@status.im&gt;",contributors:null},sidebar:"defaultSidebar",previous:{title:"Vac Raw Specifications",permalink:"/vac/raw/"},next:{title:"ETH-SECPM",permalink:"/vac/raw/eth-secpm"}},m={},d=[{value:"Abstract",id:"abstract",level:2},{value:"Motivation",id:"motivation",level:2},{value:"Theory",id:"theory",level:2},{value:"Protocol overview",id:"protocol-overview",level:3},{value:"Components of the protocol",id:"components-of-the-protocol",level:3},{value:"Authenticated causal broadcast",id:"authenticated-causal-broadcast",level:4},{value:"Decentralized group membership",id:"decentralized-group-membership",level:4},{value:"2-party secure messaging (2SM)",id:"2-party-secure-messaging-2sm",level:4},{value:"2SM-Init",id:"2sm-init",level:5},{value:"2SM-Send",id:"2sm-send",level:5},{value:"2SM-Receive",id:"2sm-receive",level:5},{value:"2SM Syntax",id:"2sm-syntax",level:4},{value:"The 2SM-Init",id:"the-2sm-init",level:4},{value:"The 2SM-Send",id:"the-2sm-send",level:4},{value:"The 2SM-Receive",id:"the-2sm-receive",level:4},{value:"PKE Syntax",id:"pke-syntax",level:3},{value:"Parameters",id:"parameters",level:4},{value:"PKE-KGen",id:"pke-kgen",level:4},{value:"PKE-Enc",id:"pke-enc",level:4},{value:"PKE-Dec",id:"pke-dec",level:4},{value:"DCGKA Syntax",id:"dcgka-syntax",level:3},{value:"Auxiliary functions",id:"auxiliary-functions",level:4},{value:"init",id:"init",level:4},{value:"encrypt-to",id:"encrypt-to",level:4},{value:"decrypt-from",id:"decrypt-from",level:4},{value:"update-ratchet",id:"update-ratchet",level:4},{value:"member-view",id:"member-view",level:4},{value:"generate-seed",id:"generate-seed",level:4},{value:"Creation of a group",id:"creation-of-a-group",level:3},{value:"create",id:"create",level:4},{value:"process-seed",id:"process-seed",level:4},{value:"process-create",id:"process-create",level:4},{value:"process-ack",id:"process-ack",level:4},{value:"Post-compromise security updates and group member removal",id:"post-compromise-security-updates-and-group-member-removal",level:3},{value:"update",id:"update",level:4},{value:"remove",id:"remove",level:4},{value:"process-update",id:"process-update",level:4},{value:"process-remove",id:"process-remove",level:4},{value:"Group member addition",id:"group-member-addition",level:3},{value:"add",id:"add",level:4},{value:"process-add",id:"process-add",level:4},{value:"process-add-ack",id:"process-add-ack",level:4},{value:"process-welcome",id:"process-welcome",level:4},{value:"Privacy Considerations",id:"privacy-considerations",level:2},{value:"Dependency on PKI",id:"dependency-on-pki",level:3},{value:"SIWE",id:"siwe",level:4},{value:"Our approach",id:"our-approach",level:4},{value:"Multi-device setting",id:"multi-device-setting",level:3},{value:"Using UPKE",id:"using-upke",level:3},{value:"Copyright",id:"copyright",level:2},{value:"References",id:"references",level:2}],l={toc:d};function p(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Status: raw"),(0,r.kt)("li",{parentName:"ul"},"Category: informational"),(0,r.kt)("li",{parentName:"ul"},"Editor: Ramses Fernandez-Valencia ","<",(0,r.kt)("a",{parentName:"li",href:"mailto:ramses@status.im"},"ramses@status.im"),">")),(0,r.kt)("h2",{id:"abstract"},"Abstract"),(0,r.kt)("p",null,"This document introduces a decentralized group messaging protocol\nusing Ethereum adresses as identifiers.\nIt is based in the proposal\n",(0,r.kt)("a",{parentName:"p",href:"https://eprint.iacr.org/2020/1281"},"DCGKA")," by Weidner et al.\nIt includes also approximations to overcome limitations related to using PKI and\nthe multi-device setting."),(0,r.kt)("h2",{id:"motivation"},"Motivation"),(0,r.kt)("p",null,"The need for secure communications has become paramount.\nTraditional centralized messaging protocols are susceptible to various security threats,\nincluding unauthorized access, data breaches, and single points of failure.\nTherefore a decentralized approach to secure communication becomes increasingly relevant,\noffering a robust solution to address these challenges."),(0,r.kt)("p",null,"Secure messaging protocols used should have the following key features:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Asynchronous Messaging:")," Users can send messages even if\nthe recipients are not online at the moment."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Resilience to Compromise:")," If a user's security is compromised,\nthe protocol ensures that previous messages remain secure\nthrough forward secrecy (FS).\nThis means that messages sent before the compromise cannot be decrypted by adversaries.\nAdditionally, the protocol maintains post-compromise security (PCS)\nby regularly updating keys,\nmaking it difficult for adversaries to decrypt future communication."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"Dynamic Group Management:")," Users can easily add or\nremove group members at any time,\nreflecting the flexible nature of communication within the app.")),(0,r.kt)("p",null,"In this field, there exists a ",(0,r.kt)("em",{parentName:"p"},"trilemma"),", similar to what one observes in blockchain,\ninvolving three key aspects:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"security,"),(0,r.kt)("li",{parentName:"ol"},"scalability, and"),(0,r.kt)("li",{parentName:"ol"},"decentralization.")),(0,r.kt)("p",null,"For instance, protocols like the ",(0,r.kt)("a",{parentName:"p",href:"https://messaginglayersecurity.rocks"},"MLS"),"\nperform well in terms of scalability and security.\nHowever, they falls short in decentralization."),(0,r.kt)("p",null,"Newer studies such as ",(0,r.kt)("a",{parentName:"p",href:"https://eprint.iacr.org/2022/251"},"CoCoa"),"\nimprove features related to security and scalability,\nbut they still rely on servers, which may not be fully trusted though they are necessary."),(0,r.kt)("p",null,"On the other hand,\nolder studies like ",(0,r.kt)("a",{parentName:"p",href:"https://mattweidner.com/assets/pdf/acs-dissertation.pdf"},"Causal TreeKEM"),"\nexhibit decent scalability (logarithmic)\nbut lack forward secrecy and have weak post-compromise security (PCS)."),(0,r.kt)("p",null,"The creators of ",(0,r.kt)("a",{parentName:"p",href:"https://eprint.iacr.org/2020/1281"},"DCGKA")," introduce a decentralized,\nasynchronous secure group messaging protocol that supports dynamic groups.\nThis protocol operates effectively on various underlying networks\nwithout strict requirements on message ordering or latency.\nIt can be implemented in peer-to-peer or anonymity networks,\naccommodating network partitions, high latency links, and\ndisconnected operation seamlessly.\nNotably, the protocol doesn't rely on servers or\na consensus protocol for its functionality."),(0,r.kt)("p",null,"This proposal provides end-to-end encryption with forward secrecy and\npost-compromise security,\neven when multiple users concurrently modify the group state."),(0,r.kt)("h2",{id:"theory"},"Theory"),(0,r.kt)("h3",{id:"protocol-overview"},"Protocol overview"),(0,r.kt)("p",null,"This protocol makes use of ratchets to provide FS\nby encrypting each message with a different key."),(0,r.kt)("p",null,"In the figure one can see the ratchet for encrypting a sequence of messages.\nThe sender requires an initial update secret ",(0,r.kt)("inlineCode",{parentName:"p"},"I_1"),", which is introduced in a PRG.\nThe PRG will produce two outputs, namely a symmetric key for AEAD encryption, and\na seed for the next ratchet state.\nThe associated data needed in the AEAD encryption includes the message index ",(0,r.kt)("inlineCode",{parentName:"p"},"i"),".\nThe ciphertext ",(0,r.kt)("inlineCode",{parentName:"p"},"c_i")," associated to message ",(0,r.kt)("inlineCode",{parentName:"p"},"m_i"),"\nis then broadcasted to all group members.\nThe next step requires deleting ",(0,r.kt)("inlineCode",{parentName:"p"},"I_1"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"k_i")," and any old ratchet state."),(0,r.kt)("p",null,"After a period of time the sender may replace the ratchet state with new update secrets\n",(0,r.kt)("inlineCode",{parentName:"p"},"I_2"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"I_3"),", and so on."),(0,r.kt)("p",null,"To start a post-compromise security update,\na user creates a new random value known as a seed secret and\nshares it with every other group member through a secure two-party channel.\nUpon receiving the seed secret,\neach group member uses it to calculate an update secret for both the sender's ratchet\nand their own.\nAdditionally, the recipient sends an unencrypted acknowledgment to the group\nconfirming the update.\nEvery member who receives the acknowledgment updates\nnot only the ratchet for the original sender but\nalso the ratchet for the sender of the acknowledgment.\nConsequently, after sharing the seed secret through ",(0,r.kt)("inlineCode",{parentName:"p"},"n - 1")," two-party messages and\nconfirming it with ",(0,r.kt)("inlineCode",{parentName:"p"},"n - 1")," broadcast acknowledgments,\nevery group member has derived an update secret and updated their ratchet accordingly."),(0,r.kt)("p",null,"When removing a group member,\nthe user who initiates the removal conducts a post-compromise security update\nby sending the update secret to all group members except the one being removed.\nTo add a new group member,\neach existing group member shares the necessary state with the new user,\nenabling them to derive their future update secrets."),(0,r.kt)("p",null,"Since group members may receive messages in various orders,\nit's important to ensure that each sender's ratchet is updated consistently\nwith the same sequence of update secrets at each group member."),(0,r.kt)("p",null,"The network protocol used in this scheme ensures that messages from the same sender\nare processed in the order they were sent."),(0,r.kt)("h3",{id:"components-of-the-protocol"},"Components of the protocol"),(0,r.kt)("p",null,"This protocol relies in 3 components:\nauthenticated causal broadcast (ACB),\ndecentralized group membership (DGM) and\n2-party secure messaging (2SM)."),(0,r.kt)("h4",{id:"authenticated-causal-broadcast"},"Authenticated causal broadcast"),(0,r.kt)("p",null,"A causal order is a partial order relation ",(0,r.kt)("inlineCode",{parentName:"p"},"<")," on messages.\nTwo messages ",(0,r.kt)("inlineCode",{parentName:"p"},"m_1")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"m_2")," are causally ordered, or\n",(0,r.kt)("inlineCode",{parentName:"p"},"m_1")," causally precedes ",(0,r.kt)("inlineCode",{parentName:"p"},"m_2"),"\n(denoted by ",(0,r.kt)("inlineCode",{parentName:"p"},"m_1 < m_2"),"), if one of the following contiditions hold:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"m_1")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"m_2")," were sent by the same group member, and\n",(0,r.kt)("inlineCode",{parentName:"li"},"m_1")," was sent before ",(0,r.kt)("inlineCode",{parentName:"li"},"m_2"),"."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"m_2")," was sent by a group member U, and ",(0,r.kt)("inlineCode",{parentName:"li"},"m_1")," was received and\nprocessed by ",(0,r.kt)("inlineCode",{parentName:"li"},"U")," before sending ",(0,r.kt)("inlineCode",{parentName:"li"},"m_2"),"."),(0,r.kt)("li",{parentName:"ol"},"There exists ",(0,r.kt)("inlineCode",{parentName:"li"},"m_3")," such that ",(0,r.kt)("inlineCode",{parentName:"li"},"m_1 < m_3")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"m_3 < m_2"),".")),(0,r.kt)("p",null,"Causal broadcast requires that before processing ",(0,r.kt)("inlineCode",{parentName:"p"},"m"),",\na group member must process all preceding messages ",(0,r.kt)("inlineCode",{parentName:"p"},"{m' | m' < m}"),"."),(0,r.kt)("p",null,"The causal broadcast module used in this protocol\nauthenticates the sender of each message,\nas well as its causal ordering metadata,\nusing a digital signature under the sender\u2019s identity key.\nThis prevents a passive adversary from impersonating users or\naffecting causally ordered delivery."),(0,r.kt)("h4",{id:"decentralized-group-membership"},"Decentralized group membership"),(0,r.kt)("p",null,"This protocol assumes the existence of a decentralized group membership function\n(denoted as DGM) that takes a set of membership change messages and\ntheir causal order relantionships,\nand returns the current set of group members\u2019 IDs.\nIt needs to be deterministic and depend only on causal order, and not exact order."),(0,r.kt)("h4",{id:"2-party-secure-messaging-2sm"},"2-party secure messaging (2SM)"),(0,r.kt)("p",null,"This protocol makes use of bidirectional 2-party secure messaging schemes,\nwhich consist of 3 algorithms: ",(0,r.kt)("inlineCode",{parentName:"p"},"2SM-Init"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"2SM-Send")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"2SM-Receive"),"."),(0,r.kt)("h5",{id:"2sm-init"},"2SM-Init"),(0,r.kt)("p",null,"This function takes two IDs as inputs:\n",(0,r.kt)("inlineCode",{parentName:"p"},"ID1")," representing the local user and ",(0,r.kt)("inlineCode",{parentName:"p"},"ID2")," representing the other party.\nIt returns an initial protocol state ",(0,r.kt)("inlineCode",{parentName:"p"},"sigma"),".\nThe 2SM protocol relies on a Public Key Infrastructure (PKI) or\na key server to map these IDs to their corresponding public keys.\nIn practice, the PKI should incorporate ephemeral prekeys.\nThis allows users to send messages to a new group member,\neven if that member is currently offline."),(0,r.kt)("h5",{id:"2sm-send"},"2SM-Send"),(0,r.kt)("p",null,"This function takes a state ",(0,r.kt)("inlineCode",{parentName:"p"},"sigma")," and a plaintext ",(0,r.kt)("inlineCode",{parentName:"p"},"m")," as inputs, and\nreturns a new state ",(0,r.kt)("inlineCode",{parentName:"p"},"sigma\u2019")," and a ciphertext ",(0,r.kt)("inlineCode",{parentName:"p"},"c"),"."),(0,r.kt)("h5",{id:"2sm-receive"},"2SM-Receive"),(0,r.kt)("p",null,"This function takes a state ",(0,r.kt)("inlineCode",{parentName:"p"},"sigma")," and a ciphertext ",(0,r.kt)("inlineCode",{parentName:"p"},"c"),", and\nreturns a new state ",(0,r.kt)("inlineCode",{parentName:"p"},"sigma\u2019")," and a plaintext ",(0,r.kt)("inlineCode",{parentName:"p"},"m"),"."),(0,r.kt)("h4",{id:"2sm-syntax"},"2SM Syntax"),(0,r.kt)("p",null,"The variable ",(0,r.kt)("inlineCode",{parentName:"p"},"sigma")," denotes the state consisting in the variables below:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"sigma.mySks[0] = sk\nsigma.nextIndex = 1 \nsigma.receivedSk = empty_string\nsigma.otherPk = pk`<br/> \nsigma.otherPksender = \u201cother\u201d\nsigma.otherPkIndex = 0\n")),(0,r.kt)("h4",{id:"the-2sm-init"},"The 2SM-Init"),(0,r.kt)("p",null,"On input a key pair ",(0,r.kt)("inlineCode",{parentName:"p"},"(sk, pk)"),", this functions otuputs a state ",(0,r.kt)("inlineCode",{parentName:"p"},"sigma"),"."),(0,r.kt)("h4",{id:"the-2sm-send"},"The 2SM-Send"),(0,r.kt)("p",null,"This function encrypts the message ",(0,r.kt)("inlineCode",{parentName:"p"},"m")," using ",(0,r.kt)("inlineCode",{parentName:"p"},"sigma.otherPk"),",\nwhich represents the other party\u2019s current public key.\nThis key is determined based on the last public key generated\nfor the other party or the last public key received from the other party,\nwhichever is more recent.\n",(0,r.kt)("inlineCode",{parentName:"p"},"sigma.otherPkSender")," is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"me")," in the former case and\n",(0,r.kt)("inlineCode",{parentName:"p"},"other")," in the latter case."),(0,r.kt)("p",null,"Metadata including ",(0,r.kt)("inlineCode",{parentName:"p"},"otherPkSender")," and\n",(0,r.kt)("inlineCode",{parentName:"p"},"otherPkIndex")," are included in the message to indicate\nwhich of the recipient\u2019s public keys is being utilized."),(0,r.kt)("p",null,"Additionally, this function generates a new key pair for the local user,\nstoring the secret key in ",(0,r.kt)("inlineCode",{parentName:"p"},"sigma.mySks")," and sending the public key.\nSimilarly, it generates a new key pair for the other party,\nsending the secret key (encrypted) and storing the public key in ",(0,r.kt)("inlineCode",{parentName:"p"},"sigma.otherPk"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'sigma.mySks[sigma.nextIndex], myNewPk) = PKE-Gen()\n(otherNewSk, otherNewPk) = PKE-Gen()\nplaintext = (m, otherNewSk, sigma`.nextIndex, myNewPk)\nmsg = (PKE-Enc(sigma.otherPk, plaintext), sigma.otherPkSender, sigma.otherPkIndex)\nsigma.nextIndex++\n(sigma.otherPk, sigma.otherPkSender, sigma.otherPkIndex) = (otherNewPk, "me", empty_string)\nreturn (sigma`, msg)\n')),(0,r.kt)("h4",{id:"the-2sm-receive"},"The 2SM-Receive"),(0,r.kt)("p",null,"This function utilizes the metadata of the message ",(0,r.kt)("inlineCode",{parentName:"p"},"c"),"\nto determine which secret key to utilize for decryption,\nassigning it to ",(0,r.kt)("inlineCode",{parentName:"p"},"sk"),".\nIf the secret key corresponds to one generated by ourselves,\nthat secret key along with all keys with lower index are deleted.\nThis deletion is indicated by ",(0,r.kt)("inlineCode",{parentName:"p"},"sigma.mySks[\u2264 keyIndex] = empty_string"),".\nSubsequently, the new public and secret keys contained in the message are stored."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'(ciphertext, keySender, keyIndex) = c\nif keySender = "other" then \nsk = sigma.mySks[keyIndex] \nsigma.mySks[\u2264 keyIndex] = empty_string\nelse sk = sigma.receivedSk\n(m, sigma.receivedSk, sigma.otherPkIndex, sigma.otherPk) = PKE-Dec(sk, ciphertext)\nsigma.otherPkSender = "other"\nreturn (sigma, m)\n')),(0,r.kt)("h3",{id:"pke-syntax"},"PKE Syntax"),(0,r.kt)("p",null,"The required PKE that MUST be used is ElGamal with a 2048-bit modulus ",(0,r.kt)("inlineCode",{parentName:"p"},"p"),"."),(0,r.kt)("h4",{id:"parameters"},"Parameters"),(0,r.kt)("p",null,"The following parameters must be used:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"p = 308920927247127345254346920820166145569\ng = 2\n")),(0,r.kt)("h4",{id:"pke-kgen"},"PKE-KGen"),(0,r.kt)("p",null,"Each user ",(0,r.kt)("inlineCode",{parentName:"p"},"u")," MUST do the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"PKE-KGen():\na = randint(2, p-2)\npk = (p, g, g^a)\nsk = a\nreturn (pk, sk)\n")),(0,r.kt)("h4",{id:"pke-enc"},"PKE-Enc"),(0,r.kt)("p",null,"A user ",(0,r.kt)("inlineCode",{parentName:"p"},"v")," encrypting a message ",(0,r.kt)("inlineCode",{parentName:"p"},"m")," for ",(0,r.kt)("inlineCode",{parentName:"p"},"u")," MUST follow these steps:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"PKE-Enc(pk):\nk = randint(2, p-2)\neta = g^k % p\ndelta = m * (g^a)^k % p\nreturn ((eta, delta))\n")),(0,r.kt)("h4",{id:"pke-dec"},"PKE-Dec"),(0,r.kt)("p",null,"The user ",(0,r.kt)("inlineCode",{parentName:"p"},"u")," recovers a message ",(0,r.kt)("inlineCode",{parentName:"p"},"m")," from a ciphertext ",(0,r.kt)("inlineCode",{parentName:"p"},"c"),"\nby performing the following operations:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"PKE-Dec(sk):\nmu = eta^(p-1-sk) % p\nreturn ((mu * delta) % p)\n")),(0,r.kt)("h3",{id:"dcgka-syntax"},"DCGKA Syntax"),(0,r.kt)("h4",{id:"auxiliary-functions"},"Auxiliary functions"),(0,r.kt)("p",null,"There exist 6 functions that are auxiliary for the rest of components of the protocol,\nnamely:"),(0,r.kt)("h4",{id:"init"},"init"),(0,r.kt)("p",null,"This function takes an ",(0,r.kt)("inlineCode",{parentName:"p"},"ID")," as input and returns its associated initial state,\ndenoted by ",(0,r.kt)("inlineCode",{parentName:"p"},"gamma"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"gamma.myId = ID\ngamma.mySeq = 0\ngamma.history = empty\ngamma.nextSeed = empty_string\ngamma.2sm[\xb7] = empty_string\ngamma.memberSecret[\xb7, \xb7, \xb7] = empty_string\ngamma.ratchet[\xb7] = empty_string\nreturn (gamma)\n")),(0,r.kt)("h4",{id:"encrypt-to"},"encrypt-to"),(0,r.kt)("p",null,"Upon reception of the recipient\u2019s ",(0,r.kt)("inlineCode",{parentName:"p"},"ID")," and a plaintext,\nit encrypts a direct message for another group member.\nShould it be the first message for a particular ",(0,r.kt)("inlineCode",{parentName:"p"},"ID"),",\nthen the ",(0,r.kt)("inlineCode",{parentName:"p"},"2SM")," protocol state is initialized and stored in ",(0,r.kt)("inlineCode",{parentName:"p"},"gamma.2sm[recipient.ID]"),".\nOne then uses ",(0,r.kt)("inlineCode",{parentName:"p"},"2SM_Send")," to encrypt the message and\nstore the updated protocol in ",(0,r.kt)("inlineCode",{parentName:"p"},"gamma"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"if gamma.2sm[recipient_ID] = empty_string then\n gamma.2sm[recipient_ID] = 2SM_Init(gamma.myID, recipient_ID)\n(gamma.2sm[recipient_ID], ciphertext) = 2SM_Send(gamma.2sm[recipient_ID], plaintext)\nreturn (gamma, ciphertext)\n")),(0,r.kt)("h4",{id:"decrypt-from"},"decrypt-from"),(0,r.kt)("p",null,"After receiving the sender\u2019s ",(0,r.kt)("inlineCode",{parentName:"p"},"ID")," and a ciphertext,\nit behaves as the reverse function of ",(0,r.kt)("inlineCode",{parentName:"p"},"encrypt-to")," and has a similar initialization:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"if gamma.2sm[sender_ID] = empty_string then\ngamma.2sm[sender_ID] = 2SM_Init(gamma.myID, sender_ID)\n(gamma.2sm[sender_ID], plaintext) = 2SM_Receive(gamma.2sm[sender_ID], ciphertext)\nreturn (gamma, plaintext)\n")),(0,r.kt)("h4",{id:"update-ratchet"},"update-ratchet"),(0,r.kt)("p",null,"This function generates the next update secret ",(0,r.kt)("inlineCode",{parentName:"p"},"I_update")," for the group member ",(0,r.kt)("inlineCode",{parentName:"p"},"ID"),".\nThe ratchet state is stored in ",(0,r.kt)("inlineCode",{parentName:"p"},"gamma.ratchet[ID]"),".\nIt is required to use a HMAC-based key derivation function HKDF\nto combine the ratchet state with an input,\nreturning an update secret and a new ratchet state."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"(updateSecret, gamma.ratchet[ID]) = HKDF(gamma.ratchet[ID], input)\nreturn (gamma, updateSecret)\n")),(0,r.kt)("h4",{id:"member-view"},"member-view"),(0,r.kt)("p",null,"This function calculates the set of group members\nbased on the most recent control message sent by the specified user ",(0,r.kt)("inlineCode",{parentName:"p"},"ID"),".\nIt filters the group membership operations\nto include only those observed by the specified ",(0,r.kt)("inlineCode",{parentName:"p"},"ID"),", and\nthen invokes the DGM function to generate the group membership."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"ops = {m in gamma.history st. m was sent or acknowledged by ID}\nreturn DGM(ops)\n")),(0,r.kt)("h4",{id:"generate-seed"},"generate-seed"),(0,r.kt)("p",null,"This functions generates a random bit string and\nsends it encrypted to each member of the group using the ",(0,r.kt)("inlineCode",{parentName:"p"},"2SM")," mechanism.\nIt returns the updated protocol state and\nthe set of direct messages (denoted as ",(0,r.kt)("inlineCode",{parentName:"p"},"dmsgs"),") to send."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"gamma.nextSeed = random.randbytes()\ndmsgs = empty\nfor each ID in recipients:\n(gamma, msg) = encrypt-to(gamma, ID, gamma.nextSeed)\ndmsgs = dmsgs + (ID, msg)\nreturn (gamma, dmsgs)\n")),(0,r.kt)("h3",{id:"creation-of-a-group"},"Creation of a group"),(0,r.kt)("p",null,"A group is generated in a 3 steps procedure:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"A user calls the ",(0,r.kt)("inlineCode",{parentName:"li"},"create")," function and broadcasts a control message of type ",(0,r.kt)("em",{parentName:"li"},"create"),"."),(0,r.kt)("li",{parentName:"ol"},"Each receiver of the message processes the message and\nbroadcasts an ",(0,r.kt)("em",{parentName:"li"},"ack")," control message."),(0,r.kt)("li",{parentName:"ol"},"Each member processes the ",(0,r.kt)("em",{parentName:"li"},"ack")," message received.")),(0,r.kt)("h4",{id:"create"},"create"),(0,r.kt)("p",null,"This function generates a ",(0,r.kt)("em",{parentName:"p"},"create")," control message and\ncalls ",(0,r.kt)("inlineCode",{parentName:"p"},"generate-seed")," to define the set of direct messages that need to be sent.\nThen it calls ",(0,r.kt)("inlineCode",{parentName:"p"},"process-create")," to process the control message for this user.\nThe function ",(0,r.kt)("inlineCode",{parentName:"p"},"process-create")," returns a tuple including an updated state gamma and\nan update secret ",(0,r.kt)("inlineCode",{parentName:"p"},"I"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"control = (\u201ccreate\u201d, gamma.mySeq, IDs)\n(gamma, dmsgs) = generate-seed(gamma, IDs)\n(gamma, _, _, I, _) = process-create(gamma, gamma.myId, gamma.mySeq, IDs, empty_string)\nreturn (gamma, control, dmsgs, I)\n")),(0,r.kt)("h4",{id:"process-seed"},"process-seed"),(0,r.kt)("p",null,"This function initially employs ",(0,r.kt)("inlineCode",{parentName:"p"},"member-view")," to\nidentify the users who were part of the group when the control message was dispatched.\nThen, it attempts to acquire the seed secret through the following steps:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"If the control message was dispatched by the local user,\nit uses the most recent invocation of ",(0,r.kt)("inlineCode",{parentName:"li"},"generate-seed")," stored the seed secret in ",(0,r.kt)("inlineCode",{parentName:"li"},"gamma.nextSeed"),"."),(0,r.kt)("li",{parentName:"ol"},"If the ",(0,r.kt)("inlineCode",{parentName:"li"},"control")," message was dispatched by another user, and\nthe local user is among its recipients,\nthe function utilizes ",(0,r.kt)("inlineCode",{parentName:"li"},"decrypt-from")," to decrypt the direct message\nthat includes the seed secret."),(0,r.kt)("li",{parentName:"ol"},"Otherwise, it returns an ",(0,r.kt)("inlineCode",{parentName:"li"},"ack")," message without deriving an update secret.")),(0,r.kt)("p",null,"Afterwards, ",(0,r.kt)("inlineCode",{parentName:"p"},"process-seed")," generates separate member secrets\nfor each group member from the seed secret by combining the seed secret and\neach user ID using HKDF.\nThe secret for the sender of the message is stored in ",(0,r.kt)("inlineCode",{parentName:"p"},"senderSecret"),",\nwhile those for the other group members are stored in ",(0,r.kt)("inlineCode",{parentName:"p"},"gamma.memberSecret"),".\nThe sender's member secret is immediately utilized to update their KDF ratchet and\ncompute their update secret ",(0,r.kt)("inlineCode",{parentName:"p"},"I_sender")," using ",(0,r.kt)("inlineCode",{parentName:"p"},"update-ratchet"),".\nIf the local user is the sender of the control message,\nthe process is completed, and the update secret is returned.\nHowever, if the seed secret is received from another user,\nan ",(0,r.kt)("inlineCode",{parentName:"p"},"ack")," control message is constructed for broadcast,\nincluding the sender ID and sequence number of the message being acknowledged."),(0,r.kt)("p",null,"The final step computes an update secret ",(0,r.kt)("inlineCode",{parentName:"p"},"I_me"),"\nfor the local user invoking the ",(0,r.kt)("inlineCode",{parentName:"p"},"process-ack")," function."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"recipients = member-view(gamma, sender) - {sender}\nif sender =  gamma.myId then seed = gamma.nextSeed; gamma.nextSeed = empty_string\nelse if  gamma.myId in recipients then (gamma, seed) = decrypt-from(gamma, sender, dmsg)\nelse\nreturn (gamma, (ack, ++gamma.mySeq, (sender, seq)), empty_string , empty_string , empty_string)\n\nfor ID in recipients do gamma.memberSecret[sender, seq, ID] = HKDF(seed, ID)\n\nsenderSecret = HKDF(seed, sender)\n(gamma, I_sender) = update-ratchet(gamma, sender, senderSecret)\nif sender = gamma.myId then return (gamma, empty_string , empty_string , I_sender, empty_string)\ncontrol = (ack, ++gamma.mySeq, (sender, seq))\nmembers = member-view(gamma, gamma.myId)\nforward = empty\nfor ID in {members - (recipients + {sender})}\n s = gamma.memberSecret[sender, seq, gamma.myId]\n (gamma, msg) = encrypt-to(gamma, ID, s)\n forward = forward + {(ID, msg)}\n\n(gamma, _, _, I_me, _) = process-ack(gamma, gamma.myId, gamma.mySeq, (sender, seq), empty_string)\nreturn (gamma, control, forward, I_sender, I_me)\n")),(0,r.kt)("h4",{id:"process-create"},"process-create"),(0,r.kt)("p",null,"This function is called by the sender and\neach of the receivers of the ",(0,r.kt)("inlineCode",{parentName:"p"},"create")," control message.\nFirst, it records the information from the create message\nin the ",(0,r.kt)("inlineCode",{parentName:"p"},"gamma.history+ {op}"),", which is used to track group membership changes.\nThen, it proceeds to call ",(0,r.kt)("inlineCode",{parentName:"p"},"process-seed"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},"op = (\u201dcreate\u201d, sender, seq, IDs)\ngamma.history = gamma.history + {op}\nreturn (process-seed(gamma, sender, seq, dmsg))\n")),(0,r.kt)("h4",{id:"process-ack"},"process-ack"),(0,r.kt)("p",null,"This function is called by those group members once they receive an ack message.\nIn ",(0,r.kt)("inlineCode",{parentName:"p"},"process-ack"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"ackID")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"ackSeq")," are the sender and\nsequence number of the acknowledged message.\nFirstly, if the acknowledged message is a group membership operation,\nit records the acknowledgement in ",(0,r.kt)("inlineCode",{parentName:"p"},"gamma.history"),"."),(0,r.kt)("p",null,"Following this, the function retrieves the relevant member secret from ",(0,r.kt)("inlineCode",{parentName:"p"},"gamma.memberSecret"),",\nwhich was previously obtained from the seed secret\ncontained in the acknowledged message."),(0,r.kt)("p",null,"Finally, it updates the ratchet for the sender of the ",(0,r.kt)("inlineCode",{parentName:"p"},"ack")," and\nreturns the resulting update secret."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'if (ackID, ackSeq) was a create / add / remove then\nop = ("ack", sender, seq, ackID, ackSeq)\ngamma.history = gamma.history + {op}`\ns = gamma.memberSecret[ackID, ackSeq, sender]\ngamma.memberSecret[ackID, ackSeq, sender] = empty_string\nif (s = empty_string) & (dmsg = empty_string) then return (gamma, empty_string, empty_string, empty_string, empty_string)\nif (s = empty_string) then (gamma, s) = decrypt-from(gamma, sender, dmsg)\n(gamma, I) = update-ratchet(gamma, sender, s)\nreturn (gamma, empty_string, empty_string, I, empty_string)\n')),(0,r.kt)("p",null,"The HKDF function MUST follow RFC 5869 using the hash function SHA256."),(0,r.kt)("h3",{id:"post-compromise-security-updates-and-group-member-removal"},"Post-compromise security updates and group member removal"),(0,r.kt)("p",null,"The functions ",(0,r.kt)("inlineCode",{parentName:"p"},"update")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"remove")," share similarities with ",(0,r.kt)("inlineCode",{parentName:"p"},"create"),":\nthey both call the function ",(0,r.kt)("inlineCode",{parentName:"p"},"generate-seed"),"\nto encrypt a new seed secret for each group member.\nThe distinction lies in the determination of the group members using ",(0,r.kt)("inlineCode",{parentName:"p"},"member-view"),".\nIn the case of ",(0,r.kt)("inlineCode",{parentName:"p"},"remove"),",\nthe user being removed is excluded from the recipients of the seed secret.\nAdditionally, the control message they construct is designated with type ",(0,r.kt)("inlineCode",{parentName:"p"},"update"),"\nor ",(0,r.kt)("inlineCode",{parentName:"p"},"remove")," respectively."),(0,r.kt)("p",null,"Likewise, ",(0,r.kt)("inlineCode",{parentName:"p"},"process-update")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"process-remove")," are akin to ",(0,r.kt)("inlineCode",{parentName:"p"},"process-create"),".\nThe function ",(0,r.kt)("inlineCode",{parentName:"p"},"process-update")," skips the update of ",(0,r.kt)("inlineCode",{parentName:"p"},"gamma.history"),",\nwhereas ",(0,r.kt)("inlineCode",{parentName:"p"},"process-remove")," includes a removal operation in the history."),(0,r.kt)("h4",{id:"update"},"update"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'control = ("update", ++gamma.mySeq, empty_string)\nrecipients = member-view(gamma, gamma.myId) - {gamma.myId}\n(gamma, dmsgs) = generate-seed(gamma, recipients)\n(gamma, _, _, I , _) = process-update(gamma, gamma.myId, gamma.mySeq, empty_string, empty_string)\nreturn (gamma, control, dmsgs, I)\n')),(0,r.kt)("h4",{id:"remove"},"remove"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'control = ("remove", ++gamma.mySeq, empty)\nrecipients = member-view(gamma, gamma.myId) - {ID, gamma.myId}\n(gamma, dmsgs) = generate-seed(gamma, recipients)\n(gamma, _, _, I , _) = process-update(gamma, gamma.myId, gamma.mySeq, ID, empty_string)\nreturn (gamma, control, dmsgs, I)\n')),(0,r.kt)("h4",{id:"process-update"},"process-update"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"return process-seed(gamma, sender, seq, dmsg)")),(0,r.kt)("h4",{id:"process-remove"},"process-remove"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'op = ("remove", sender, seq, removed)\ngamma.history = gamma.history + {op}\nreturn process-seed(gamma, sender, seq, dmsg)\n')),(0,r.kt)("h3",{id:"group-member-addition"},"Group member addition"),(0,r.kt)("h4",{id:"add"},"add"),(0,r.kt)("p",null,"When adding a new group member,\nan existing member initiates the process by invoking the ",(0,r.kt)("inlineCode",{parentName:"p"},"add")," function and\nproviding the ID of the user to be added.\nThis function prepares a control message marked as ",(0,r.kt)("inlineCode",{parentName:"p"},"add")," for broadcast to the group.\nSimultaneously, it creates a welcome message intended for the new member\nas a direct message.\nThis ",(0,r.kt)("inlineCode",{parentName:"p"},"welcome")," message includes the current state of the sender's KDF ratchet,\nencrypted using ",(0,r.kt)("inlineCode",{parentName:"p"},"2SM"),",\nalong with the history of group membership operations conducted so far."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'control = ("add", ++gamma.mySeq, ID)\n(gamma, c) = encrypt-to(gamma, ID, gamma.ratchet[gamma.myId])\nop = ("add", gamma.myId, gamma.mySeq, ID)\nwelcome = (gamma.history + {op}, c)\n(gamma, _, _, I, _) = process-add(gamma, gamma.myId, gamma.mySeq, ID, empty_string)\nreturn (gamma, control, (ID, welcome), I)\n')),(0,r.kt)("h4",{id:"process-add"},"process-add"),(0,r.kt)("p",null,"This function is invoked by both the sender and\neach recipient of an ",(0,r.kt)("inlineCode",{parentName:"p"},"add")," message, which includes the new group member.\nIf the local user is the newly added member,\nthe function proceeds to call ",(0,r.kt)("inlineCode",{parentName:"p"},"process-welcome")," and then exits.\nOtherwise, it extends ",(0,r.kt)("inlineCode",{parentName:"p"},"gamma.history")," with the ",(0,r.kt)("inlineCode",{parentName:"p"},"add")," operation."),(0,r.kt)("p",null,"Line 5 determines whether the local user was already a group member\nat the time the ",(0,r.kt)("inlineCode",{parentName:"p"},"add")," message was sent;\nthis condition is typically true but may be false if multiple users were added concurrently."),(0,r.kt)("p",null,"On lines 6 to 8, the ratchet for the sender of the ",(0,r.kt)("em",{parentName:"p"},"add")," message is updated twice.\nIn both calls to ",(0,r.kt)("inlineCode",{parentName:"p"},"update-ratchet"),",\na constant string is used as the ratchet input instead of a random seed secret."),(0,r.kt)("p",null,"The value returned by the first ratchet update is stored in ",(0,r.kt)("inlineCode",{parentName:"p"},"gamma.memberSecret"),"\nas the added user\u2019s initial member secret.\nThe result of the second ratchet update becomes ",(0,r.kt)("inlineCode",{parentName:"p"},"I_sender"),",\nthe update secret for the sender of the ",(0,r.kt)("inlineCode",{parentName:"p"},"add")," message.\nOn line 10, if the local user is the sender, the update secret is returned."),(0,r.kt)("p",null,"If the local user is not the sender, an acknowledgment for the ",(0,r.kt)("inlineCode",{parentName:"p"},"add")," message is required.\nTherefore, on line 11, a control message of type ",(0,r.kt)("inlineCode",{parentName:"p"},"add-ack")," is constructed for broadcast.\nSubsequently, in line 12 the current ratchet state is encrypted using ",(0,r.kt)("inlineCode",{parentName:"p"},"2SM"),"\nto generate a direct message intended for the added user,\nallowing them to decrypt subsequent messages sent by the sender.\nFinally, in lines 13 to 15,\n",(0,r.kt)("inlineCode",{parentName:"p"},"process-add-ack")," is called to calculate the local user\u2019s update secret (",(0,r.kt)("inlineCode",{parentName:"p"},"I_me"),"),\nwhich is then returned along with ",(0,r.kt)("inlineCode",{parentName:"p"},"I_sender"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'if added = gamma.myId then return process-welcome(gamma, sender, seq, dmsg)\nop = ("add", sender, seq, added)\ngamma.history = gamma.history + {op}\nif gamma.myId in member-view(gamma, sender) then\n (gamma, s) = update-ratchet(gamma, sender, "welcome")\n gamma.memberSecret[sender, seq, added] = s\n (gamma, I_sender) = update-ratchet(gamma, sender, "add")\nelse I_sender = empty_string\nif sender = gamma.myId then return (gamma, empty_string, empty_string, I_sender, empty_string)\ncontrol = ("add-ack", ++gamma.mySeq, (sender, seq))\n(gamma, c) = encrypt-to(gamma, added, ratchet[gamma.myId])\n(gamma, _, _, I_me, _) = process-add-ack(gamma, gamma.myId, gamma.mySeq, (sender, seq), empty_string)\nreturn (gamma, control, {(added, c)}, I_sender, I_me)\n')),(0,r.kt)("h4",{id:"process-add-ack"},"process-add-ack"),(0,r.kt)("p",null,"This function is invoked by both the sender and each recipient of an ",(0,r.kt)("inlineCode",{parentName:"p"},"add-ack")," message,\nincluding the new group member.\nUpon lines 1\u20132, the acknowledgment is added to ",(0,r.kt)("inlineCode",{parentName:"p"},"gamma.history"),",\nmirroring the process in ",(0,r.kt)("inlineCode",{parentName:"p"},"process-ack"),".\nIf the current user is the new group member,\nthe ",(0,r.kt)("inlineCode",{parentName:"p"},"add-ack")," message includes the direct message constructed in ",(0,r.kt)("inlineCode",{parentName:"p"},"process-add"),";\nthis direct message contains the encrypted ratchet state of the sender of the ",(0,r.kt)("inlineCode",{parentName:"p"},"add-ack"),",\nthen it is decrypted on lines 3\u20135."),(0,r.kt)("p",null,"Upon line 6,\na check is performed to check if the local user\nwas already a group member at the time the ",(0,r.kt)("inlineCode",{parentName:"p"},"add-ack")," was sent.\nIf affirmative, a new update secret ",(0,r.kt)("inlineCode",{parentName:"p"},"I")," for the sender of the ",(0,r.kt)("inlineCode",{parentName:"p"},"add-ack"),"\nis computed on line 7 by invoking ",(0,r.kt)("inlineCode",{parentName:"p"},"update-ratchet")," with the constant string ",(0,r.kt)("inlineCode",{parentName:"p"},"add"),"."),(0,r.kt)("p",null,"In the scenario involving the new member,\nthe ratchet state was recently initialized on line 5.\nThis ratchet update facilitates all group members, including the new addition,\nto derive each member\u2019s update by obtaining any update secret from before their inclusion."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'op = ("ack", sender, seq, ackID, ackSeq)\ngamma$.history = gamma.history + {op}\nif dmsg != empty_string then\n (gamma, s) = decrypt-from(gamma, sender, dmsg)\n gamma.ratchet[sender] = s\nif gamma.myId in member-view(gamma, sender) then\n (gamma, I) = update-ratchet(gamma, sender, "add")\n return (gamma, empty_string, empty_string, I, empty_string)\nelse return (gamma, empty_string, empty_string, empty_string, empty_string)\n')),(0,r.kt)("h4",{id:"process-welcome"},"process-welcome"),(0,r.kt)("p",null,"This function serves as the second step called by a newly added group member.\nIn this context, ",(0,r.kt)("inlineCode",{parentName:"p"},"adderHistory")," represents the adding user\u2019s copy of ",(0,r.kt)("inlineCode",{parentName:"p"},"gamma.history"),"\nsent in their welcome message,\nwhich is utilized to initialize the added user\u2019s history.\nHere, ",(0,r.kt)("inlineCode",{parentName:"p"},"c")," denotes the ciphertext of the adding user\u2019s ratchet state,\nwhich is decrypted on line 2 using ",(0,r.kt)("inlineCode",{parentName:"p"},"decrypt-from"),"."),(0,r.kt)("p",null,"Once ",(0,r.kt)("inlineCode",{parentName:"p"},"gamma.ratchet[sender]")," is initialized,\n",(0,r.kt)("inlineCode",{parentName:"p"},"update-ratchet")," is invoked twice on lines 3 to 5 with the constant strings ",(0,r.kt)("inlineCode",{parentName:"p"},"welcome"),"\nand ",(0,r.kt)("inlineCode",{parentName:"p"},"add")," respectively.\nThese operations mirror the ratchet operations\nperformed by every other group member in ",(0,r.kt)("inlineCode",{parentName:"p"},"process-add"),".\nThe outcome of the first ",(0,r.kt)("inlineCode",{parentName:"p"},"update-ratchet")," call\nbecomes the first member secret for the added user,\nwhile the second call returns ",(0,r.kt)("inlineCode",{parentName:"p"},"I_sender"),",\nthe update secret for the sender of the add operation."),(0,r.kt)("p",null,"Subsequently, the new group member constructs an ",(0,r.kt)("em",{parentName:"p"},"ack")," control message\nto broadcast on line 6 and\ncalls ",(0,r.kt)("inlineCode",{parentName:"p"},"process-ack")," to compute their initial update secret I_me.\nThe function ",(0,r.kt)("inlineCode",{parentName:"p"},"process-ack")," reads from ",(0,r.kt)("inlineCode",{parentName:"p"},"gamma.memberSecret")," and\npasses it to ",(0,r.kt)("inlineCode",{parentName:"p"},"update-ratchet"),".\nThe previous ratchet state for the new member is the empty string ",(0,r.kt)("inlineCode",{parentName:"p"},"empty"),",\nas established by ",(0,r.kt)("inlineCode",{parentName:"p"},"init"),",\nthereby initializing the new member\u2019s ratchet.\nUpon receiving the new member\u2019s ",(0,r.kt)("inlineCode",{parentName:"p"},"ack"),",\nevery other group member initializes their copy of the new member\u2019s ratchet\nin a similar manner."),(0,r.kt)("p",null,"By the conclusion of ",(0,r.kt)("inlineCode",{parentName:"p"},"process-welcome"),",\nthe new group member has acquired update secrets for themselves and\nthe user who added them.\nThe ratchets for other group members are initialized by ",(0,r.kt)("inlineCode",{parentName:"p"},"process-add-ack"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-go"},'gamma.history = adderHistory\n(gamma, gamma.ratchet[sender]) = decrypt-from(gamma, sender, c)\n(gamma, s) = update-ratchet(gamma, sender, "welcome")\ngamma.memberSecret[sender, seq, gamma.myId] = s\n(gamma, I_sender) = update-ratchet(gamma, sender, "add")\ncontrol = ("ack", ++gamma.mySeq, (sender, seq))\n(gamma, _, _, I_me, _) = process-ack(gamma, gamma.myId, gamma.mySeq, (sender, seq), empty_string)\nreturn (gamma, control, empty_string , I_sender, I_me)\n')),(0,r.kt)("h2",{id:"privacy-considerations"},"Privacy Considerations"),(0,r.kt)("h3",{id:"dependency-on-pki"},"Dependency on PKI"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"https://eprint.iacr.org/2020/1281"},"DCGKA"),"\nproposal presents some limitations highlighted by the authors.\nAmong these limitations one finds the requirement of a PKI\n(or a key server) mapping IDs to public keys."),(0,r.kt)("p",null,"One method to overcome this limitation is adapting the protocol SIWE\n(Sign in with Ethereum) so a user ",(0,r.kt)("inlineCode",{parentName:"p"},"u_1")," who wants to start a communication\nwith a user ",(0,r.kt)("inlineCode",{parentName:"p"},"u_2")," can interact with latter\u2019s wallet to request a public key\nusing an Ethereum address as ",(0,r.kt)("inlineCode",{parentName:"p"},"ID"),"."),(0,r.kt)("h4",{id:"siwe"},"SIWE"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"https://docs.login.xyz/general-information/siwe-overview"},"SIWE"),"\n(Sign In With Ethereum) proposal was a suggested standard for leveraging Ethereum\nto authenticate and authorize users on web3 applications.\nIts goal is to establish a standardized method for users\nto sign in to web3 applications using their Ethereum address and private key,\nmirroring the process by which users currently sign in to web2 applications\nusing their email and password.\nBelow follows the required steps:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"A server generates a unique Nonce for each user intending to sign in."),(0,r.kt)("li",{parentName:"ol"},"A user initiates a request to connect to a website using their wallet."),(0,r.kt)("li",{parentName:"ol"},"The user is presented with a distinctive message that includes the Nonce and\ndetails about the website."),(0,r.kt)("li",{parentName:"ol"},"The user authenticates their identity by signing in with their wallet."),(0,r.kt)("li",{parentName:"ol"},"Upon successful authentication, the user's identity is confirmed or approved."),(0,r.kt)("li",{parentName:"ol"},"The website grants access to data specific to the authenticated user.")),(0,r.kt)("h4",{id:"our-approach"},"Our approach"),(0,r.kt)("p",null,"The idea in the ",(0,r.kt)("a",{parentName:"p",href:"https://eprint.iacr.org/2020/1281"},"DCGKA"),"\nsetting closely resembles the procedure outlined in SIWE. Here:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"The server corresponds to user D1,\nwho initiates a request (instead of generating a nonce)\nto obtain the public key of user D2."),(0,r.kt)("li",{parentName:"ol"},"Upon receiving the request, the wallet of D2 send the request to the user,"),(0,r.kt)("li",{parentName:"ol"},"User D2 receives the request from the wallet, and decides whether accepts or rejects."),(0,r.kt)("li",{parentName:"ol"},"The wallet and responds with a message containing the requested public key\nin case of acceptance by D2.")),(0,r.kt)("p",null,"This message may be signed,\nallowing D1 to verify that the owner of the received public key is indeed D2."),(0,r.kt)("h3",{id:"multi-device-setting"},"Multi-device setting"),(0,r.kt)("p",null,"One may see the set of devices as a group and create a group key for internal communications.\nOne may use treeKEM for instance,\nsince it provides interesting properties like forward secrecy and\npost-compromise security.\nAll devices share the same ",(0,r.kt)("inlineCode",{parentName:"p"},"ID"),",\nwhich is held by one of them, and from other user\u2019s point of view,\nthey would look as a single user."),(0,r.kt)("p",null,"Using servers,\nlike in the paper ",(0,r.kt)("a",{parentName:"p",href:"https://eprint.iacr.org/2019/1363"},"Multi-Device for Signal"),",\nshould be avoided; but this would imply using a particular device as receiver and\nbroadcaster within the group.\nThere is an obvious drawback which is having a single device working as a \u201cserver\u201d.\nShould this device be attacked or without connection,\nthere should be a mechanism for its revocation and replacement."),(0,r.kt)("p",null,"Another approach for communications between devices\ncould be using the keypair of each device.\nThis could open the door to use UPKE, since keypairs should be regenerated frequently."),(0,r.kt)("p",null,"Each time a device sends a message, either an internal message or an external message,\nit needs to replicate and broadcast it to all devices in the group."),(0,r.kt)("p",null,"The mechanism for the substitution of misbehaving leader devices follows:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Each device within a group knows the details of other leader devices.\nThis information may come from metadata in received messages, and\nis replicated by the leader device."),(0,r.kt)("li",{parentName:"ol"},"To replace a leader,\nthe user should select any other device within its group and\nuse it to send a signed message to all other users."),(0,r.kt)("li",{parentName:"ol"},"To get the ability to sign messages,\nthis new leader should request the keypair associated to the ID to the wallet."),(0,r.kt)("li",{parentName:"ol"},"Once the leader has been changed,\nit revocates access from DCGKA to the former leader using the DCGKA protocol."),(0,r.kt)("li",{parentName:"ol"},"The new leader starts a key update in DCGKA.")),(0,r.kt)("p",null,"Not all devices in a group should be able to send messages to other users.\nOnly the leader device should be in charge of sending and receiving messages.\nTo prevent other devices from sending messages outside their group,\na requirement should be signing each message.\nThe keys associated to the ",(0,r.kt)("inlineCode",{parentName:"p"},"ID")," should only be in control of the leader device."),(0,r.kt)("p",null,"The leader device is in charge of setting the keys involved in the DCGKA.\nThis information must be replicated within the group to make sure it is updated."),(0,r.kt)("p",null,"To detect missing messages or potential misbehavior, messages must include a counter."),(0,r.kt)("h3",{id:"using-upke"},"Using UPKE"),(0,r.kt)("p",null,"Managing the group of devices of a user can be done either\nusing a group key protocol such as treeKEM or\nusing the keypair of each device.\nSetting a common key for a group of devices\nunder the control of the same actor might be excessive,\nfurthermore it may imply some of the problems one can find\nin the usual setting of a group of different users;\nfor example: one of the devices may not participate in the required updating processes,\nrepresenting a threat for the group."),(0,r.kt)("p",null,"The other approach to managing the group of devices is using each device\u2019s keypair,\nbut it would require each device updating these materia frequently,\nsomething that may not happens."),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://eprint.iacr.org/2022/068"},"UPKE")," is a form of asymetric cryptography\nwhere any user can update any other user\u2019s key pair\nby running an update algorithm with (high-entropy) private coins.\nAny sender can initiate a ",(0,r.kt)("em",{parentName:"p"},"key update")," by sending a special update ciphertext.\nThis ciphertext updates the receiver\u2019s public key and also,\nonce processed by the receiver, will update their secret key."),(0,r.kt)("p",null,"To the best of my knowledge,\nthere exists several efficient constructions both ",(0,r.kt)("a",{parentName:"p",href:"https://eprint.iacr.org/2019/1189"},"UPKE from ElGamal"),"\n(based in the DH assumption) and\n",(0,r.kt)("a",{parentName:"p",href:"(https://eprint.iacr.org/2023/1400)"},"UPKE from Lattices")," (based in lattices).\nNone of them have been implemented in a secure messaging protocol, and\nthis opens the door to some novel research."),(0,r.kt)("h2",{id:"copyright"},"Copyright"),(0,r.kt)("p",null,"Copyright and related rights waived via ",(0,r.kt)("a",{parentName:"p",href:"https://creativecommons.org/publicdomain/zero/1.0/"},"CC0"),"."),(0,r.kt)("h2",{id:"references"},"References"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://eprint.iacr.org/2020/1281"},"DCGKA")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://messaginglayersecurity.rocks"},"MLS")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://eprint.iacr.org/2022/251"},"CoCoa")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://mattweidner.com/assets/pdf/acs-dissertation.pdf"},"Causal TreeKEM")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://docs.login.xyz/general-information/siwe-overview"},"SIWE")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://eprint.iacr.org/2019/1363"},"Multi-device for Signal")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://eprint.iacr.org/2022/068"},"UPKE")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://eprint.iacr.org/2019/1189"},"UPKE from ElGamal")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://eprint.iacr.org/2023/1400"},"UPKE from Lattices"))))}p.isMDXComponent=!0},3905:(e,t,n)=>{n.d(t,{Zo:()=>l,kt:()=>h});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var m=a.createContext({}),d=function(e){var t=a.useContext(m),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},l=function(e){var t=d(e.components);return a.createElement(m.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,m=e.parentName,l=o(e,["components","mdxType","originalType","parentName"]),c=d(n),h=r,u=c["".concat(m,".").concat(h)]||c[h]||p[h]||i;return n?a.createElement(u,s(s({ref:t},l),{},{components:n})):a.createElement(u,s({ref:t},l))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,s=new Array(i);s[0]=c;var o={};for(var m in t)hasOwnProperty.call(t,m)&&(o[m]=t[m]);o.originalType=e,o.mdxType="string"==typeof e?e:r,s[1]=o;for(var d=2;d<i;d++)s[d]=n[d];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"}}]);