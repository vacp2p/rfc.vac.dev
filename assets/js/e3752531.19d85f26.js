"use strict";(self.webpackChunklogos_docs_template=self.webpackChunklogos_docs_template||[]).push([[1176],{63254:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>s,metadata:()=>o,toc:()=>p});var n=a(87462),i=(a(67294),a(3905));const s={title:"SDS",name:"Scalable Data Sync protocol for distributed logs",status:"raw",editor:"Hanno Cornelius &lt;hanno@status.im&gt;",contributors:["Akhil Peddireddy &lt;akhil@status.im&gt;"]},r=void 0,o={unversionedId:"raw/sds",id:"raw/sds",title:"SDS",description:"- Status: raw",source:"@site/vac/raw/sds.md",sourceDirName:"raw",slug:"/raw/sds",permalink:"/vac/raw/sds",draft:!1,tags:[],version:"current",frontMatter:{title:"SDS",name:"Scalable Data Sync protocol for distributed logs",status:"raw",editor:"Hanno Cornelius &lt;hanno@status.im&gt;",contributors:["Akhil Peddireddy &lt;akhil@status.im&gt;"]},sidebar:"defaultSidebar",previous:{title:"RLN-V2",permalink:"/vac/raw/rln-v2"},next:{title:"1/COSS",permalink:"/vac/1/coss"}},l={},p=[{value:"Abstract",id:"abstract",level:2},{value:"Motivation",id:"motivation",level:2},{value:"Design Assumptions",id:"design-assumptions",level:2},{value:"Wire protocol",id:"wire-protocol",level:2},{value:"Message",id:"message",level:3},{value:"Participant state",id:"participant-state",level:3},{value:"Protocol Steps",id:"protocol-steps",level:3},{value:"Send Message",id:"send-message",level:4},{value:"Receive Message",id:"receive-message",level:4},{value:"Deliver Message",id:"deliver-message",level:4},{value:"Resolve Conflicts",id:"resolve-conflicts",level:4},{value:"Review ACK Status",id:"review-ack-status",level:4},{value:"Periodic Incoming Buffer Sweep",id:"periodic-incoming-buffer-sweep",level:4},{value:"Periodic Outgoing Buffer Sweep",id:"periodic-outgoing-buffer-sweep",level:4},{value:"Periodic Sync Message",id:"periodic-sync-message",level:4},{value:"Ephemeral Messages",id:"ephemeral-messages",level:4},{value:"Copyright",id:"copyright",level:2}],c={toc:p};function m(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},c,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Status: raw"),(0,i.kt)("li",{parentName:"ul"},"Editor: Hanno Cornelius ","<",(0,i.kt)("a",{parentName:"li",href:"mailto:hanno@status.im"},"hanno@status.im"),">"),(0,i.kt)("li",{parentName:"ul"},"Contributors:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Akhil Peddireddy ","<",(0,i.kt)("a",{parentName:"li",href:"mailto:akhil@status.im"},"akhil@status.im"),">")))),(0,i.kt)("h2",{id:"abstract"},"Abstract"),(0,i.kt)("p",null,"This specification introduces the Scalable Data Sync (SDS) protocol\nto achieve end-to-end reliability\nwhen consolidating distributed logs in a decentralized manner.\nThe protocol is designed for a peer-to-peer (p2p) topology\nwhere an append-only log is maintained by each member of a group of nodes\nwho may individually append new entries to their local log at any time and\nis interested in merging new entries from other nodes in real-time or close to real-time\nwhile maintaining a consistent order.\nThe outcome of the log consolidation procedure is\nthat all nodes in the group eventually reflect in their own logs\nthe same entries in the same order.\nThe protocol aims to scale to very large groups."),(0,i.kt)("h2",{id:"motivation"},"Motivation"),(0,i.kt)("p",null,"A common application that fits this model is a p2p group chat (or group communication),\nwhere the participants act as log nodes\nand the group conversation is modelled as the consolidated logs\nmaintained on each node.\nThe problem of end-to-end reliability can then be stated as\nensuring that all participants eventually see the same sequence of messages\nin the same causal order,\ndespite the challenges of network latency, message loss,\nand scalability present in any communications transport layer.\nThe rest of this document will assume the terminology of a group communication:\nlog nodes being the ",(0,i.kt)("em",{parentName:"p"},"participants")," in the group chat\nand the logged entries being the ",(0,i.kt)("em",{parentName:"p"},"messages")," exchanged between participants."),(0,i.kt)("h2",{id:"design-assumptions"},"Design Assumptions"),(0,i.kt)("p",null,"We make the following simplifying assumptions for a proposed reliability protocol:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Broadcast routing:"),"\nMessages are broadcast disseminated by the underlying transport.\nThe selected transport takes care of routing messages\nto all participants of the communication."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Store nodes:"),"\nThere are high-availability caches (a.k.a. Store nodes)\nfrom which missed messages can be retrieved.\nThese caches maintain the full history of all messages that have been broadcast.\nThis is an optional element in the protocol design,\nbut improves scalability by reducing direct interactions between participants."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Message ID:"),"\nEach message has a globally unique, immutable ID (or hash).\nMessages can be requested from the high-availability caches or\nother participants using the corresponding message ID.")),(0,i.kt)("h2",{id:"wire-protocol"},"Wire protocol"),(0,i.kt)("p",null,"The keywords \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d,\n\u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and\n\u201cOPTIONAL\u201d in this document are to be interpreted as described in ",(0,i.kt)("a",{parentName:"p",href:"https://www.ietf.org/rfc/rfc2119.txt"},"2119"),"."),(0,i.kt)("h3",{id:"message"},"Message"),(0,i.kt)("p",null,"Messages MUST adhere to the following meta structure:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-protobuf"},'syntax = "proto3";\n\nmessage Message {\n  // 1 Reserved for sender/participant id\n  string message_id = 2;          // Unique identifier of the message\n  string channel_id = 3;          // Identifier of the channel to which the message belongs\n  optional int32 lamport_timestamp = 10;    // Logical timestamp for causal ordering in channel\n  repeated string causal_history = 11;  // List of preceding message IDs that this message causally depends on. Generally 2 or 3 message IDs are included.\n  optional bytes bloom_filter = 12;         // Bloom filter representing received message IDs in channel\n  optional bytes content = 20;             // Actual content of the message\n}\n')),(0,i.kt)("p",null,"Each message MUST include its globally unique identifier in the ",(0,i.kt)("inlineCode",{parentName:"p"},"message_id")," field,\nlikely based on a message hash.\nThe ",(0,i.kt)("inlineCode",{parentName:"p"},"channel_id")," field MUST be set to the identifier of the channel of group communication\nthat is being synchronized.\nFor simple group communications without individual channels,\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"channel_id")," SHOULD be set to ",(0,i.kt)("inlineCode",{parentName:"p"},"0"),".\nThe ",(0,i.kt)("inlineCode",{parentName:"p"},"lamport_timestamp"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"causal_history")," and\n",(0,i.kt)("inlineCode",{parentName:"p"},"bloom_filter")," fields MUST be set according to the ",(0,i.kt)("a",{parentName:"p",href:"#protocol-steps"},"protocol steps"),"\nset out below.\nThese fields MAY be left unset in the case of ",(0,i.kt)("a",{parentName:"p",href:"#ephemeral-messages"},"ephemeral messages"),".\nThe message ",(0,i.kt)("inlineCode",{parentName:"p"},"content")," MAY be left empty for ",(0,i.kt)("a",{parentName:"p",href:"#periodic-sync-message"},"periodic sync messages"),",\notherwise it MUST contain the application-level content"),(0,i.kt)("h3",{id:"participant-state"},"Participant state"),(0,i.kt)("p",null,"Each participant MUST maintain:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"A Lamport timestamp for each channel of communication,\ninitialized to current epoch time in nanosecond resolution."),(0,i.kt)("li",{parentName:"ul"},"A bloom filter for received message IDs per channel.\nThe bloom filter SHOULD be rolled over and\nrecomputed once it reaches a predefined capacity of message IDs.\nFurthermore,\nit SHOULD be designed to minimize false positives through an optimal selection of\nsize and hash functions."),(0,i.kt)("li",{parentName:"ul"},"A buffer for unacknowledged outgoing messages"),(0,i.kt)("li",{parentName:"ul"},"A buffer for incoming messages with unmet causal dependencies"),(0,i.kt)("li",{parentName:"ul"},"A local log (or history) for each channel,\ncontaining all message IDs in the communication channel,\nordered by Lamport timestamp.")),(0,i.kt)("p",null,"Messages in the unacknowledged outgoing buffer can be in one of three states:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Unacknowledged")," - there has been no acknowledgement of message receipt\nby any participant in the channel"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Possibly acknowledged")," - there has been ambiguous indication that the message\nhas been ",(0,i.kt)("em",{parentName:"li"},"possibly")," received by at least one participant in the channel"),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Acknowledged")," - there has been sufficient indication that the message\nhas been received by at least some of the participants in the channel.\nThis state will also remove the message from the outgoing buffer.")),(0,i.kt)("h3",{id:"protocol-steps"},"Protocol Steps"),(0,i.kt)("p",null,"For each channel of communication,\nparticipants MUST follow these protocol steps to populate and interpret\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"lamport_timestamp"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"causal_history")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"bloom_filter")," fields."),(0,i.kt)("h4",{id:"send-message"},"Send Message"),(0,i.kt)("p",null,"Before broadcasting a message:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"the participant MUST increase its local Lamport timestamp by ",(0,i.kt)("inlineCode",{parentName:"li"},"1")," and\ninclude this in the ",(0,i.kt)("inlineCode",{parentName:"li"},"lamport_timestamp")," field."),(0,i.kt)("li",{parentName:"ul"},"the participant MUST determine the preceding few message IDs in the local history\nand include these in an ordered list in the ",(0,i.kt)("inlineCode",{parentName:"li"},"causal_history")," field.\nThe number of message IDs to include in the ",(0,i.kt)("inlineCode",{parentName:"li"},"causal_history")," depends on the application.\nWe recommend a causal history of two message IDs."),(0,i.kt)("li",{parentName:"ul"},"the participant MUST include the current ",(0,i.kt)("inlineCode",{parentName:"li"},"bloom_filter"),"\nstate in the broadcast message.")),(0,i.kt)("p",null,"After broadcasting a message,\nthe message MUST be added to the participant\u2019s buffer\nof unacknowledged outgoing messages."),(0,i.kt)("h4",{id:"receive-message"},"Receive Message"),(0,i.kt)("p",null,"Upon receiving a message,"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"the participant MUST ",(0,i.kt)("a",{parentName:"li",href:"#review-ack-status"},"review the ACK status")," of messages\nin its unacknowledged outgoing buffer\nusing the received message's causal history and bloom filter."),(0,i.kt)("li",{parentName:"ul"},"if the message has a populated ",(0,i.kt)("inlineCode",{parentName:"li"},"content")," field,\nthe participant MUST include the received message ID in its local bloom filter."),(0,i.kt)("li",{parentName:"ul"},"the participant MUST verify that all causal dependencies are met\nfor the received message.\nDependencies are met if the message IDs in the ",(0,i.kt)("inlineCode",{parentName:"li"},"causal_history")," of the received message\nappear in the local history of the receiving participant.")),(0,i.kt)("p",null,"If all dependencies are met and the message has a populated ",(0,i.kt)("inlineCode",{parentName:"p"},"content")," field,\nthe participant MUST ",(0,i.kt)("a",{parentName:"p",href:"#deliver-message"},"deliver the message"),".\nIf dependencies are unmet,\nthe participant MUST add the message to the incoming buffer of messages\nwith unmet causal dependencies."),(0,i.kt)("h4",{id:"deliver-message"},"Deliver Message"),(0,i.kt)("p",null,"Triggered by the ",(0,i.kt)("a",{parentName:"p",href:"#receive-message"},"Receive Message")," procedure."),(0,i.kt)("p",null,"If the received message\u2019s Lamport timestamp is greater than the participant's\nlocal Lamport timestamp,\nthe participant MUST update its local Lamport timestamp to match the received message.\nThe participant MUST insert the message ID into its local log,\nbased on Lamport timestamp.\nIf one or more message IDs with the same Lamport timestamp already exists,\nthe participant MUST follow the ",(0,i.kt)("a",{parentName:"p",href:"#resolve-conflicts"},"Resolve Conflicts")," procedure."),(0,i.kt)("h4",{id:"resolve-conflicts"},"Resolve Conflicts"),(0,i.kt)("p",null,"Triggered by the ",(0,i.kt)("a",{parentName:"p",href:"#deliver-message"},"Deliver Message")," procedure."),(0,i.kt)("p",null,"The participant MUST order messages with the same Lamport timestamp\nin ascending order of message ID.\nIf the message ID is implemented as a hash of the message,\nthis means the message with the lowest hash would precede\nother messages with the same Lamport timestamp in the local log."),(0,i.kt)("h4",{id:"review-ack-status"},"Review ACK Status"),(0,i.kt)("p",null,"Triggered by the ",(0,i.kt)("a",{parentName:"p",href:"#receive-message"},"Receive Message")," procedure."),(0,i.kt)("p",null,"For each message in the unacknowledged outgoing buffer,\nbased on the received ",(0,i.kt)("inlineCode",{parentName:"p"},"bloom_filter")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"causal_history"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"the participant MUST mark all messages in the received ",(0,i.kt)("inlineCode",{parentName:"li"},"causal_history")," as ",(0,i.kt)("strong",{parentName:"li"},"acknowledged"),"."),(0,i.kt)("li",{parentName:"ul"},"the participant MUST mark all messages included in the ",(0,i.kt)("inlineCode",{parentName:"li"},"bloom_filter"),"\nas ",(0,i.kt)("strong",{parentName:"li"},"possibly acknowledged"),".\nIf a message appears as ",(0,i.kt)("strong",{parentName:"li"},"possibly acknowledged")," in multiple received bloom filters,\nthe participant MAY mark it as acknowledged based on probabilistic grounds,\ntaking into account the bloom filter size and hash number.")),(0,i.kt)("h4",{id:"periodic-incoming-buffer-sweep"},"Periodic Incoming Buffer Sweep"),(0,i.kt)("p",null,"The participant MUST periodically check causal dependencies for each message\nin the incoming buffer.\nFor each message in the incoming buffer:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"the participant MAY attempt to retrieve missing dependencies from the Store node\n(high-availability cache) or other peers."),(0,i.kt)("li",{parentName:"ul"},"if all dependencies of a message are met,\nthe participant MUST proceed to ",(0,i.kt)("a",{parentName:"li",href:"#deliver-message"},"deliver the message"),".")),(0,i.kt)("p",null,"If a message's causal dependencies have failed to be met\nafter a predetermined amount of time,\nthe participant MAY mark them as ",(0,i.kt)("strong",{parentName:"p"},"irretrievably lost"),"."),(0,i.kt)("h4",{id:"periodic-outgoing-buffer-sweep"},"Periodic Outgoing Buffer Sweep"),(0,i.kt)("p",null,"The participant MUST rebroadcast ",(0,i.kt)("strong",{parentName:"p"},"unacknowledged")," outgoing messages\nafter a set period.\nThe participant SHOULD use distinct resend periods for ",(0,i.kt)("strong",{parentName:"p"},"unacknowledged")," and\n",(0,i.kt)("strong",{parentName:"p"},"possibly acknowledged")," messages,\nprioritizing ",(0,i.kt)("strong",{parentName:"p"},"unacknowledged")," messages."),(0,i.kt)("h4",{id:"periodic-sync-message"},"Periodic Sync Message"),(0,i.kt)("p",null,"For each channel of communication,\nparticipants SHOULD periodically send sync messages to maintain state.\nThese sync messages:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"MUST be sent with empty content"),(0,i.kt)("li",{parentName:"ul"},"MUST include an incremented Lamport timestamp"),(0,i.kt)("li",{parentName:"ul"},"MUST include causal history and bloom filter according to regular message rules"),(0,i.kt)("li",{parentName:"ul"},"MUST NOT be added to the unacknowledged outgoing buffer"),(0,i.kt)("li",{parentName:"ul"},"MUST NOT be included in causal histories of subsequent messages"),(0,i.kt)("li",{parentName:"ul"},"MUST NOT be included in bloom filters"),(0,i.kt)("li",{parentName:"ul"},"MUST NOT be added to the local log")),(0,i.kt)("p",null,"Since sync messages are not persisted,\nthey MAY have non-unique message IDs without impacting the protocol.\nTo avoid network activity bursts in large groups,\na participant MAY choose to only send periodic sync messages\nif no other messages have been broadcast in the channel after a random backoff period."),(0,i.kt)("p",null,"Participants MUST process the causal history and bloom filter of these sync messages\nfollowing the same steps as regular messages,\nbut MUST NOT persist the sync messages themselves."),(0,i.kt)("h4",{id:"ephemeral-messages"},"Ephemeral Messages"),(0,i.kt)("p",null,"Participants MAY choose to send short-lived messages for which no synchronization\nor reliability is required.\nThese messages are termed ",(0,i.kt)("em",{parentName:"p"},"ephemeral"),"."),(0,i.kt)("p",null,"Ephemeral messages SHOULD be sent with ",(0,i.kt)("inlineCode",{parentName:"p"},"lamport_timestamp"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"causal_history"),", and\n",(0,i.kt)("inlineCode",{parentName:"p"},"bloom_filter")," unset.\nEphemeral messages SHOULD NOT be added to the unacknowledged outgoing buffer\nafter broadcast.\nUpon reception,\nephemeral messages SHOULD be delivered immediately without buffering for causal dependencies\nor including in the local log."),(0,i.kt)("h2",{id:"copyright"},"Copyright"),(0,i.kt)("p",null,"Copyright and related rights waived via ",(0,i.kt)("a",{parentName:"p",href:"https://creativecommons.org/publicdomain/zero/1.0/"},"CC0"),"."))}m.isMDXComponent=!0},3905:(e,t,a)=>{a.d(t,{Zo:()=>c,kt:()=>h});var n=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var l=n.createContext({}),p=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,s=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),d=p(a),h=i,u=d["".concat(l,".").concat(h)]||d[h]||m[h]||s;return a?n.createElement(u,r(r({ref:t},c),{},{components:a})):n.createElement(u,r({ref:t},c))}));function h(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var s=a.length,r=new Array(s);r[0]=d;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:i,r[1]=o;for(var p=2;p<s;p++)r[p]=a[p];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"}}]);