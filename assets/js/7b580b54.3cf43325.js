"use strict";(self.webpackChunklogos_docs_template=self.webpackChunklogos_docs_template||[]).push([[952],{26514:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>m,contentTitle:()=>s,default:()=>l,frontMatter:()=>i,metadata:()=>o,toc:()=>p});var a=n(87462),r=(n(67294),n(3905));const i={title:"ETH-DCGKA",name:"Decentralized Key and Session Setup for Secure Messaging over Ethereum",status:"raw",category:"informational",editor:"Ramses Fernandez-Valencia &lt;ramses@status.im&gt;",contributors:null},s=void 0,o={unversionedId:"raw/decentralized-messaging-ethereum",id:"raw/decentralized-messaging-ethereum",title:"ETH-DCGKA",description:"- Status: raw",source:"@site/vac/raw/decentralized-messaging-ethereum.md",sourceDirName:"raw",slug:"/raw/decentralized-messaging-ethereum",permalink:"/vac/raw/decentralized-messaging-ethereum",draft:!1,tags:[],version:"current",frontMatter:{title:"ETH-DCGKA",name:"Decentralized Key and Session Setup for Secure Messaging over Ethereum",status:"raw",category:"informational",editor:"Ramses Fernandez-Valencia &lt;ramses@status.im&gt;",contributors:null},sidebar:"defaultSidebar",previous:{title:"ETH-SECPM",permalink:"/vac/raw/deleted/eth-secpm"},next:{title:"ETH-MLS-OFFCHAIN",permalink:"/vac/raw/eth-mls-offchain"}},m={},p=[{value:"Abstract",id:"abstract",level:2},{value:"Motivation",id:"motivation",level:2},{value:"Theory",id:"theory",level:2},{value:"Protocol overview",id:"protocol-overview",level:3},{value:"Components of the protocol",id:"components-of-the-protocol",level:3},{value:"Authenticated causal broadcast",id:"authenticated-causal-broadcast",level:4},{value:"Decentralized group membership",id:"decentralized-group-membership",level:4},{value:"2-party secure messaging (2SM)",id:"2-party-secure-messaging-2sm",level:4},{value:"Function 2SM-Init",id:"function-2sm-init",level:5},{value:"Function 2SM-Send",id:"function-2sm-send",level:5},{value:"Function 2SM-Receive",id:"function-2sm-receive",level:5},{value:"Function 2SM Syntax",id:"function-2sm-syntax",level:4},{value:"2SM-Init",id:"2sm-init",level:4},{value:"2SM-Send",id:"2sm-send",level:4},{value:"2SM-Receive",id:"2sm-receive",level:4},{value:"PKE Syntax",id:"pke-syntax",level:3},{value:"Parameters",id:"parameters",level:4},{value:"PKE-KGen",id:"pke-kgen",level:4},{value:"PKE-Enc",id:"pke-enc",level:4},{value:"PKE-Dec",id:"pke-dec",level:4},{value:"DCGKA Syntax",id:"dcgka-syntax",level:3},{value:"Auxiliary functions",id:"auxiliary-functions",level:4},{value:"init",id:"init",level:4},{value:"encrypt-to",id:"encrypt-to",level:4},{value:"decrypt-from",id:"decrypt-from",level:4},{value:"update-ratchet",id:"update-ratchet",level:4},{value:"member-view",id:"member-view",level:4},{value:"generate-seed",id:"generate-seed",level:4},{value:"Creation of a group",id:"creation-of-a-group",level:3},{value:"create",id:"create",level:4},{value:"process-seed",id:"process-seed",level:4},{value:"process-create",id:"process-create",level:4},{value:"process-ack",id:"process-ack",level:4},{value:"Post-compromise security updates and group member removal",id:"post-compromise-security-updates-and-group-member-removal",level:3},{value:"update",id:"update",level:4},{value:"remove",id:"remove",level:4},{value:"process-update",id:"process-update",level:4},{value:"process-remove",id:"process-remove",level:4},{value:"Group member addition",id:"group-member-addition",level:3},{value:"add",id:"add",level:4},{value:"process-add",id:"process-add",level:4},{value:"process-add-ack",id:"process-add-ack",level:4},{value:"process-welcome",id:"process-welcome",level:4},{value:"Privacy Considerations",id:"privacy-considerations",level:2},{value:"Dependency on PKI",id:"dependency-on-pki",level:3},{value:"SIWE",id:"siwe",level:4},{value:"Our approach",id:"our-approach",level:4},{value:"Multi-device setting",id:"multi-device-setting",level:3},{value:"Using UPKE",id:"using-upke",level:3},{value:"Copyright",id:"copyright",level:2},{value:"References",id:"references",level:2}],d={toc:p};function l(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Status: raw"),(0,r.kt)("li",{parentName:"ul"},"Category: informational"),(0,r.kt)("li",{parentName:"ul"},"Editor: Ramses Fernandez-Valencia ","<",(0,r.kt)("a",{parentName:"li",href:"mailto:ramses@status.im"},"ramses@status.im"),">")),(0,r.kt)("h2",{id:"abstract"},"Abstract"),(0,r.kt)("p",null,"This document introduces a decentralized group messaging protocol\nusing Ethereum adresses as identifiers.\nIt is based in the proposal\n",(0,r.kt)("a",{parentName:"p",href:"https://eprint.iacr.org/2020/1281"},"DCGKA")," by Weidner et al.\nIt includes also approximations to overcome limitations related to using PKI and\nthe multi-device setting."),(0,r.kt)("h2",{id:"motivation"},"Motivation"),(0,r.kt)("p",null,"The need for secure communications has become paramount.\nTraditional centralized messaging protocols are susceptible to various security\nthreats, including unauthorized access, data breaches, and single points of\nfailure.\nTherefore a decentralized approach to secure communication becomes increasingly\nrelevant, offering a robust solution to address these challenges."),(0,r.kt)("p",null,"Secure messaging protocols used should have the following key features:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Asynchronous Messaging:")," Users can send messages even if the recipients\nare not online at the moment.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Resilience to Compromise:")," If a user's security is compromised,\nthe protocol ensures that previous messages remain secure through forward\nsecrecy (FS). This means that messages sent before the compromise cannot be\ndecrypted by adversaries. Additionally, the protocol maintains post-compromise\nsecurity (PCS) by regularly updating keys, making it difficult for adversaries\nto decrypt future communication.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"Dynamic Group Management:")," Users can easily add or remove group members\nat any time, reflecting the flexible nature of communication within the app."))),(0,r.kt)("p",null,"In this field, there exists a ",(0,r.kt)("em",{parentName:"p"},"trilemma"),", similar to what one observes in\nblockchain, involving three key aspects:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"security,"),(0,r.kt)("li",{parentName:"ol"},"scalability, and"),(0,r.kt)("li",{parentName:"ol"},"decentralization.")),(0,r.kt)("p",null,"For instance, protocols like the ",(0,r.kt)("a",{parentName:"p",href:"https://messaginglayersecurity.rocks"},"MLS"),"\nperform well in terms of scalability and security.\nHowever, they falls short in decentralization."),(0,r.kt)("p",null,"Newer studies such as ",(0,r.kt)("a",{parentName:"p",href:"https://eprint.iacr.org/2022/251"},"CoCoa"),"\nimprove features related to security and scalability,\nbut they still rely on servers, which may not be fully trusted though they are necessary."),(0,r.kt)("p",null,"On the other hand,\nolder studies like ",(0,r.kt)("a",{parentName:"p",href:"https://mattweidner.com/assets/pdf/acs-dissertation.pdf"},"Causal TreeKEM"),"\nexhibit decent scalability (logarithmic)\nbut lack forward secrecy and have weak post-compromise security (PCS)."),(0,r.kt)("p",null,"The creators of ",(0,r.kt)("a",{parentName:"p",href:"https://eprint.iacr.org/2020/1281"},"DCGKA")," introduce a decentralized,\nasynchronous secure group messaging protocol that supports dynamic groups.\nThis protocol operates effectively on various underlying networks\nwithout strict requirements on message ordering or latency.\nIt can be implemented in peer-to-peer or anonymity networks,\naccommodating network partitions, high latency links, and\ndisconnected operation seamlessly.\nNotably, the protocol doesn't rely on servers or\na consensus protocol for its functionality."),(0,r.kt)("p",null,"This proposal provides end-to-end encryption with forward secrecy and\npost-compromise security,\neven when multiple users concurrently modify the group state."),(0,r.kt)("h2",{id:"theory"},"Theory"),(0,r.kt)("h3",{id:"protocol-overview"},"Protocol overview"),(0,r.kt)("p",null,"This protocol makes use of ratchets to provide FS\nby encrypting each message with a different key."),(0,r.kt)("p",null,"In the figure one can see the ratchet for encrypting a sequence of messages.\nThe sender requires an initial update secret ",(0,r.kt)("inlineCode",{parentName:"p"},"I_1"),", which is introduced in a PRG.\nThe PRG will produce two outputs, namely a symmetric key for AEAD encryption, and\na seed for the next ratchet state.\nThe associated data needed in the AEAD encryption includes the message index ",(0,r.kt)("inlineCode",{parentName:"p"},"i"),".\nThe ciphertext ",(0,r.kt)("inlineCode",{parentName:"p"},"c_i")," associated to message ",(0,r.kt)("inlineCode",{parentName:"p"},"m_i"),"\nis then broadcasted to all group members.\nThe next step requires deleting ",(0,r.kt)("inlineCode",{parentName:"p"},"I_1"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"k_i")," and any old ratchet state."),(0,r.kt)("p",null,"After a period of time the sender may replace the ratchet state with new update secrets\n",(0,r.kt)("inlineCode",{parentName:"p"},"I_2"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"I_3"),", and so on."),(0,r.kt)("p",null,"To start a post-compromise security update,\na user creates a new random value known as a seed secret and\nshares it with every other group member through a secure two-party channel.\nUpon receiving the seed secret,\neach group member uses it to calculate an update secret for both the sender's ratchet\nand their own.\nAdditionally, the recipient sends an unencrypted acknowledgment to the group\nconfirming the update.\nEvery member who receives the acknowledgment updates\nnot only the ratchet for the original sender but\nalso the ratchet for the sender of the acknowledgment.\nConsequently, after sharing the seed secret through ",(0,r.kt)("inlineCode",{parentName:"p"},"n - 1")," two-party messages and\nconfirming it with ",(0,r.kt)("inlineCode",{parentName:"p"},"n - 1")," broadcast acknowledgments,\nevery group member has derived an update secret and updated their ratchet accordingly."),(0,r.kt)("p",null,"When removing a group member,\nthe user who initiates the removal conducts a post-compromise security update\nby sending the update secret to all group members except the one being removed.\nTo add a new group member,\neach existing group member shares the necessary state with the new user,\nenabling them to derive their future update secrets."),(0,r.kt)("p",null,"Since group members may receive messages in various orders,\nit's important to ensure that each sender's ratchet is updated consistently\nwith the same sequence of update secrets at each group member."),(0,r.kt)("p",null,"The network protocol used in this scheme ensures that messages from the same sender\nare processed in the order they were sent."),(0,r.kt)("h3",{id:"components-of-the-protocol"},"Components of the protocol"),(0,r.kt)("p",null,"This protocol relies in 3 components:\nauthenticated causal broadcast (ACB),\ndecentralized group membership (DGM) and\n2-party secure messaging (2SM)."),(0,r.kt)("h4",{id:"authenticated-causal-broadcast"},"Authenticated causal broadcast"),(0,r.kt)("p",null,"A causal order is a partial order relation ",(0,r.kt)("inlineCode",{parentName:"p"},"<")," on messages.\nTwo messages ",(0,r.kt)("inlineCode",{parentName:"p"},"m_1")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"m_2")," are causally ordered, or\n",(0,r.kt)("inlineCode",{parentName:"p"},"m_1")," causally precedes ",(0,r.kt)("inlineCode",{parentName:"p"},"m_2"),"\n(denoted by ",(0,r.kt)("inlineCode",{parentName:"p"},"m_1 < m_2"),"), if one of the following contiditions hold:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"m_1")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"m_2")," were sent by the same group member, and\n",(0,r.kt)("inlineCode",{parentName:"li"},"m_1")," was sent before ",(0,r.kt)("inlineCode",{parentName:"li"},"m_2"),"."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("inlineCode",{parentName:"li"},"m_2")," was sent by a group member U, and ",(0,r.kt)("inlineCode",{parentName:"li"},"m_1")," was received and\nprocessed by ",(0,r.kt)("inlineCode",{parentName:"li"},"U")," before sending ",(0,r.kt)("inlineCode",{parentName:"li"},"m_2"),"."),(0,r.kt)("li",{parentName:"ol"},"There exists ",(0,r.kt)("inlineCode",{parentName:"li"},"m_3")," such that ",(0,r.kt)("inlineCode",{parentName:"li"},"m_1 < m_3")," and ",(0,r.kt)("inlineCode",{parentName:"li"},"m_3 < m_2"),".")),(0,r.kt)("p",null,"Causal broadcast requires that before processing ",(0,r.kt)("inlineCode",{parentName:"p"},"m"),", a group member must\nprocess all preceding messages ",(0,r.kt)("inlineCode",{parentName:"p"},"{m' | m' < m}"),"."),(0,r.kt)("p",null,"The causal broadcast module used in this protocol authenticates the sender of\neach message, as well as its causal ordering metadata, using a digital\nsignature under the sender\u2019s identity key.\nThis prevents a passive adversary from impersonating users or affecting\ncausally ordered delivery."),(0,r.kt)("h4",{id:"decentralized-group-membership"},"Decentralized group membership"),(0,r.kt)("p",null,"This protocol assumes the existence of a decentralized group membership\nfunction (denoted as DGM) that takes a set of membership change messages and\ntheir causal order relantionships, and returns the current set of group\nmembers\u2019 IDs. It needs to be deterministic and depend only on causal order, and\nnot exact order."),(0,r.kt)("h4",{id:"2-party-secure-messaging-2sm"},"2-party secure messaging (2SM)"),(0,r.kt)("p",null,"This protocol makes use of bidirectional 2-party secure messaging schemes,\nwhich consist of 3 algorithms: ",(0,r.kt)("inlineCode",{parentName:"p"},"2SM-Init"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"2SM-Send")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"2SM-Receive"),"."),(0,r.kt)("h5",{id:"function-2sm-init"},"Function 2SM-Init"),(0,r.kt)("p",null,"This function takes two IDs as inputs:\n",(0,r.kt)("inlineCode",{parentName:"p"},"ID1")," representing the local user and ",(0,r.kt)("inlineCode",{parentName:"p"},"ID2")," representing the other party.\nIt returns an initial protocol state ",(0,r.kt)("inlineCode",{parentName:"p"},"sigma"),".\nThe 2SM protocol relies on a Public Key Infrastructure (PKI) or\na key server to map these IDs to their corresponding public keys.\nIn practice, the PKI should incorporate ephemeral prekeys.\nThis allows users to send messages to a new group member,\neven if that member is currently offline."),(0,r.kt)("h5",{id:"function-2sm-send"},"Function 2SM-Send"),(0,r.kt)("p",null,"This function takes a state ",(0,r.kt)("inlineCode",{parentName:"p"},"sigma")," and a plaintext ",(0,r.kt)("inlineCode",{parentName:"p"},"m")," as inputs, and returns\na new state ",(0,r.kt)("inlineCode",{parentName:"p"},"sigma\u2019")," and a ciphertext ",(0,r.kt)("inlineCode",{parentName:"p"},"c"),"."),(0,r.kt)("h5",{id:"function-2sm-receive"},"Function 2SM-Receive"),(0,r.kt)("p",null,"This function takes a state ",(0,r.kt)("inlineCode",{parentName:"p"},"sigma")," and a ciphertext ",(0,r.kt)("inlineCode",{parentName:"p"},"c"),", and\nreturns a new state ",(0,r.kt)("inlineCode",{parentName:"p"},"sigma\u2019")," and a plaintext ",(0,r.kt)("inlineCode",{parentName:"p"},"m"),"."),(0,r.kt)("p",null,"This function takes a state ",(0,r.kt)("inlineCode",{parentName:"p"},"sigma")," and a ciphertext ",(0,r.kt)("inlineCode",{parentName:"p"},"c"),", and returns a new\nstate ",(0,r.kt)("inlineCode",{parentName:"p"},"sigma\u2019")," and a plaintext ",(0,r.kt)("inlineCode",{parentName:"p"},"m"),"."),(0,r.kt)("h4",{id:"function-2sm-syntax"},"Function 2SM Syntax"),(0,r.kt)("p",null,"The variable ",(0,r.kt)("inlineCode",{parentName:"p"},"sigma")," denotes the state consisting in the variables below:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},"sigma.mySks[0] = sk\nsigma.nextIndex = 1 \nsigma.receivedSk = empty_string\nsigma.otherPk = pk`<br/> \nsigma.otherPksender = \u201cother\u201d\nsigma.otherPkIndex = 0\n\n")),(0,r.kt)("h4",{id:"2sm-init"},"2SM-Init"),(0,r.kt)("p",null,"On input a key pair ",(0,r.kt)("inlineCode",{parentName:"p"},"(sk, pk)"),", this functions otuputs a state ",(0,r.kt)("inlineCode",{parentName:"p"},"sigma"),"."),(0,r.kt)("h4",{id:"2sm-send"},"2SM-Send"),(0,r.kt)("p",null,"This function encrypts the message ",(0,r.kt)("inlineCode",{parentName:"p"},"m")," using ",(0,r.kt)("inlineCode",{parentName:"p"},"sigma.otherPk"),", which represents\nthe other party\u2019s current public key.\nThis key is determined based on the last public key generated for the other\nparty or the last public key received from the other party,\nwhichever is more recent. ",(0,r.kt)("inlineCode",{parentName:"p"},"sigma.otherPkSender")," is set to ",(0,r.kt)("inlineCode",{parentName:"p"},"me")," in the former\ncase and ",(0,r.kt)("inlineCode",{parentName:"p"},"other")," in the latter case."),(0,r.kt)("p",null,"Metadata including ",(0,r.kt)("inlineCode",{parentName:"p"},"otherPkSender")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"otherPkIndex")," are included in the\nmessage to indicate which of the recipient\u2019s public keys is being utilized."),(0,r.kt)("p",null,"Additionally, this function generates a new key pair for the local user,\nstoring the secret key in ",(0,r.kt)("inlineCode",{parentName:"p"},"sigma.mySks")," and sending the public key.\nSimilarly, it generates a new key pair for the other party,\nsending the secret key (encrypted) and storing the public key in\n",(0,r.kt)("inlineCode",{parentName:"p"},"sigma.otherPk"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},'sigma.mySks[sigma.nextIndex], myNewPk) = PKE-Gen()\n(otherNewSk, otherNewPk) = PKE-Gen()\nplaintext = (m, otherNewSk, sigma`.nextIndex, myNewPk)\nmsg = (PKE-Enc(sigma.otherPk, plaintext), sigma.otherPkSender, sigma.otherPkIndex)\nsigma.nextIndex++\n(sigma.otherPk, sigma.otherPkSender, sigma.otherPkIndex) = (otherNewPk, "me", empty_string)\nreturn (sigma`, msg)\n\n')),(0,r.kt)("h4",{id:"2sm-receive"},"2SM-Receive"),(0,r.kt)("p",null,"This function utilizes the metadata of the message ",(0,r.kt)("inlineCode",{parentName:"p"},"c")," to determine which\nsecret key to utilize for decryption, assigning it to ",(0,r.kt)("inlineCode",{parentName:"p"},"sk"),".\nIf the secret key corresponds to one generated by ourselves,\nthat secret key along with all keys with lower index are deleted.\nThis deletion is indicated by ",(0,r.kt)("inlineCode",{parentName:"p"},"sigma.mySks[\u2264 keyIndex] = empty_string"),".\nSubsequently, the new public and secret keys contained in the message are\nstored."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},'(ciphertext, keySender, keyIndex) = c\nif keySender = "other" then \nsk = sigma.mySks[keyIndex] \nsigma.mySks[\u2264 keyIndex] = empty_string\nelse sk = sigma.receivedSk\n(m, sigma.receivedSk, sigma.otherPkIndex, sigma.otherPk) = PKE-Dec(sk, ciphertext)\nsigma.otherPkSender = "other"\nreturn (sigma, m)\n\n')),(0,r.kt)("h3",{id:"pke-syntax"},"PKE Syntax"),(0,r.kt)("p",null,"The required PKE that MUST be used is ElGamal with a 2048-bit modulus ",(0,r.kt)("inlineCode",{parentName:"p"},"p"),"."),(0,r.kt)("h4",{id:"parameters"},"Parameters"),(0,r.kt)("p",null,"The following parameters must be used:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},"p = 308920927247127345254346920820166145569\ng = 2\n\n")),(0,r.kt)("h4",{id:"pke-kgen"},"PKE-KGen"),(0,r.kt)("p",null,"Each user ",(0,r.kt)("inlineCode",{parentName:"p"},"u")," MUST do the following:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},"PKE-KGen():\na = randint(2, p-2)\npk = (p, g, g^a)\nsk = a\nreturn (pk, sk)\n\n")),(0,r.kt)("h4",{id:"pke-enc"},"PKE-Enc"),(0,r.kt)("p",null,"A user ",(0,r.kt)("inlineCode",{parentName:"p"},"v")," encrypting a message ",(0,r.kt)("inlineCode",{parentName:"p"},"m")," for ",(0,r.kt)("inlineCode",{parentName:"p"},"u")," MUST follow these steps:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},"PKE-Enc(pk):\nk = randint(2, p-2)\neta = g^k % p\ndelta = m * (g^a)^k % p\nreturn ((eta, delta))\n\n")),(0,r.kt)("h4",{id:"pke-dec"},"PKE-Dec"),(0,r.kt)("p",null,"The user ",(0,r.kt)("inlineCode",{parentName:"p"},"u")," recovers a message ",(0,r.kt)("inlineCode",{parentName:"p"},"m")," from a ciphertext ",(0,r.kt)("inlineCode",{parentName:"p"},"c"),"\nby performing the following operations:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},"PKE-Dec(sk):\nmu = eta^(p-1-sk) % p\nreturn ((mu * delta) % p)\n\n")),(0,r.kt)("h3",{id:"dcgka-syntax"},"DCGKA Syntax"),(0,r.kt)("h4",{id:"auxiliary-functions"},"Auxiliary functions"),(0,r.kt)("p",null,"There exist 6 functions that are auxiliary for the rest of components of the\nprotocol, namely:"),(0,r.kt)("h4",{id:"init"},"init"),(0,r.kt)("p",null,"This function takes an ",(0,r.kt)("inlineCode",{parentName:"p"},"ID")," as input and returns its associated initial state,\ndenoted by ",(0,r.kt)("inlineCode",{parentName:"p"},"gamma"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},"gamma.myId = ID\ngamma.mySeq = 0\ngamma.history = empty\ngamma.nextSeed = empty_string\ngamma.2sm[\xb7] = empty_string\ngamma.memberSecret[\xb7, \xb7, \xb7] = empty_string\ngamma.ratchet[\xb7] = empty_string\nreturn (gamma)\n\n")),(0,r.kt)("h4",{id:"encrypt-to"},"encrypt-to"),(0,r.kt)("p",null,"Upon reception of the recipient\u2019s ",(0,r.kt)("inlineCode",{parentName:"p"},"ID")," and a plaintext, it encrypts a direct\nmessage for another group member.\nShould it be the first message for a particular ",(0,r.kt)("inlineCode",{parentName:"p"},"ID"),",\nthen the ",(0,r.kt)("inlineCode",{parentName:"p"},"2SM")," protocol state is initialized and stored in\n",(0,r.kt)("inlineCode",{parentName:"p"},"gamma.2sm[recipient.ID]"),".\nOne then uses ",(0,r.kt)("inlineCode",{parentName:"p"},"2SM_Send")," to encrypt the message and store the updated protocol\nin ",(0,r.kt)("inlineCode",{parentName:"p"},"gamma"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},"if gamma.2sm[recipient_ID] = empty_string then\n gamma.2sm[recipient_ID] = 2SM_Init(gamma.myID, recipient_ID)\n(gamma.2sm[recipient_ID], ciphertext) = 2SM_Send(gamma.2sm[recipient_ID], plaintext)\nreturn (gamma, ciphertext)\n\n")),(0,r.kt)("h4",{id:"decrypt-from"},"decrypt-from"),(0,r.kt)("p",null,"After receiving the sender\u2019s ",(0,r.kt)("inlineCode",{parentName:"p"},"ID")," and a ciphertext, it behaves as the reverse\nfunction of ",(0,r.kt)("inlineCode",{parentName:"p"},"encrypt-to")," and has a similar initialization:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},"if gamma.2sm[sender_ID] = empty_string then\ngamma.2sm[sender_ID] = 2SM_Init(gamma.myID, sender_ID)\n(gamma.2sm[sender_ID], plaintext) = 2SM_Receive(gamma.2sm[sender_ID], ciphertext)\nreturn (gamma, plaintext)\n\n")),(0,r.kt)("h4",{id:"update-ratchet"},"update-ratchet"),(0,r.kt)("p",null,"This function generates the next update secret ",(0,r.kt)("inlineCode",{parentName:"p"},"I_update")," for the group member\n",(0,r.kt)("inlineCode",{parentName:"p"},"ID"),".\nThe ratchet state is stored in ",(0,r.kt)("inlineCode",{parentName:"p"},"gamma.ratchet[ID]"),".\nIt is required to use a HMAC-based key derivation function HKDF to combine the\nratchet state with an input, returning an update secret and a new ratchet\nstate."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},"(updateSecret, gamma.ratchet[ID]) = HKDF(gamma.ratchet[ID], input)\nreturn (gamma, updateSecret)\n\n")),(0,r.kt)("h4",{id:"member-view"},"member-view"),(0,r.kt)("p",null,"This function calculates the set of group members\nbased on the most recent control message sent by the specified user ",(0,r.kt)("inlineCode",{parentName:"p"},"ID"),".\nIt filters the group membership operations\nto include only those observed by the specified ",(0,r.kt)("inlineCode",{parentName:"p"},"ID"),", and\nthen invokes the DGM function to generate the group membership."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},"ops = {m in gamma.history st. m was sent or acknowledged by ID}\nreturn DGM(ops)\n\n")),(0,r.kt)("h4",{id:"generate-seed"},"generate-seed"),(0,r.kt)("p",null,"This functions generates a random bit string and\nsends it encrypted to each member of the group using the ",(0,r.kt)("inlineCode",{parentName:"p"},"2SM")," mechanism.\nIt returns the updated protocol state and\nthe set of direct messages (denoted as ",(0,r.kt)("inlineCode",{parentName:"p"},"dmsgs"),") to send."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},"gamma.nextSeed = random.randbytes()\ndmsgs = empty\nfor each ID in recipients:\n(gamma, msg) = encrypt-to(gamma, ID, gamma.nextSeed)\ndmsgs = dmsgs + (ID, msg)\nreturn (gamma, dmsgs)\n\n")),(0,r.kt)("h3",{id:"creation-of-a-group"},"Creation of a group"),(0,r.kt)("p",null,"A group is generated in a 3 steps procedure:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"A user calls the ",(0,r.kt)("inlineCode",{parentName:"li"},"create")," function and broadcasts a control message of type\n",(0,r.kt)("em",{parentName:"li"},"create"),"."),(0,r.kt)("li",{parentName:"ol"},"Each receiver of the message processes the message and broadcasts an ",(0,r.kt)("em",{parentName:"li"},"ack"),"\ncontrol message."),(0,r.kt)("li",{parentName:"ol"},"Each member processes the ",(0,r.kt)("em",{parentName:"li"},"ack")," message received.")),(0,r.kt)("h4",{id:"create"},"create"),(0,r.kt)("p",null,"This function generates a ",(0,r.kt)("em",{parentName:"p"},"create")," control message and calls ",(0,r.kt)("inlineCode",{parentName:"p"},"generate-seed")," to\ndefine the set of direct messages that need to be sent.\nThen it calls ",(0,r.kt)("inlineCode",{parentName:"p"},"process-create")," to process the control message for this user.\nThe function ",(0,r.kt)("inlineCode",{parentName:"p"},"process-create")," returns a tuple including an updated state gamma\nand an update secret ",(0,r.kt)("inlineCode",{parentName:"p"},"I"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},"control = (\u201ccreate\u201d, gamma.mySeq, IDs)\n(gamma, dmsgs) = generate-seed(gamma, IDs)\n(gamma, _, _, I, _) = process-create(gamma, gamma.myId, gamma.mySeq, IDs, empty_string)\nreturn (gamma, control, dmsgs, I)\n\n")),(0,r.kt)("h4",{id:"process-seed"},"process-seed"),(0,r.kt)("p",null,"This function initially employs ",(0,r.kt)("inlineCode",{parentName:"p"},"member-view")," to identify the users who were\npart of the group when the control message was dispatched.\nThen, it attempts to acquire the seed secret through the following steps:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"If the control message was dispatched by the local user, it uses the most\nrecent invocation of ",(0,r.kt)("inlineCode",{parentName:"li"},"generate-seed")," stored the seed secret in\n",(0,r.kt)("inlineCode",{parentName:"li"},"gamma.nextSeed"),"."),(0,r.kt)("li",{parentName:"ol"},"If the ",(0,r.kt)("inlineCode",{parentName:"li"},"control")," message was dispatched by another user, and the local user\nis among its recipients, the function utilizes ",(0,r.kt)("inlineCode",{parentName:"li"},"decrypt-from")," to decrypt the\ndirect message that includes the seed secret."),(0,r.kt)("li",{parentName:"ol"},"Otherwise, it returns an ",(0,r.kt)("inlineCode",{parentName:"li"},"ack")," message without deriving an update secret.")),(0,r.kt)("p",null,"Afterwards, ",(0,r.kt)("inlineCode",{parentName:"p"},"process-seed")," generates separate member secrets for each group\nmember from the seed secret by combining the seed secret and\neach user ID using HKDF.\nThe secret for the sender of the message is stored in ",(0,r.kt)("inlineCode",{parentName:"p"},"senderSecret"),", while\nthose for the other group members are stored in ",(0,r.kt)("inlineCode",{parentName:"p"},"gamma.memberSecret"),".\nThe sender's member secret is immediately utilized to update their KDF ratchet\nand compute their update secret ",(0,r.kt)("inlineCode",{parentName:"p"},"I_sender")," using ",(0,r.kt)("inlineCode",{parentName:"p"},"update-ratchet"),".\nIf the local user is the sender of the control message, the process is\ncompleted, and the update secret is returned.\nHowever, if the seed secret is received from another user, an ",(0,r.kt)("inlineCode",{parentName:"p"},"ack")," control\nmessage is constructed for broadcast, including the sender ID and sequence\nnumber of the message being acknowledged."),(0,r.kt)("p",null,"The final step computes an update secret ",(0,r.kt)("inlineCode",{parentName:"p"},"I_me")," for the local user invoking the\n",(0,r.kt)("inlineCode",{parentName:"p"},"process-ack")," function."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},"recipients = member-view(gamma, sender) - {sender}\nif sender =  gamma.myId then seed = gamma.nextSeed; gamma.nextSeed =\nempty_string\nelse if  gamma.myId in recipients then (gamma, seed) = decrypt-from(gamma,\nsender, dmsg)\nelse\nreturn (gamma, (ack, ++gamma.mySeq, (sender, seq)), empty_string ,\nempty_string , empty_string)\n\nfor ID in recipients do gamma.memberSecret[sender, seq, ID] = HKDF(seed, ID)\nsenderSecret = HKDF(seed, sender)\n(gamma, I_sender) = update-ratchet(gamma, sender, senderSecret)\nif sender = gamma.myId then return (gamma, empty_string , empty_string ,\nI_sender, empty_string)\ncontrol = (ack, ++gamma.mySeq, (sender, seq))\nmembers = member-view(gamma, gamma.myId)\nforward = empty\nfor ID in {members - (recipients + {sender})}\n    s = gamma.memberSecret[sender, seq, gamma.myId]\n    (gamma, msg) = encrypt-to(gamma, ID, s)\n    forward = forward + {(ID, msg)}\n    (gamma, _, _, I_me, _) = process-ack(gamma, gamma.myId, gamma.mySeq, \n    (sender, seq), empty_string)\n    return (gamma, control, forward, I_sender, I_me)\n\n")),(0,r.kt)("h4",{id:"process-create"},"process-create"),(0,r.kt)("p",null,"This function is called by the sender and each of the receivers of the ",(0,r.kt)("inlineCode",{parentName:"p"},"create"),"\ncontrol message.\nFirst, it records the information from the create message in the\n",(0,r.kt)("inlineCode",{parentName:"p"},"gamma.history+ {op}"),", which is used to track group membership changes. Then,\nit proceeds to call ",(0,r.kt)("inlineCode",{parentName:"p"},"process-seed"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},"op = (\u201dcreate\u201d, sender, seq, IDs)\ngamma.history = gamma.history + {op}\nreturn (process-seed(gamma, sender, seq, dmsg))\n\n")),(0,r.kt)("h4",{id:"process-ack"},"process-ack"),(0,r.kt)("p",null,"This function is called by those group members once they receive an ack\nmessage.\nIn ",(0,r.kt)("inlineCode",{parentName:"p"},"process-ack"),", ",(0,r.kt)("inlineCode",{parentName:"p"},"ackID")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"ackSeq")," are the sender and sequence number of\nthe acknowledged message.\nFirstly, if the acknowledged message is a group membership operation, it\nrecords the acknowledgement in ",(0,r.kt)("inlineCode",{parentName:"p"},"gamma.history"),"."),(0,r.kt)("p",null,"Following this, the function retrieves the relevant member secret from\n",(0,r.kt)("inlineCode",{parentName:"p"},"gamma.memberSecret"),", which was previously obtained from the seed secret\ncontained in the acknowledged message."),(0,r.kt)("p",null,"Finally, it updates the ratchet for the sender of the ",(0,r.kt)("inlineCode",{parentName:"p"},"ack")," and returns the\nresulting update secret."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},'if (ackID, ackSeq) was a create / add / remove then\nop = ("ack", sender, seq, ackID, ackSeq)\ngamma.history = gamma.history + {op}`\ns = gamma.memberSecret[ackID, ackSeq, sender]\ngamma.memberSecret[ackID, ackSeq, sender] = empty_string\nif (s = empty_string) & (dmsg = empty_string) then return (gamma, empty_string,\nempty_string, empty_string, empty_string)\nif (s = empty_string) then (gamma, s) = decrypt-from(gamma, sender, dmsg)\n(gamma, I) = update-ratchet(gamma, sender, s)\nreturn (gamma, empty_string, empty_string, I, empty_string)\n\n')),(0,r.kt)("p",null,"The HKDF function MUST follow RFC 5869 using the hash function SHA256."),(0,r.kt)("h3",{id:"post-compromise-security-updates-and-group-member-removal"},"Post-compromise security updates and group member removal"),(0,r.kt)("p",null,"The functions ",(0,r.kt)("inlineCode",{parentName:"p"},"update")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"remove")," share similarities with ",(0,r.kt)("inlineCode",{parentName:"p"},"create"),":\nthey both call the function ",(0,r.kt)("inlineCode",{parentName:"p"},"generate-seed")," to encrypt a new seed secret for\neach group member.\nThe distinction lies in the determination of the group members using ",(0,r.kt)("inlineCode",{parentName:"p"},"member\nview"),".\nIn the case of ",(0,r.kt)("inlineCode",{parentName:"p"},"remove"),", the user being removed is excluded from the recipients\nof the seed secret.\nAdditionally, the control message they construct is designated with type\n",(0,r.kt)("inlineCode",{parentName:"p"},"update")," or ",(0,r.kt)("inlineCode",{parentName:"p"},"remove")," respectively."),(0,r.kt)("p",null,"Likewise, ",(0,r.kt)("inlineCode",{parentName:"p"},"process-update")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"process-remove")," are akin to ",(0,r.kt)("inlineCode",{parentName:"p"},"process-create"),".\nThe function ",(0,r.kt)("inlineCode",{parentName:"p"},"process-update")," skips the update of ",(0,r.kt)("inlineCode",{parentName:"p"},"gamma.history"),",\nwhereas ",(0,r.kt)("inlineCode",{parentName:"p"},"process-remove")," includes a removal operation in the history."),(0,r.kt)("h4",{id:"update"},"update"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},'control = ("update", ++gamma.mySeq, empty_string)\nrecipients = member-view(gamma, gamma.myId) - {gamma.myId}\n(gamma, dmsgs) = generate-seed(gamma, recipients)\n(gamma, _, _, I , _) = process-update(gamma, gamma.myId, gamma.mySeq,\nempty_string, empty_string)\nreturn (gamma, control, dmsgs, I)\n\n')),(0,r.kt)("h4",{id:"remove"},"remove"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},'control = ("remove", ++gamma.mySeq, empty)\nrecipients = member-view(gamma, gamma.myId) - {ID, gamma.myId}\n(gamma, dmsgs) = generate-seed(gamma, recipients)\n(gamma, _, _, I , _) = process-update(gamma, gamma.myId, gamma.mySeq, ID,\nempty_string)\nreturn (gamma, control, dmsgs, I)\n\n')),(0,r.kt)("h4",{id:"process-update"},"process-update"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"return process-seed(gamma, sender, seq, dmsg)")),(0,r.kt)("h4",{id:"process-remove"},"process-remove"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},'op = ("remove", sender, seq, removed)\ngamma.history = gamma.history + {op}\nreturn process-seed(gamma, sender, seq, dmsg)\n\n')),(0,r.kt)("h3",{id:"group-member-addition"},"Group member addition"),(0,r.kt)("h4",{id:"add"},"add"),(0,r.kt)("p",null,"When adding a new group member, an existing member initiates the process by\ninvoking the ",(0,r.kt)("inlineCode",{parentName:"p"},"add")," function and providing the ID of the user to be added.\nThis function prepares a control message marked as ",(0,r.kt)("inlineCode",{parentName:"p"},"add")," for broadcast to the\ngroup. Simultaneously, it creates a welcome message intended for the new member\nas a direct message.\nThis ",(0,r.kt)("inlineCode",{parentName:"p"},"welcome")," message includes the current state of the sender's KDF ratchet,\nencrypted using ",(0,r.kt)("inlineCode",{parentName:"p"},"2SM"),", along with the history of group membership operations\nconducted so far."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},'control = ("add", ++gamma.mySeq, ID)\n(gamma, c) = encrypt-to(gamma, ID, gamma.ratchet[gamma.myId])\nop = ("add", gamma.myId, gamma.mySeq, ID)\nwelcome = (gamma.history + {op}, c)\n(gamma, _, _, I, _) = process-add(gamma, gamma.myId, gamma.mySeq, ID, empty_string)\nreturn (gamma, control, (ID, welcome), I)\n\n')),(0,r.kt)("h4",{id:"process-add"},"process-add"),(0,r.kt)("p",null,"This function is invoked by both the sender and each recipient of an ",(0,r.kt)("inlineCode",{parentName:"p"},"add"),"\nmessage, which includes the new group member. If the local user is the newly\nadded member, the function proceeds to call ",(0,r.kt)("inlineCode",{parentName:"p"},"process-welcome")," and then exits.\nOtherwise, it extends ",(0,r.kt)("inlineCode",{parentName:"p"},"gamma.history")," with the ",(0,r.kt)("inlineCode",{parentName:"p"},"add")," operation."),(0,r.kt)("p",null,"Line 5 determines whether the local user was already a group member at the time\nthe ",(0,r.kt)("inlineCode",{parentName:"p"},"add")," message was sent; this condition is typically true but may be false\nif multiple users were added concurrently."),(0,r.kt)("p",null,"On lines 6 to 8, the ratchet for the sender of the ",(0,r.kt)("em",{parentName:"p"},"add")," message is updated\ntwice. In both calls to ",(0,r.kt)("inlineCode",{parentName:"p"},"update-ratchet"),", a constant string is used as the\nratchet input instead of a random seed secret."),(0,r.kt)("p",null,"The value returned by the first ratchet update is stored in\n",(0,r.kt)("inlineCode",{parentName:"p"},"gamma.memberSecret")," as the added user\u2019s initial member secret. The result of\nthe second ratchet update becomes ",(0,r.kt)("inlineCode",{parentName:"p"},"I_sender"),", the update secret for the sender\nof the ",(0,r.kt)("inlineCode",{parentName:"p"},"add")," message. On line 10, if the local user is the sender, the update\nsecret is returned."),(0,r.kt)("p",null,"If the local user is not the sender, an acknowledgment for the ",(0,r.kt)("inlineCode",{parentName:"p"},"add")," message is\nrequired.\nTherefore, on line 11, a control message of type ",(0,r.kt)("inlineCode",{parentName:"p"},"add-ack")," is constructed for\nbroadcast.\nSubsequently, in line 12 the current ratchet state is encrypted using ",(0,r.kt)("inlineCode",{parentName:"p"},"2SM")," to\ngenerate a direct message intended for the added user, allowing them to decrypt\nsubsequent messages sent by the sender.\nFinally, in lines 13 to 15, ",(0,r.kt)("inlineCode",{parentName:"p"},"process-add-ack")," is called to calculate the local\nuser\u2019s update secret (",(0,r.kt)("inlineCode",{parentName:"p"},"I_me"),"), which is then returned along with ",(0,r.kt)("inlineCode",{parentName:"p"},"I_sender"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},'if added = gamma.myId then return process-welcome(gamma, sender, seq, dmsg)\nop = ("add", sender, seq, added)\ngamma.history = gamma.history + {op}\nif gamma.myId in member-view(gamma, sender) then\n    (gamma, s) = update-ratchet(gamma, sender, "welcome")\n    gamma.memberSecret[sender, seq, added] = s\n    (gamma, I_sender) = update-ratchet(gamma, sender, "add")\n    else I_sender = empty_string\n    if sender = gamma.myId then return (gamma, empty_string, empty_string,\n    I_sender, empty_string)\n    control = ("add-ack", ++gamma.mySeq, (sender, seq))\n    (gamma, c) = encrypt-to(gamma, added, ratchet[gamma.myId])\n    (gamma, _, _, I_me, _) = process-add-ack(gamma, gamma.myId, gamma.mySeq,\n    (sender, seq), empty_string)\n    return (gamma, control, {(added, c)}, I_sender, I_me)\n\n')),(0,r.kt)("h4",{id:"process-add-ack"},"process-add-ack"),(0,r.kt)("p",null,"This function is invoked by both the sender and each recipient of an ",(0,r.kt)("inlineCode",{parentName:"p"},"add-ack"),"\nmessage, including the new group member. Upon lines 1\u20132, the acknowledgment is\nadded to ",(0,r.kt)("inlineCode",{parentName:"p"},"gamma.history"),", mirroring the process in ",(0,r.kt)("inlineCode",{parentName:"p"},"process-ack"),".\nIf the current user is the new group member, the ",(0,r.kt)("inlineCode",{parentName:"p"},"add-ack")," message includes the\ndirect message constructed in ",(0,r.kt)("inlineCode",{parentName:"p"},"process-add"),"; this direct message contains the\nencrypted ratchet state of the sender of the ",(0,r.kt)("inlineCode",{parentName:"p"},"add-ack"),", then it is decrypted on\nlines 3\u20135."),(0,r.kt)("p",null,"Upon line 6, a check is performed to check if the local user was already a\ngroup member at the time the ",(0,r.kt)("inlineCode",{parentName:"p"},"add-ack")," was sent. If affirmative, a new update\nsecret ",(0,r.kt)("inlineCode",{parentName:"p"},"I")," for the sender of the ",(0,r.kt)("inlineCode",{parentName:"p"},"add-ack")," is computed on line 7 by invoking\n",(0,r.kt)("inlineCode",{parentName:"p"},"update-ratchet")," with the constant string ",(0,r.kt)("inlineCode",{parentName:"p"},"add"),"."),(0,r.kt)("p",null,"In the scenario involving the new member,  the ratchet state was recently\ninitialized on line 5. This ratchet update facilitates all group members,\nincluding the new addition, to derive each member\u2019s update by obtaining any\nupdate secret from before their inclusion."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},'op = ("ack", sender, seq, ackID, ackSeq)\ngamma$.history = gamma.history + {op}\nif dmsg != empty_string then\n    (gamma, s) = decrypt-from(gamma, sender, dmsg)\n    gamma.ratchet[sender] = s\nif gamma.myId in member-view(gamma, sender) then\n    (gamma, I) = update-ratchet(gamma, sender, "add")\n    return (gamma, empty_string, empty_string, I, empty_string)\nelse return (gamma, empty_string, empty_string, empty_string, empty_string)\n\n')),(0,r.kt)("h4",{id:"process-welcome"},"process-welcome"),(0,r.kt)("p",null,"This function serves as the second step called by a newly added group member.\nIn this context, ",(0,r.kt)("inlineCode",{parentName:"p"},"adderHistory")," represents the adding user\u2019s copy of\n",(0,r.kt)("inlineCode",{parentName:"p"},"gamma.history")," sent in their welcome message, which is utilized to initialize\nthe added user\u2019s history.\nHere, ",(0,r.kt)("inlineCode",{parentName:"p"},"c")," denotes the ciphertext of the adding user\u2019s ratchet state, which is\ndecrypted on line 2 using ",(0,r.kt)("inlineCode",{parentName:"p"},"decrypt-from"),"."),(0,r.kt)("p",null,"Once ",(0,r.kt)("inlineCode",{parentName:"p"},"gamma.ratchet[sender]")," is initialized, ",(0,r.kt)("inlineCode",{parentName:"p"},"update-ratchet")," is invoked twice\non lines 3 to 5 with the constant strings ",(0,r.kt)("inlineCode",{parentName:"p"},"welcome")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"add")," respectively.\nThese operations mirror the ratchet operations performed by every other group\nmember in ",(0,r.kt)("inlineCode",{parentName:"p"},"process-add"),".\nThe outcome of the first ",(0,r.kt)("inlineCode",{parentName:"p"},"update-ratchet")," call becomes the first member secret\nfor the added user,\nwhile the second call returns ",(0,r.kt)("inlineCode",{parentName:"p"},"I_sender"),", the update secret for the sender of\nthe add operation."),(0,r.kt)("p",null,"Subsequently, the new group member constructs an ",(0,r.kt)("em",{parentName:"p"},"ack")," control message to\nbroadcast on line 6 and calls ",(0,r.kt)("inlineCode",{parentName:"p"},"process-ack")," to compute their initial update\nsecret I_me. The function ",(0,r.kt)("inlineCode",{parentName:"p"},"process-ack")," reads from ",(0,r.kt)("inlineCode",{parentName:"p"},"gamma.memberSecret")," and\npasses it to ",(0,r.kt)("inlineCode",{parentName:"p"},"update-ratchet"),". The previous ratchet state for the new member is\nthe empty string ",(0,r.kt)("inlineCode",{parentName:"p"},"empty"),", as established by ",(0,r.kt)("inlineCode",{parentName:"p"},"init"),", thereby initializing the\nnew member\u2019s ratchet.\nUpon receiving the new member\u2019s ",(0,r.kt)("inlineCode",{parentName:"p"},"ack"),", every other group member initializes\ntheir copy of the new member\u2019s ratchet in a similar manner."),(0,r.kt)("p",null,"By the conclusion of ",(0,r.kt)("inlineCode",{parentName:"p"},"process-welcome"),", the new group member has acquired\nupdate secrets for themselves and the user who added them.\nThe ratchets for other group members are initialized by ",(0,r.kt)("inlineCode",{parentName:"p"},"process-add-ack"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-text"},'gamma.history = adderHistory\n(gamma, gamma.ratchet[sender]) = decrypt-from(gamma, sender, c)\n(gamma, s) = update-ratchet(gamma, sender, "welcome")\ngamma.memberSecret[sender, seq, gamma.myId] = s\n(gamma, I_sender) = update-ratchet(gamma, sender, "add")\ncontrol = ("ack", ++gamma.mySeq, (sender, seq))\n(gamma, _, _, I_me, _) = process-ack(gamma, gamma.myId, gamma.mySeq, (sender,\nseq), empty_string)\nreturn (gamma, control, empty_string , I_sender, I_me)\n\n')),(0,r.kt)("h2",{id:"privacy-considerations"},"Privacy Considerations"),(0,r.kt)("h3",{id:"dependency-on-pki"},"Dependency on PKI"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"https://eprint.iacr.org/2020/1281"},"DCGKA")," proposal presents some\nlimitations highlighted by the authors.\nAmong these limitations one finds the requirement of a PKI (or a key server)\nmapping IDs to public keys."),(0,r.kt)("p",null,"One method to overcome this limitation is adapting the protocol SIWE (Sign in\nwith Ethereum) so a user ",(0,r.kt)("inlineCode",{parentName:"p"},"u_1")," who wants to start a communication with a user\n",(0,r.kt)("inlineCode",{parentName:"p"},"u_2")," can interact with latter\u2019s wallet to request a public key using an\nEthereum address as ",(0,r.kt)("inlineCode",{parentName:"p"},"ID"),"."),(0,r.kt)("h4",{id:"siwe"},"SIWE"),(0,r.kt)("p",null,"The ",(0,r.kt)("a",{parentName:"p",href:"https://docs.login.xyz/general-information/siwe-overview"},"SIWE")," (Sign In\nWith Ethereum) proposal was a suggested standard for leveraging Ethereum to\nauthenticate and authorize users on web3 applications.\nIts goal is to establish a standardized method for users to sign in to web3\napplications using their Ethereum address and private key,\nmirroring the process by which users currently sign in to web2 applications\nusing their email and password.\nBelow follows the required steps:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"A server generates a unique Nonce for each user intending to sign in."),(0,r.kt)("li",{parentName:"ol"},"A user initiates a request to connect to a website using their wallet."),(0,r.kt)("li",{parentName:"ol"},"The user is presented with a distinctive message that includes the Nonce and\ndetails about the website."),(0,r.kt)("li",{parentName:"ol"},"The user authenticates their identity by signing in with their wallet."),(0,r.kt)("li",{parentName:"ol"},"Upon successful authentication, the user's identity is confirmed or\napproved."),(0,r.kt)("li",{parentName:"ol"},"The website grants access to data specific to the authenticated user.")),(0,r.kt)("h4",{id:"our-approach"},"Our approach"),(0,r.kt)("p",null,"The idea in the ",(0,r.kt)("a",{parentName:"p",href:"https://eprint.iacr.org/2020/1281"},"DCGKA")," setting closely\nresembles the procedure outlined in SIWE. Here:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"The server corresponds to user D1,who initiates a request (instead of\ngenerating a nonce) to obtain the public key of user D2."),(0,r.kt)("li",{parentName:"ol"},"Upon receiving the request, the wallet of D2 send the request to the user,"),(0,r.kt)("li",{parentName:"ol"},"User D2 receives the request from the wallet, and decides whether accepts or\nrejects."),(0,r.kt)("li",{parentName:"ol"},"The wallet and responds with a message containing the requested public key\nin case of acceptance by D2.")),(0,r.kt)("p",null,"This message may be signed, allowing D1 to verify that the owner of the\nreceived public key is indeed D2."),(0,r.kt)("h3",{id:"multi-device-setting"},"Multi-device setting"),(0,r.kt)("p",null,"One may see the set of devices as a group and create a group key for internal\ncommunications.\nOne may use treeKEM for instance, since it provides interesting properties like\nforward secrecy and post-compromise security.\nAll devices share the same ",(0,r.kt)("inlineCode",{parentName:"p"},"ID"),", which is held by one of them, and from other\nuser\u2019s point of view, they would look as a single user."),(0,r.kt)("p",null,"Using servers, like in the paper\n",(0,r.kt)("a",{parentName:"p",href:"https://eprint.iacr.org/2019/1363"},"Multi-Device for Signal"),", should be\navoided; but this would imply using a particular device as receiver and\nbroadcaster within the group.\nThere is an obvious drawback which is having a single device working as a\n\u201cserver\u201d. Should this device be attacked or without connection, there should be\na mechanism for its revocation and replacement."),(0,r.kt)("p",null,"Another approach for communications between devices could be using the keypair\nof each device. This could open the door to use UPKE, since keypairs should be\nregenerated frequently."),(0,r.kt)("p",null,"Each time a device sends a message, either an internal message or an external\nmessage, it needs to replicate and broadcast it to all devices in the group."),(0,r.kt)("p",null,"The mechanism for the substitution of misbehaving leader devices follows:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Each device within a group knows the details of other leader devices. This\ninformation may come from metadata in received messages, and is replicated by\nthe leader device."),(0,r.kt)("li",{parentName:"ol"},"To replace a leader, the user should select any other device within its\ngroup and use it to send a signed message to all other users."),(0,r.kt)("li",{parentName:"ol"},"To get the ability to sign messages, this new leader should request the\nkeypair associated to the ID to the wallet."),(0,r.kt)("li",{parentName:"ol"},"Once the leader has been changed, it revocates access from DCGKA to the\nformer leader using the DCGKA protocol."),(0,r.kt)("li",{parentName:"ol"},"The new leader starts a key update in DCGKA.")),(0,r.kt)("p",null,"Not all devices in a group should be able to send messages to other users. Only\nthe leader device should be in charge of sending and receiving messages.\nTo prevent other devices from sending messages outside their group, a\nrequirement should be signing each message. The keys associated to the ",(0,r.kt)("inlineCode",{parentName:"p"},"ID"),"\nshould only be in control of the leader device."),(0,r.kt)("p",null,"The leader device is in charge of setting the keys involved in the DCGKA. This\ninformation must be replicated within the group to make sure it is updated."),(0,r.kt)("p",null,"To detect missing messages or potential misbehavior, messages must include a\ncounter."),(0,r.kt)("h3",{id:"using-upke"},"Using UPKE"),(0,r.kt)("p",null,"Managing the group of devices of a user can be done either using a group key\nprotocol such as treeKEM or using the keypair of each device.\nSetting a common key for a group of devices under the control of the same actor\nmight be excessive, furthermore it may imply some of the problems one can find\nin the usual setting of a group of different users;\nfor example: one of the devices may not participate in the required updating\nprocesses, representing a threat for the group."),(0,r.kt)("p",null,"The other approach to managing the group of devices is using each device\u2019s\nkeypair, but it would require each device updating these materia frequently,\nsomething that may not happens."),(0,r.kt)("p",null,(0,r.kt)("a",{parentName:"p",href:"https://eprint.iacr.org/2022/068"},"UPKE")," is a form of asymetric cryptography\nwhere any user can update any other user\u2019s key pair by running an update\nalgorithm with (high-entropy) private coins. Any sender can initiate a ",(0,r.kt)("em",{parentName:"p"},"key\nupdate")," by sending a special update ciphertext.\nThis ciphertext updates the receiver\u2019s public key and also, once processed by\nthe receiver, will update their secret key."),(0,r.kt)("p",null,"To the best of my knowledge, there exists several efficient constructions both\n",(0,r.kt)("a",{parentName:"p",href:"https://eprint.iacr.org/2019/1189"},"UPKE from ElGamal")," (based in the DH\nassumption) and ",(0,r.kt)("a",{parentName:"p",href:"(https://eprint.iacr.org/2023/1400)"},"UPKE from Lattices"),"\n(based in lattices).\nNone of them have been implemented in a secure messaging protocol, and this\nopens the door to some novel research."),(0,r.kt)("h2",{id:"copyright"},"Copyright"),(0,r.kt)("p",null,"Copyright and related rights waived via\n",(0,r.kt)("a",{parentName:"p",href:"https://creativecommons.org/publicdomain/zero/1.0/"},"CC0"),"."),(0,r.kt)("h2",{id:"references"},"References"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://eprint.iacr.org/2020/1281"},"DCGKA")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://messaginglayersecurity.rocks"},"MLS")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://eprint.iacr.org/2022/251"},"CoCoa")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://mattweidner.com/assets/pdf/acs-dissertation.pdf"},"Causal TreeKEM")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://docs.login.xyz/general-information/siwe-overview"},"SIWE")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://eprint.iacr.org/2019/1363"},"Multi-device for Signal")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://eprint.iacr.org/2022/068"},"UPKE")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://eprint.iacr.org/2019/1189"},"UPKE from ElGamal")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"https://eprint.iacr.org/2023/1400"},"UPKE from Lattices"))))}l.isMDXComponent=!0},3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var m=a.createContext({}),p=function(e){var t=a.useContext(m),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=p(e.components);return a.createElement(m.Provider,{value:t},e.children)},l={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},c=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,m=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),c=p(n),h=r,u=c["".concat(m,".").concat(h)]||c[h]||l[h]||i;return n?a.createElement(u,s(s({ref:t},d),{},{components:n})):a.createElement(u,s({ref:t},d))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,s=new Array(i);s[0]=c;var o={};for(var m in t)hasOwnProperty.call(t,m)&&(o[m]=t[m]);o.originalType=e,o.mdxType="string"==typeof e?e:r,s[1]=o;for(var p=2;p<i;p++)s[p]=n[p];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}c.displayName="MDXCreateElement"}}]);