"use strict";(self.webpackChunklogos_docs_template=self.webpackChunklogos_docs_template||[]).push([[6778],{27588:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>p,contentTitle:()=>r,default:()=>c,frontMatter:()=>s,metadata:()=>o,toc:()=>m});var n=a(87462),i=(a(67294),a(3905));const s={title:"LIBP2P-MIX",name:"Libp2p Mix Protocol",status:"raw",category:"Standards Track",editor:"Akshaya Mani &lt;akshaya@status.im&gt;",contributors:"Daniel Kaiser &lt;danielkaiser@status.im&gt;"},r=void 0,o={unversionedId:"raw/mix",id:"raw/mix",title:"LIBP2P-MIX",description:"- Status: raw",source:"@site/vac/raw/mix.md",sourceDirName:"raw",slug:"/raw/mix",permalink:"/vac/raw/mix",draft:!1,tags:[],version:"current",frontMatter:{title:"LIBP2P-MIX",name:"Libp2p Mix Protocol",status:"raw",category:"Standards Track",editor:"Akshaya Mani &lt;akshaya@status.im&gt;",contributors:"Daniel Kaiser &lt;danielkaiser@status.im&gt;"},sidebar:"defaultSidebar",previous:{title:"GOSSIPSUB-TOR-PUSH",permalink:"/vac/raw/gossipsub-tor-push"},next:{title:"NOISE-X3DH-DOUBLE-RATCHET",permalink:"/vac/raw/noise-x3dh-double-ratchet"}},p={},m=[{value:"Abstract",id:"abstract",level:2},{value:"1. Introduction",id:"1-introduction",level:2},{value:"2. Terminology",id:"2-terminology",level:2},{value:"3. Motivation and Background",id:"3-motivation-and-background",level:2},{value:"3.1 Comparison with Tor",id:"31-comparison-with-tor",level:3},{value:"4. Mixing Strategy and Packet Format",id:"4-mixing-strategy-and-packet-format",level:2},{value:"4.1 Mixing Strategy",id:"41-mixing-strategy",level:3},{value:"4.2 Mix Packet Format",id:"42-mix-packet-format",level:3},{value:"5. Protocol Overview",id:"5-protocol-overview",level:2},{value:"5.1 Integration with Origin Protocols",id:"51-integration-with-origin-protocols",level:3},{value:"5.2 Mixify Option",id:"52-mixify-option",level:3},{value:"5.3 Why a Protocol, Not a Transport",id:"53-why-a-protocol-not-a-transport",level:3},{value:"5.4 Protocol Interaction Flow",id:"54-protocol-interaction-flow",level:3},{value:"5.5 Stream Management and Multiplexing",id:"55-stream-management-and-multiplexing",level:3},{value:"6. Pluggable Components",id:"6-pluggable-components",level:2},{value:"6.1 Discovery",id:"61-discovery",level:3},{value:"6.2 Delay Strategy",id:"62-delay-strategy",level:3},{value:"6.3 Spam Protection",id:"63-spam-protection",level:3},{value:"6.4 Cover Traffic",id:"64-cover-traffic",level:3},{value:"6.5 Incentivization",id:"65-incentivization",level:3},{value:"7. Core Mix Protocol Responsibilities",id:"7-core-mix-protocol-responsibilities",level:2},{value:"7.1 Protocol Identifier",id:"71-protocol-identifier",level:3},{value:"7.2 Initiation",id:"72-initiation",level:3},{value:"7.3 Sphinx Packet Receiving and Processing",id:"73-sphinx-packet-receiving-and-processing",level:3},{value:"7.3.1 Intermediary Processing",id:"731-intermediary-processing",level:4},{value:"7.3.2 Exit Processing",id:"732-exit-processing",level:4},{value:"8. Sphinx Packet Format",id:"8-sphinx-packet-format",level:2},{value:"8.1 Packet Structure Overview",id:"81-packet-structure-overview",level:3},{value:"8.2 Cryptographic Primitives",id:"82-cryptographic-primitives",level:3}],l={toc:m};function c(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},l,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Status: raw"),(0,i.kt)("li",{parentName:"ul"},"Category: Standards Track"),(0,i.kt)("li",{parentName:"ul"},"Editor: Akshaya Mani ","<",(0,i.kt)("a",{parentName:"li",href:"mailto:akshaya@status.im"},"akshaya@status.im"),">")),(0,i.kt)("h2",{id:"abstract"},"Abstract"),(0,i.kt)("p",null,"The Mix Protocol defines a decentralized anonymous message routing layer for\nlibp2p networks.\nIt enables sender anonymity by routing each message through a decentralized mix\noverlay network\ncomposed of participating libp2p nodes, known as mix nodes. Each message is\nrouted independently\nin a stateless manner, allowing other libp2p protocols to selectively anonymize\nmessages without\nmodifying their core protocol behavior."),(0,i.kt)("h2",{id:"1-introduction"},"1. Introduction"),(0,i.kt)("p",null,"The Mix Protocol is a custom libp2p protocol that defines a message-layer\nrouting abstraction\ndesigned to provide sender anonymity in peer-to-peer systems built on the libp2p\nstack.\nIt addresses the absence of native anonymity primitives in libp2p by offering a\nmodular,\ncontent-agnostic protocol that other libp2p protocols can invoke when anonymity\nis required."),(0,i.kt)("p",null,"This document describes the design, behavior, and integration of the Mix\nProtocol within the\nlibp2p architecture. Rather than replacing or modifying existing libp2p\nprotocols, the Mix Protocol\ncomplements them by operating independently of connection state and protocol\nnegotiation.\nIt is intended to be used as an optional anonymity layer that can be selectively\napplied on a\nper-message basis."),(0,i.kt)("p",null,"Integration with other libp2p protocols is handled through external interface\ncomponents","\u2014","the Mix Entry\nand Exit layers","\u2014","which mediate between these protocols and the Mix Protocol\ninstances.\nThese components allow applications to defer anonymity concerns to the Mix layer\nwithout altering\ntheir native semantics or transport assumptions."),(0,i.kt)("p",null,"The rest of this document describes the motivation for the protocol, defines\nrelevant terminology,\npresents the protocol architecture, and explains how the Mix Protocol\ninteroperates with the broader\nlibp2p protocol ecosystem."),(0,i.kt)("h2",{id:"2-terminology"},"2. Terminology"),(0,i.kt)("p",null,"The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d,\n\u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d,\n\u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in\n",(0,i.kt)("a",{parentName:"p",href:"https://datatracker.ietf.org/doc/html/rfc2119"},"RFC 2119"),"."),(0,i.kt)("p",null,"The following terms are used throughout this specification:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Origin Protocol"),"\nA libp2p protocol (",(0,i.kt)("em",{parentName:"p"},"e.g.,")," Ping, GossipSub) that generates and receives the\nactual message payload.\nThe origin protocol MUST decide on a per-message basis whether to route the\nmessage through the Mix Protocol\nor not.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Mix Node"),"\nA libp2p node that supports the Mix Protocol and participates in the mix\nnetwork.\nA mix node initiates anonymous routing when invoked with a message.\nIt also receives and processes Sphinx packets when selected as a hop in a mix\npath.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Mix Path"),"\nA non-repeating sequence of mix nodes through which a Sphinx packet is routed\nacross the mix network.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Mixify"),"\nA per-message flag set by the origin protocol to indicate that a message should\nbe routed using\nthe Mix Protocol or not.\nOnly messages with mixify set are forwarded to the Mix Entry Layer.\nOther messages SHOULD be routed using the origin protocol\u2019s default behavior."))),(0,i.kt)("p",null,"The phrases 'messages to be mixified', 'to mixify a message' and related\nvariants are used\ninformally throughout this document to refer to messages that either have the\n",(0,i.kt)("inlineCode",{parentName:"p"},"mixify")," flag set\nor are selected to have it set."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Mix Entry Layer"),"\nA component that receives messages to be ",(0,i.kt)("em",{parentName:"p"},"mixified")," from an origin protocol and\nforwards them to the\nlocal Mix Protocol instance.\nThe Entry Layer is external to the Mix Protocol.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Mix Exit Layer"),"\nA component that receives decrypted messages from a Mix Protocol instance and\ndelivers them\nto the appropriate origin protocol instance at the destination.\nLike the Entry Layer, it is external to the Mix Protocol.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Mixnet or Mix Network"),"\nA decentralized overlay network formed by all nodes that support the Mix\nProtocol.\nIt operates independently of libp2p\u2019s protocol-level routing and origin protocol\nbehavior.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Sphinx Packet"),"\nA cryptographic packet format used by the Mix Protocol to encapsulate messages.\nIt uses layered encryption to hide routing information and protect message\ncontents as packets are forwarded hop-by-hop.\nSphinx packets are fixed-size and indistinguishable from one another, providing\nunlinkability and metadata protection."))),(0,i.kt)("h2",{id:"3-motivation-and-background"},"3. Motivation and Background"),(0,i.kt)("p",null,"libp2p enables modular peer-to-peer applications, but it lacks built-in support\nfor sender anonymity.\nMost protocols expose persistent peer identifiers, transport metadata, or\ntraffic patterns that\ncan be exploited to deanonymize users through passive observation or\ncorrelation."),(0,i.kt)("p",null,"While libp2p supports NAT traversal mechanisms such as Circuit Relay, these\nfocus on connectivity\nrather than anonymity. Relays may learn peer identities during stream setup and\ncan observe traffic\ntiming and volume, offering no protection against metadata analysis."),(0,i.kt)("p",null,"libp2p also supports a Tor transport for network-level anonymity, tunneling\ntraffic through long-lived,\nencrypted circuits. However, Tor relies on session persistence and is ill-suited\nfor protocols\nrequiring per-message unlinkability."),(0,i.kt)("p",null,"The Mix Protocol addresses this gap with a decentralized message routing layer\nbased on classical\nmix network principles. It applies layered encryption and per-hop delays to\nobscure both routing paths\nand timing correlations. Each message is routed independently, providing\nresistance to traffic analysis\nand protection against metadata leakage"),(0,i.kt)("p",null,"By decoupling anonymity from connection state and transport negotiation, the Mix\nProtocol offers\na modular privacy abstraction that existing libp2p protocols can adopt without\naltering their\ncore behavior."),(0,i.kt)("p",null,"To better illustrate the differences in design goals and threat models, the\nfollowing subsection contrasts\nthe Mix Protocol with Tor, a widely known anonymity system."),(0,i.kt)("h3",{id:"31-comparison-with-tor"},"3.1 Comparison with Tor"),(0,i.kt)("p",null,"The Mix Protocol differs fundamentally from Tor in several ways:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Unlinkability"),": In the Mix Protocol, there is no direct connection between\nsource and destination.\nEach message is routed independently, eliminating correlation through persistent\ncircuits.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Delay-based mixing"),": Mix nodes introduce randomized delays (e.g., from an\nexponential distribution)\nbefore forwarding messages, making timing correlation significantly harder.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"High-latency focus"),": Tor prioritizes low-latency communication for\ninteractive web traffic,\nwhereas the Mix Protocol is designed for scenarios where higher latency is\nacceptable\nin exchange for stronger anonymity.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Message-based design"),": Each message in the Mix Protocol is self-contained\nand independently routed.\nNo sessions or state are maintained between messages.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Resistance to endpoint attacks"),": The Mix Protocol is less susceptible to\ncertain endpoint-level attacks,\nsuch as traffic volume correlation or targeted probing, since messages are\ndelayed, reordered, and unlinkable at each hop."))),(0,i.kt)("p",null,"To understand the underlying anonymity properties of the Mix Protocol, we next\ndescribe the core components of a mix network."),(0,i.kt)("h2",{id:"4-mixing-strategy-and-packet-format"},"4. Mixing Strategy and Packet Format"),(0,i.kt)("p",null,"The Mix Protocol relies on two core design elements to achieve sender\nunlinkability and metadata\nprotection: a mixing strategy and a a cryptographically secure mix packet\nformat."),(0,i.kt)("h3",{id:"41-mixing-strategy"},"4.1 Mixing Strategy"),(0,i.kt)("p",null,"A mixing strategy defines how mix nodes delay and reorder incoming packets to\nresist timing\ncorrelation and input-output linkage. Two commonly used approaches are\nbatch-based mixing and\ncontinuous-time mixing."),(0,i.kt)("p",null,"In batching-based mixing, each mix node collects incoming packets over a fixed\nor adaptive\ninterval, shuffles them, and forwards them in a batch. While this provides some\nunlinkability,\nit introduces high latency, requires synchronized flushing rounds, and may\nresult in bursty\noutput traffic. Anonymity is bounded by the batch size, and performance may\ndegrade under variable\nmessage rates."),(0,i.kt)("p",null,"The Mix Protocol instead uses continuous-time mixing, where each mix node\napplies a randomized\ndelay to every incoming packet, typically drawn from an exponential\ndistribution. This enables\ntheoretically unbounded anonymity sets, since any packet may, with non-zero\nprobability,\nbe delayed arbitrarily long. In practice, the distribution is truncated once the\nprobability\nof delay falls below a negligible threshold. Continuous-time mixing also offers\nimproved\nbandwidth utilization and smoother output traffic compared to batching-based\napproaches."),(0,i.kt)("p",null,"To make continuous-time mixing tunable and predictable, the sender MUST select\nthe mean delay\nfor each hop and encode it into the Sphinx packet header. This allows top-level\napplications\nto balance latency and anonymity according to their requirements."),(0,i.kt)("h3",{id:"42-mix-packet-format"},"4.2 Mix Packet Format"),(0,i.kt)("p",null,"A mix packet format defines how messages are encapsulated and routed through a\nmix network.\nIt must ensure unlinkability between incoming and outgoing packets, prevent\nmetadata leakage\n(e.g., path length, hop position, or payload size), and support uniform\nprocessing by mix nodes\nregardless of direction or content."),(0,i.kt)("p",null,"The Mix Protocol uses ",(0,i.kt)("a",{parentName:"p",href:"https://cypherpunks.ca/~iang/pubs/Sphinx_Oakland09.pdf"},"Sphinx\npackets"),"\nto meet these goals.\nEach message is encrypted in layers corresponding to the selected mix path. As a\npacket traverses\nthe network, each mix node removes one encryption layer to obtain the next hop\nand delay,\nwhile the remaining payload remains encrypted and indistinguishable."),(0,i.kt)("p",null,"Sphinx packets are fixed in size and bit-wise unlinkable. This ensures that they\nappear identical\non the wire regardless of payload, direction, or route length, reducing\nopportunities for correlation\nbased on packet size or format. Even mix nodes learn only the immediate routing\ninformation\nand the delay to be applied. They do not learn their position in the path or the\ntotal number of hops."),(0,i.kt)("p",null,"The packet format is resistant to tagging and replay attacks and is compact and\nefficient to\nprocess. Sphinx packets also include per-hop integrity checks and enforces a\nmaximum path length.\nTogether with a constant-size header and payload, this provides bounded\nprotection\nagainst\nendless routing and malformed packet propagation."),(0,i.kt)("p",null,"It also supports anonymous and indistinguishable reply messages through\n",(0,i.kt)("a",{parentName:"p",href:"https://cypherpunks.ca/~iang/pubs/Sphinx_Oakland09.pdf"},"Single-Use Reply Blocks\n(SURBs)"),",\nalthough reply support is not implemented yet."),(0,i.kt)("p",null,"A complete specification of the Sphinx packet structure and fields is provided\nin ","[Section 6]","."),(0,i.kt)("h2",{id:"5-protocol-overview"},"5. Protocol Overview"),(0,i.kt)("p",null,"The Mix Protocol defines a decentralized, message-based routing layer that\nprovides sender anonymity\nwithin the libp2p framework."),(0,i.kt)("p",null,"It is agnostic to message content and semantics. Each message is treated as an\nopaque payload,\nwrapped into a ",(0,i.kt)("a",{parentName:"p",href:"https://cypherpunks.ca/~iang/pubs/Sphinx_Oakland09.pdf"},"Sphinx\npacket")," and routed\nindependently through a randomly selected mix path. Along the path, each mix\nnode removes one layer\nof encryption, adds a randomized delay, and forwards the packet to the next hop.\nThis combination of\nlayered encryption and per-hop delay provides resistance to traffic analysis and\nenables message-level\nunlinkability."),(0,i.kt)("p",null,"Unlike typical custom libp2p protocols, the Mix protocol is stateless","\u2014","it\ndoes not establish\npersistent streams, negotiate protocols, or maintain sessions. Each message is\nself-contained\nand routed independently."),(0,i.kt)("p",null,"The Mix Protocol sits above the transport layer and below the protocol layer in\nthe libp2p stack.\nIt provides a modular anonymity layer that other libp2p protocols MAY invoke\nselectively on a\nper-message basis."),(0,i.kt)("p",null,"Integration with other libp2p protocols is handled through external components\nthat mediate\nbetween the origin protocol and the Mix Protocol instances. This enables\nselective anonymous routing\nwithout modifying protocol semantics or internal behavior."),(0,i.kt)("p",null,"The following subsections describe how the Mix Protocol integrates with origin\nprotocols via\nthe Mix Entry and Exit layers, how per-message anonymity is controlled through\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"mixify")," flag,\nthe rationale for defining Mix as a protocol rather than a transport, and the\nend-to-end message\ninteraction flow."),(0,i.kt)("h3",{id:"51-integration-with-origin-protocols"},"5.1 Integration with Origin Protocols"),(0,i.kt)("p",null,"libp2p protocols that wish to anonymize messages MUST do so by integrating with\nthe Mix Protocol\nvia the Mix Entry and Exit layers."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The ",(0,i.kt)("strong",{parentName:"p"},"Mix Entry Layer")," receives messages to be ",(0,i.kt)("em",{parentName:"p"},"mixified")," from an origin\nprotocol and forwards them\nto the local Mix Protocol instance.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"The ",(0,i.kt)("strong",{parentName:"p"},"Mix Exit Layer")," receives the final decrypted message from a Mix\nProtocol instance and\nforwards it to the appropriate origin protocol instance at the destination over\na client-only connection."))),(0,i.kt)("p",null,"This integration is external to the Mix Protocol and is not handled by mix nodes\nthemselves."),(0,i.kt)("h3",{id:"52-mixify-option"},"5.2 Mixify Option"),(0,i.kt)("p",null,"Some origin protocols may require selective anonymity, choosing to anonymize\n",(0,i.kt)("em",{parentName:"p"},"only")," certain messages\nbased on their content, context, or destination. For example, a protocol may\nonly anonymize messages\ncontaining sensitive metadata while delivering others directly to optimize\nperformance."),(0,i.kt)("p",null,"To support this, origin protocols MAY implement a per-message ",(0,i.kt)("inlineCode",{parentName:"p"},"mixify")," flag that\nindicates whether a message should be routed using the Mix Protocol."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"If the flag is set, the message MUST be handed off to the Mix Entry Layer for\nanonymous routing."),(0,i.kt)("li",{parentName:"ul"},"If the flag is not set, the message SHOULD be routed using the origin\nprotocol\u2019s default mechanism.")),(0,i.kt)("p",null,"This design enables protocols to invoke the Mix Protocol only for selected\nmessages, providing fine-grained control over privacy and performance\ntrade-offs."),(0,i.kt)("h3",{id:"53-why-a-protocol-not-a-transport"},"5.3 Why a Protocol, Not a Transport"),(0,i.kt)("p",null,"The Mix Protocol is specified as a custom libp2p protocol rather than a\ntransport to support\nselective anonymity while remaining compatible with libp2p\u2019s architecture."),(0,i.kt)("p",null,"As noted in ",(0,i.kt)("a",{parentName:"p",href:"#52-mixify-option"},"Section 5.2"),", origin protocols may anonymize\nonly specific messages\nbased on content or context. Supporting such selective behavior requires\ninvoking Mix on a per-message basis."),(0,i.kt)("p",null,"libp2p transports, however, are negotiated per peer connection and apply\nglobally to all messages\nexchanged between two peers. Enabling selective anonymity at the transport layer\nwould\ntherefore require\nchanges to libp2p\u2019s core transport semantics."),(0,i.kt)("p",null,"Defining Mix as a protocol avoids these constraints and offers several benefits:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Supports selective invocation on a per-message basis."),(0,i.kt)("li",{parentName:"ul"},"Works atop existing secure transports (",(0,i.kt)("em",{parentName:"li"},"e.g.,")," QUIC, TLS) without requiring\nchanges to the transport stack."),(0,i.kt)("li",{parentName:"ul"},"Preserves a stateless, content-agnostic model focused on anonymous message\nrouting."),(0,i.kt)("li",{parentName:"ul"},"Integrates seamlessly with origin protocols via the Mix Entry and Exit layers.")),(0,i.kt)("p",null,"This design preserves the modularity of the libp2p stack and allows Mix to be\nadopted without altering existing transport or protocol behavior."),(0,i.kt)("h3",{id:"54-protocol-interaction-flow"},"5.4 Protocol Interaction Flow"),(0,i.kt)("p",null,"A typical end-to-end Mix Protocol flow consists of the following three\nconceptual phases.\nOnly the second phase","\u2014","the anonymous routing performed by mix\nnodes","\u2014","is part of the core\nMix Protocol. The entry-side and exit-side integration steps are handled\nexternally by the Mix Entry\nand Exit layers."),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Entry-side Integration (Mix Entry Layer):")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"The origin protocol generates a message and sets the ",(0,i.kt)("inlineCode",{parentName:"li"},"mixify")," flag."),(0,i.kt)("li",{parentName:"ul"},"The message is passed to the Mix Entry Layer, which invokes the local Mix\nProtocol instance with\nthe message, destination, and origin protocol codec as input."))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Anonymous Routing (Core Mix Protocol):")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"The Mix Protocol instance wraps the message in a Sphinx packet and selects a\nrandom mix path."),(0,i.kt)("li",{parentName:"ul"},"Each mix node along the path:",(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Processes the Sphinx packet by removing one encryption layer."),(0,i.kt)("li",{parentName:"ul"},"Applies a delay and forwards the packet to the next hop."))),(0,i.kt)("li",{parentName:"ul"},"The final node in the path (exit node) decrypts the final layer, extracting\nthe original plaintext message, destination, and origin protocol codec."))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Exit-side Integration (Mix Exit Layer):")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"The Mix Exit Layer receives the plaintext message, destination, and origin\nprotocol codec."),(0,i.kt)("li",{parentName:"ul"},"It routes the message to the destination origin protocol instance using a\nclient-only connection.")))),(0,i.kt)("p",null,"The destination node does not need to support the Mix Protocol to receive or\nrespond\nto anonymous messages."),(0,i.kt)("p",null,"The behavior described above represents the core Mix Protocol. In addition, the\nprotocol\nsupports a set of pluggable components that extend its functionality. These\ncomponents cover\nareas such as node discovery, delay strategy, spam resistance, cover traffic\ngeneration,\nand incentivization. Some are REQUIRED for interoperability; others are OPTIONAL\nor deployment-specific.\nThe next section describes each component."),(0,i.kt)("h3",{id:"55-stream-management-and-multiplexing"},"5.5 Stream Management and Multiplexing"),(0,i.kt)("p",null,"Each Mix Protocol message is routed independently, and forwarding it to the next\nhop requires\nopening a new libp2p stream using the Mix Protocol. This applies to both the\ninitial Sphinx packet\ntransmission and each hop along the mix path."),(0,i.kt)("p",null,"In high-throughput environments (",(0,i.kt)("em",{parentName:"p"},"e.g."),", messaging systems with continuous\nanonymous traffic),\nmix nodes may frequently communicate with a subset of mix nodes. Opening a new\nstream for each\nSphinx packet in such scenarios can incur performance costs, as each stream\nsetup requires a\nmultistream handshake for protocol negotiation."),(0,i.kt)("p",null,"While libp2p supports multiplexing multiple streams over a single transport\nconnection using\nstream muxers such as mplex and yamux, it does not natively support reusing a\nstream over multiple\nmessage transmissions. However, stream reuse may be desirable in the mixnet\nsetting to reduce overhead\nand avoid hitting per protocol stream limits between peers."),(0,i.kt)("p",null,"The lifecycle of streams, including their reuse, eviction, or pooling strategy,\nis outside the\nscope of this specification. It SHOULD be handled by the libp2p host, connection\nmanager, or\ntransport stack."),(0,i.kt)("p",null,"Mix Protocol implementations MUST NOT assume persistent stream availability and\nSHOULD gracefully\nfall back to opening a new stream when reuse is not possible."),(0,i.kt)("h2",{id:"6-pluggable-components"},"6. Pluggable Components"),(0,i.kt)("p",null,"Pluggable components define functionality that extends or configures the\nbehavior of the Mix Protocol\nbeyond its core message routing logic. Each component in this section falls into\none of two categories:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Required for interoperability and path construction (",(0,i.kt)("em",{parentName:"li"},"e.g.,")," discovery, delay\nstrategy)."),(0,i.kt)("li",{parentName:"ul"},"Optional or deployment-specific (",(0,i.kt)("em",{parentName:"li"},"e.g.,")," spam protection, cover traffic,\nincentivization).")),(0,i.kt)("p",null,"The following subsections describe the role and expected behavior of each."),(0,i.kt)("h3",{id:"61-discovery"},"6.1 Discovery"),(0,i.kt)("p",null,"The Mix Protocol does not mandate a specific peer discovery mechanism. However,\nnodes participating in\nthe mixnet MUST be discoverable so that other nodes can construct routing paths\nthat include them."),(0,i.kt)("p",null,"To enable this, regardless of the discovery mechanism used, each mix node MUST\nmake the following\ninformation available to peers:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Indicate Mix Protocol support (",(0,i.kt)("em",{parentName:"li"},"e.g.,")," using a ",(0,i.kt)("inlineCode",{parentName:"li"},"mix")," field or bit)."),(0,i.kt)("li",{parentName:"ul"},"Its X25519 public key for Sphinx encryption."),(0,i.kt)("li",{parentName:"ul"},"One or more routable libp2p multiaddresses that identify the mix node\u2019s own\nnetwork endpoints.")),(0,i.kt)("p",null,"To support sender anonymity at scale, discovery mechanism SHOULD support\n",(0,i.kt)("em",{parentName:"p"},"unbiased random sampling"),"\nfrom the set of live mix nodes. This enables diverse path construction and\nreduces exposure to\nadversarial routing bias."),(0,i.kt)("p",null,"While no existing mechanism provides unbiased sampling by default,\n",(0,i.kt)("a",{parentName:"p",href:"https://rfc.vac.dev/waku/standards/core/33/discv5/"},"Waku\u2019s ambient discovery"),"\n","\u2014"," an extension\nover ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/ethereum/devp2p/blob/master/discv5/discv5.md"},"Discv5"),"\n","\u2014"," demonstrates\nan approximate solution. It combines topic-based capability advertisement with\nperiodic\npeer sampling. A similar strategy could potentially be adapted for the Mix\nProtocol."),(0,i.kt)("p",null,"A more robust solution would involve integrating capability-aware discovery\ndirectly into the\nlibp2p stack, such as through extensions to ",(0,i.kt)("inlineCode",{parentName:"p"},"libp2p-kaddht"),". This would enable\ndirect lookup of\nmix nodes based on protocol support and eliminate reliance on external\nmechanisms such as Discv5.\nSuch an enhancement remains exploratory and is outside the scope of this\nspecification."),(0,i.kt)("p",null,"Regardless of the mechanism, the goal is to ensure mix nodes are discoverable\nand that path selection\nis resistant to bias and node churn."),(0,i.kt)("h3",{id:"62-delay-strategy"},"6.2 Delay Strategy"),(0,i.kt)("p",null,"The Mix Protocol uses per-hop delay as a core mechanism for achieving timing\nunlinkability.\nFor each hop in the mix path, the sender MUST specify a mean delay value, which\nis embedded in\nthe Sphinx packet header. The mix node at each hop uses this value to sample a\nrandomized delay\nbefore forwarding the packet."),(0,i.kt)("p",null,"By default, delays are sampled from an exponential distribution. This supports\ncontinuous-time mixing,\nproduces smooth output traffic, and enables tunable trade-offs between latency\nand anonymity.\nImportantly, it allows for unbounded anonymity sets: each packet may, with\nnon-zero probability,\nbe delayed arbitrarily long."),(0,i.kt)("p",null,"The delay strategy is considered pluggable, and other distributions MAY be used\nto match\napplication-specific anonymity or performance requirements. However, any delay\nstrategy\nMUST ensure that:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Delays are sampled independently at each hop."),(0,i.kt)("li",{parentName:"ul"},"Delay sampling introduces sufficient variability to obscure timing correlation\nbetween packet\narrival and forwarding across multiple hops.")),(0,i.kt)("p",null,"Strategies that produce deterministic or tightly clustered output delays are NOT\nRECOMMENDED,\nas they increase the risk of timing correlation. Delay strategies SHOULD\nintroduce enough uncertainty\nto prevent adversaries from linking packet arrival and departure times, even\nwhen monitoring\nmultiple hops concurrently."),(0,i.kt)("h3",{id:"63-spam-protection"},"6.3 Spam Protection"),(0,i.kt)("p",null,"The Mix Protocol supports optional spam protection mechanisms to defend\nrecipients against\nabusive or unsolicited traffic. These mechanisms are applied at the exit node,\nwhich is the\nfinal node in the mix path before the message is delivered to its destination\nvia the respective\nlibp2p protocol."),(0,i.kt)("p",null,"Exit nodes that enforce spam protection MUST validate the attached proof before\nforwarding\nthe message. If validation fails, the message MUST be discarded."),(0,i.kt)("p",null,"Common strategies include Proof of Work (PoW), Verifiable Delay Functions\n(VDFs), and Rate-limiting Nullifiers (RLNs)."),(0,i.kt)("p",null,"The sender is responsible for appending the appropriate spam protection data\n(e.g., nonce, timestamp)\nto the message payload. The format and verification logic depend on the selected\nmethod.\nAn example using PoW is included in Appendix A."),(0,i.kt)("p",null,"Note: The spam protection mechanisms described above are intended to protect the\ndestination application\nor protocol from message abuse or flooding. They do not provide protection\nagainst denial-of-service (DoS) or\nresource exhaustion attacks targeting the mixnet itself (",(0,i.kt)("em",{parentName:"p"},"e.g.,")," flooding mix\nnodes with traffic,\ninducing processing overhead, or targeting bandwidth)."),(0,i.kt)("p",null,"Protections against attacks targeting the mixnet itself are not defined in this\nspecification\nbut are critical to the long-term robustness of the system. Future versions of\nthe protocol may\ndefine mechanisms to rate-limit clients, enforce admission control, or\nincorporate incentives and\naccountability to defend the mixnet itself from abuse."),(0,i.kt)("h3",{id:"64-cover-traffic"},"6.4 Cover Traffic"),(0,i.kt)("p",null,"Cover traffic is an optional mechanism used to improve privacy by making the\npresence or absence\nof actual messages indistinguishable to observers. It helps achieve\n",(0,i.kt)("em",{parentName:"p"},"unobservability")," where\na passive adversary cannot determine whether a node is sending real messages or\nnot."),(0,i.kt)("p",null,"In the Mix Protocol, cover traffic is limited to ",(0,i.kt)("em",{parentName:"p"},"loop messages")," ","\u2014"," dummy\nSphinx packets\nthat follow a valid mix path and return to the originating node. These messages\ncarry no application\npayload but are indistinguishable from real messages in structure, size, and\nrouting behavior."),(0,i.kt)("p",null,"Cover traffic MAY be generated by either mix nodes or senders. The strategy for\ngenerating\nsuch traffic ","\u2014"," such as timing and frequency ","\u2014"," is pluggable and not\nspecified\nin this document."),(0,i.kt)("p",null,"Implementations that support cover traffic SHOULD generate loop messages at\nrandomized intervals.\nThis helps mask actual sending behavior and increases the effective anonymity\nset. Timing\nstrategies such as Poisson processes or exponential delays are commonly used,\nbut the choice is\nleft to the implementation."),(0,i.kt)("p",null,"In addition to\nenhancing privacy, loop messages can be used to assess network liveness or path\nreliability\nwithout requiring explicit acknowledgments."),(0,i.kt)("h3",{id:"65-incentivization"},"6.5 Incentivization"),(0,i.kt)("p",null,"The Mix Protocol supports a simple tit-for-tat model to discourage free-riding\nand promote\nmix node participation. In this model, nodes that wish to send anonymous\nmessages using the\nMix Protocol MUST also operate a mix node. This requirement ensures that\nparticipants contribute to\nthe anonymity set they benefit from, fostering a minimal form of fairness and\nreciprocity."),(0,i.kt)("p",null,"This tit-for-tat model is intentionally lightweight and decentralized. It deters\npassive use\nof the mixnet by requiring each user to contribute bandwidth and processing\ncapacity. However, it\ndoes not guarantee the quality of service provided by participating nodes. For\nexample, it\ndoes not prevent nodes from running low-quality or misbehaving mix instances,\nnor does it\ndeter participation by compromised or transient peers."),(0,i.kt)("p",null,"The Mix Protocol does not mandate any form of payment, token exchange, or\naccounting. More\nsophisticated economic models ","\u2014"," such as stake-based participation,\ncredentialed relay networks,\nor zero-knowledge proof-of-contribution systems ","\u2014"," MAY be layered on top of\nthe protocol or\nenforced via external coordination."),(0,i.kt)("p",null,"Additionally, network operators or application-layer policies MAY require nodes\nto maintain\nminimum uptime, prove their participation, or adhere to service-level\nguarantees."),(0,i.kt)("p",null,"While the Mix Protocol defines a minimum participation requirement, additional\nincentivization\nextensions are considered pluggable and experimental in this version of the\nspecification.\nNo specific mechanism is standardized."),(0,i.kt)("h2",{id:"7-core-mix-protocol-responsibilities"},"7. Core Mix Protocol Responsibilities"),(0,i.kt)("p",null,"This section defines the core routing behavior of the Mix Protocol, which all\nconforming\nimplementations MUST support."),(0,i.kt)("p",null,"The Mix Protocol defines the logic for anonymously routing messages through the\ndecentralized\nmix network formed by participating libp2p nodes. Each mix node MUST implement\nsupport for:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"initiating anonymous routing when invoked with a message."),(0,i.kt)("li",{parentName:"ul"},"receiving and processing Sphinx packets when selected as a hop in a mix path.")),(0,i.kt)("p",null,"These roles and their required behaviors are defined in the following\nsubsections."),(0,i.kt)("h3",{id:"71-protocol-identifier"},"7.1 Protocol Identifier"),(0,i.kt)("p",null,"The Mix Protocol is identified by the protocol string ",(0,i.kt)("inlineCode",{parentName:"p"},'"/mix/1.0.0"'),"."),(0,i.kt)("p",null,"All Mix Protocol interactions occur over libp2p streams negotiated using this\nidentifier.\nEach Sphinx packet transmission","\u2014","whether initiated locally or forwarded as\npart of a\nmix path","\u2014","involves opening a new libp2p stream to the next hop.\nImplementations MAY optimize\nperformance by reusing streams where appropriate; see ",(0,i.kt)("a",{parentName:"p",href:"#55-stream-management-and-multiplexing"},"Section\n5.5"),"\nfor more details on stream management."),(0,i.kt)("h3",{id:"72-initiation"},"7.2 Initiation"),(0,i.kt)("p",null,"A mix node initiates anonymous routing only when it is explicitly invoked with a\nmessage\nto be routed. As specified in ",(0,i.kt)("a",{parentName:"p",href:"#52-mixify-option"},"Section 5.2"),", the decision to\nanonymize a\nmessage is made by the origin protocol. When anonymization is required, the\norigin protocol instance\nforwards the message to the Mix Entry Layer, which then passes the message to\nthe local\nMix Protocol instance for routing."),(0,i.kt)("p",null,"To perform message initiation, a mix node MUST:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Select a random mix path."),(0,i.kt)("li",{parentName:"ul"},"Assign a delay value for each hop and encode it into the Sphinx packet header."),(0,i.kt)("li",{parentName:"ul"},"Wrap message in a Sphinx packet by applying layered encryption in reverse\norder of nodes\nin the selected mix path."),(0,i.kt)("li",{parentName:"ul"},"Forward the resulting packet to the first mix node in the mix path using the\nMix Protocol.")),(0,i.kt)("p",null,"The Mix Protocol does not interpret message content or origin protocol context.\nEach invocation is\nstateless, and the implementation MUST NOT retain routing metadata or\nper-message state\nafter the packet is forwarded."),(0,i.kt)("h3",{id:"73-sphinx-packet-receiving-and-processing"},"7.3 Sphinx Packet Receiving and Processing"),(0,i.kt)("p",null,"A mix node that receives a Sphinx packet is oblivious to its position in the\npath. The\nfirst hop is indistinguishable from other intermediary hops in terms of\nprocessing and behavior."),(0,i.kt)("p",null,"After decrypting one layer of the Sphinx packet, the node MUST inspect the\nrouting information.\nIf this layer indicates that the next hop is the final destination, the packet\nMUST be processed\nas an exit. Otherwise, it MUST be processed as an intermediary."),(0,i.kt)("h4",{id:"731-intermediary-processing"},"7.3.1 Intermediary Processing"),(0,i.kt)("p",null,"To process a Sphinx packet as an intermediary, a mix node MUST:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Extract the next hop address and associated delay from the decrypted packet."),(0,i.kt)("li",{parentName:"ul"},"Wait for the specified delay."),(0,i.kt)("li",{parentName:"ul"},"Forward the updated packet to the next hop using the Mix Protocol.")),(0,i.kt)("p",null,"A mix node performing intermediary processing MUST treat each packet as\nstateless and self-contained."),(0,i.kt)("h4",{id:"732-exit-processing"},"7.3.2 Exit Processing"),(0,i.kt)("p",null,"To process a Sphinx packet as an exit, a mix node MUST:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Extract the plaintext message from the final decrypted packet."),(0,i.kt)("li",{parentName:"ul"},"Validate any attached spam protection proof."),(0,i.kt)("li",{parentName:"ul"},"Discard the message if spam protection validation fails."),(0,i.kt)("li",{parentName:"ul"},"Forward the valid message to the Mix Exit Layer for delivery to the\ndestination origin protocol instance.")),(0,i.kt)("p",null,"The node MUST NOT retain decrypted content after forwarding."),(0,i.kt)("h2",{id:"8-sphinx-packet-format"},"8. Sphinx Packet Format"),(0,i.kt)("p",null,"The Mix Protocol uses the Sphinx packet format to enable unlinkable, multi-hop\nmessage routing\nwith per-hop confidentiality and integrity. Each message transmitted through the\nmix network is\nencapsulated in a Sphinx packet constructed by the initiating mix node. The\npacket is encrypted in\nlayers such that each hop in the mix path can decrypt exactly one layer and\nobtain the next-hop\nrouting information and delay value, without learning the complete path or the\nmessage origin."),(0,i.kt)("p",null,"Sphinx packets are self-contained and indistinguishable on the wire, providing\nstrong metadata\nprotection. Mix nodes forward packets without retaining state or requiring\nknowledge of the\nsource or destination beyond their immediate routing target."),(0,i.kt)("p",null,"To ensure uniformity, each Sphinx packet consists of a fixed-length header and a\npayload\nthat is padded to a fixed maximum size. Although the original message payload\nmay vary in length,\npadding ensures that all packets are identical in size on the wire. This ensures\nunlinkability\nand protects against correlation attacks based on message size."),(0,i.kt)("p",null,"If a message exceeds the maximum supported payload size, it MUST be fragmented\nbefore being passed\nto the Mix Protocol. Fragmentation and reassembly are the responsibility of the\norigin protocol\nor the top-level application. The Mix Protocol handles only messages that do not\nrequire\nfragmentation."),(0,i.kt)("p",null,"The structure, encoding, and size constraints of the Sphinx packet are detailed\nin the following\nsubsections."),(0,i.kt)("h3",{id:"81-packet-structure-overview"},"8.1 Packet Structure Overview"),(0,i.kt)("p",null,"Each Sphinx packet consists of three fixed-length header fields ","\u2014"," ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"\u03b1")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\u03b1")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.0037em"}},"\u03b1"))))),",\n",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"\u03b2")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\u03b2")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8889em",verticalAlign:"-0.1944em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.05278em"}},"\u03b2"))))),", and ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"\u03b3")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\u03b3")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.05556em"}},"\u03b3")))))," ","\u2014","\nfollowed by a fixed-length encrypted payload ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"\u03b4")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\u03b4")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6944em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03785em"}},"\u03b4"))))),". Together, these components\nenable per-hop message\nprocessing with strong confidentiality and integrity guarantees in a stateless\nand unlinkable manner."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("span",{parentName:"strong",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"\u03b1")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\u03b1")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.0037em"}},"\u03b1")))))," (Alpha)"),": An ephemeral public value. Each mix node uses its private key\nand ",(0,i.kt)("span",{parentName:"li",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"\u03b1")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\u03b1")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.0037em"}},"\u03b1")))))," to\nderive a shared session key for that hop. This session key is used to decrypt\nand process\none layer of the packet."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("span",{parentName:"strong",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"\u03b2")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\u03b2")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8889em",verticalAlign:"-0.1944em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.05278em"}},"\u03b2")))))," (Beta)"),": The nested encrypted routing information. It encodes the next\nhop address, the forwarding delay,\nintegrity check ",(0,i.kt)("span",{parentName:"li",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"\u03b3")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\u03b3")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.05556em"}},"\u03b3")))))," for the next hop, and the ",(0,i.kt)("span",{parentName:"li",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"\u03b2")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\u03b2")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8889em",verticalAlign:"-0.1944em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.05278em"}},"\u03b2")))))," for subsequent hops."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("span",{parentName:"strong",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"\u03b3")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\u03b3")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.05556em"}},"\u03b3")))))," (Gamma)"),": A message authentication code computed over ",(0,i.kt)("span",{parentName:"li",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"\u03b2")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\u03b2")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8889em",verticalAlign:"-0.1944em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.05278em"}},"\u03b2")))))," using the\nsession key derived\nfrom ",(0,i.kt)("span",{parentName:"li",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"\u03b1")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\u03b1")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.0037em"}},"\u03b1"))))),". It ensures header integrity at each hop."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},(0,i.kt)("span",{parentName:"strong",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"\u03b4")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\u03b4")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6944em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03785em"}},"\u03b4")))))," (Delta)"),": The encrypted payload. It consists of the message padded to a\nfixed maximum length and\nencrypted in layers corresponding to each hop in the mix path.")),(0,i.kt)("p",null,"At each hop, the mix node derives the session key from ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"\u03b1")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\u03b1")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.0037em"}},"\u03b1"))))),", verifies the header\nintegrity\nusing ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"\u03b3")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\u03b3")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.05556em"}},"\u03b3"))))),", decrypts one layer of ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"\u03b2")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\u03b2")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8889em",verticalAlign:"-0.1944em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.05278em"}},"\u03b2")))))," to extract the next hop and delay, and\ndecrypts one layer\nof ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"\u03b4")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\u03b4")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6944em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03785em"}},"\u03b4"))))),". It then constructs a new packet with updated values of ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"\u03b1")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\u03b1")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.0037em"}},"\u03b1"))))),", ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"\u03b2")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\u03b2")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8889em",verticalAlign:"-0.1944em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.05278em"}},"\u03b2"))))),", ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"\u03b3")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\u03b3")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.05556em"}},"\u03b3"))))),",\nand ",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"\u03b4")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\u03b4")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6944em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03785em"}},"\u03b4"))))),", and\nforwards it to the next hop."),(0,i.kt)("p",null,"All Sphinx packets are fixed in size and indistinguishable on the wire. This\nuniform format,\ncombined with layered encryption and per-hop integrity protection, ensures\nunlinkability,\ntamper resistance, and robustness against correlation attacks."),(0,i.kt)("p",null,"The structure and semantics of these fields, the cryptographic primitives used,\nand the construction\nand processing steps are defined in the following subsections."),(0,i.kt)("h3",{id:"82-cryptographic-primitives"},"8.2 Cryptographic Primitives"),(0,i.kt)("p",null,"This section defines the cryptographic primitives used in Sphinx packet\nconstruction and processing."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Security Parameter"),": All cryptographic operations target a minimum of\n",(0,i.kt)("span",{parentName:"p",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"\u03ba"),(0,i.kt)("mo",{parentName:"mrow"},"="),(0,i.kt)("mn",{parentName:"mrow"},"128")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\kappa = 128")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal"},"\u03ba"),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}}),(0,i.kt)("span",{parentName:"span",className:"mrel"},"="),(0,i.kt)("span",{parentName:"span",className:"mspace",style:{marginRight:"0.2778em"}})),(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6444em"}}),(0,i.kt)("span",{parentName:"span",className:"mord"},"128")))))," bits of\nsecurity, balancing performance with resistance to modern attacks.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Elliptic Curve Group ",(0,i.kt)("span",{parentName:"strong",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow",mathvariant:"double-struck"},"G")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\\mathbb{G}")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6889em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathbb"},"G")))))),":"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Curve"),": Curve25519"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Purpose"),": Used for deriving Diffie\u2013Hellman-style shared key at each hop\nusing ",(0,i.kt)("span",{parentName:"li",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"\u03b1")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\u03b1")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.4306em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.0037em"}},"\u03b1"))))),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Representation"),": Small 32-byte group elements, efficient for both\nencryption and key exchange."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Key Derivation Function (KDF)"),":"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Purpose"),": To derive encryption keys, IVs, and MAC key from the shared\nsession key at each hop."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Construction"),": SHA-256 hash with output truncated to 128 bits."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Key Derivation"),": The KDF key separation labels (",(0,i.kt)("em",{parentName:"li"},"e.g.,")," ",(0,i.kt)("inlineCode",{parentName:"li"},'"aes_key"'),",\n",(0,i.kt)("inlineCode",{parentName:"li"},'"mac_key"'),")\nare fixed strings and MUST be agreed upon across implementations."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Symmetric Encryption"),": AES-128 in Counter Mode (AES-CTR)"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Purpose"),": To encrypt ",(0,i.kt)("span",{parentName:"li",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"\u03b2")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\u03b2")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.8889em",verticalAlign:"-0.1944em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.05278em"}},"\u03b2")))))," and ",(0,i.kt)("span",{parentName:"li",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"\u03b4")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\u03b4")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.6944em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.03785em"}},"\u03b4")))))," for each hop."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Keys and IVs"),": Each derived from the session key for the hop using the KDF."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Message Authentication Code (MAC)"),":"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Construction"),": HMAC-SHA-256 with output truncated to 128 bits."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Purpose"),": To compute ",(0,i.kt)("span",{parentName:"li",className:"math math-inline"},(0,i.kt)("span",{parentName:"span",className:"katex"},(0,i.kt)("span",{parentName:"span",className:"katex-mathml"},(0,i.kt)("math",{parentName:"span",xmlns:"http://www.w3.org/1998/Math/MathML"},(0,i.kt)("semantics",{parentName:"math"},(0,i.kt)("mrow",{parentName:"semantics"},(0,i.kt)("mi",{parentName:"mrow"},"\u03b3")),(0,i.kt)("annotation",{parentName:"semantics",encoding:"application/x-tex"},"\u03b3")))),(0,i.kt)("span",{parentName:"span",className:"katex-html","aria-hidden":"true"},(0,i.kt)("span",{parentName:"span",className:"base"},(0,i.kt)("span",{parentName:"span",className:"strut",style:{height:"0.625em",verticalAlign:"-0.1944em"}}),(0,i.kt)("span",{parentName:"span",className:"mord mathnormal",style:{marginRight:"0.05556em"}},"\u03b3")))))," for each hop."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Key"),": Derived using KDF from the session key for the hop.")))),(0,i.kt)("p",null,"These primitives are used consistently throughout packet construction and\ndecryption, as described in the following sections."))}c.isMDXComponent=!0},3905:(e,t,a)=>{a.d(t,{Zo:()=>l,kt:()=>d});var n=a(67294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function r(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var p=n.createContext({}),m=function(e){var t=n.useContext(p),a=t;return e&&(a="function"==typeof e?e(t):r(r({},t),e)),a},l=function(e){var t=m(e.components);return n.createElement(p.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,s=e.originalType,p=e.parentName,l=o(e,["components","mdxType","originalType","parentName"]),h=m(a),d=i,k=h["".concat(p,".").concat(d)]||h[d]||c[d]||s;return a?n.createElement(k,r(r({ref:t},l),{},{components:a})):n.createElement(k,r({ref:t},l))}));function d(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var s=a.length,r=new Array(s);r[0]=h;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o.mdxType="string"==typeof e?e:i,r[1]=o;for(var m=2;m<s;m++)r[m]=a[m];return n.createElement.apply(null,r)}return n.createElement.apply(null,a)}h.displayName="MDXCreateElement"}}]);